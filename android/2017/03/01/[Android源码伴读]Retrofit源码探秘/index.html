
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>【Android源码伴读】Retrofit源码探秘 | hjhjw1991&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="hjhjw1991">
    

    
    <meta name="description" content="本文讲Retrofit. 总的来说它是一个面向业务流程的网络请求库, 内部默认使用面向网络协议的库OkHttp来打出成吨伤害.">
<meta property="og:type" content="article">
<meta property="og:title" content="【Android源码伴读】Retrofit源码探秘">
<meta property="og:url" content="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/index.html">
<meta property="og:site_name" content="hjhjw1991's blog">
<meta property="og:description" content="本文讲Retrofit. 总的来说它是一个面向业务流程的网络请求库, 内部默认使用面向网络协议的库OkHttp来打出成吨伤害.">
<meta property="og:image" content="https://hjhjw1991.github.io/images/blogs/retrofit_okhttp.png">
<meta property="og:updated_time" content="2017-03-05T11:15:49.483Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Android源码伴读】Retrofit源码探秘">
<meta name="twitter:description" content="本文讲Retrofit. 总的来说它是一个面向业务流程的网络请求库, 内部默认使用面向网络协议的库OkHttp来打出成吨伤害.">
<meta name="twitter:image" content="https://hjhjw1991.github.io/images/blogs/retrofit_okhttp.png">

    
    <link rel="alternative" href="/atom.xml" title="hjhjw1991&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.png">
    <link rel="apple-touch-icon-precomposed" href="/img/author.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="hjhjw1991&#39;s blog" title="hjhjw1991&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="hjhjw1991&#39;s blog">hjhjw1991&#39;s blog</a></h1>
				<h2 class="blog-motto">Coder, Learn</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 8741923514077570040 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/" title="【Android源码伴读】Retrofit源码探秘" itemprop="url">【Android源码伴读】Retrofit源码探秘</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="hjhjw1991" target="_blank" itemprop="author">hjhjw1991</a>
		
  <p class="article-time">
    <time datetime="2017-02-28T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-03-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit的使用"><span class="toc-number">1.</span> <span class="toc-text">Retrofit的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit源码探秘"><span class="toc-number">2.</span> <span class="toc-text">Retrofit源码探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit注解定义和解析"><span class="toc-number">2.1.</span> <span class="toc-text">Retrofit注解定义和解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit的Call与Response"><span class="toc-number">2.2.</span> <span class="toc-text">Retrofit的Call与Response</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit的Converter与CallAdapter-开始使用RxJava"><span class="toc-number">2.3.</span> <span class="toc-text">Retrofit的Converter与CallAdapter: 开始使用RxJava</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol>
		
		</div>
		
		<p>截至我写文章为止, <code>Retrofit</code>更新到了<code>2.2.0</code>版本. 据说<code>1.x</code>与<code>2.0+</code>差异巨大, 这里我们就直接拥抱变化来看最新代码了.  </p>
<h2 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h2><p>添加依赖和添加网络权限我就不说了. 假设我们要访问网络获取一个<code>Json</code>格式的响应, 来看代码怎么写:  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
                    .baseUrl(&quot;http://url.of.yourserver/&quot;)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build(); // 创建全局管理
HttpService httpService = retrofit.create(YourHttpService.class); // 创建访问接口实例
Call&lt;Json&gt; call = httpService.getJson(); // 为要访问的接口创建Call
call.enqueue(new YourCallbackForThisCall(){...}); // Call入队列并添加回调
</code></pre><p>非常简单对不对, 而且<code>YourHttpService.class</code>甚至可能根据某种规范直接从服务端导出, 需要自己手写的代码几乎可以忽略不计, 出bug的几率就更小了.<br>这里的<code>Callback</code>经我验证是在UI线程执行的, 所以可以直接在<code>onResponse</code>里更新UI. 如果想要换到其他线程处理, 需要设置<code>callbackExecutor</code>, 默认是主线程.  </p>
<h2 id="Retrofit源码探秘"><a href="#Retrofit源码探秘" class="headerlink" title="Retrofit源码探秘"></a>Retrofit源码探秘</h2><p>根据我们前面分析过的<code>OkHttp</code>源码可以知道, <code>Retrofit</code>背后的请求发送和接收都是通过它来完成的, 自己几乎没做什么. <code>Retrofit</code>能实现这么简单的调用方式, 其魔法就在它的抽象架构上. <code>Retrofit</code>通过定义和解析注解的方式生成<code>Request</code>, 又在原本<code>OkHttpCall</code>(<code>Retrofit</code>定义的<code>OkHttp</code>的代理)的回调之中加了一层, 用于处理响应出错情况和把响应结果包装成<code>ExceptionCatchingRequestBody</code>, 最后用<code>ServiceMethod.toResponse</code>使用<code>Converter</code>完成响应解析, 使用解析结果通过<code>CallAdapter</code>构造一个自定义的<code>Response&lt;T&gt;</code>并返回. 再在外层回调我们设置的<code>Callback&lt;T&gt;</code>.<br>真正的网络请求的事情包括连接和缓存的维护都交给<code>OkHttpClient</code>完成了, 因此关键就在于<code>Retrofit</code>从注解到<code>Call</code>的过程和从<code>Response</code>到<code>Response&lt;T&gt;</code>的过程.  </p>
<h3 id="Retrofit注解定义和解析"><a href="#Retrofit注解定义和解析" class="headerlink" title="Retrofit注解定义和解析"></a>Retrofit注解定义和解析</h3><p>在我之前的某篇文章中曾经解析过<code>Java</code>的<code>Annotation</code>机制, 这里就不再解释了, 我们已经知道, <code>Java</code>的注解是通过注解处理器<code>Processor</code>进行处理的, <code>Retrofit</code>应该也是实现了类似的机制去处理它自己的注解. 注解都是编译器完成处理的, 其处理后的代码的生命周期根据它的<code>Retention</code>不同而不同, <code>Retention</code>为<code>RUNTIME</code>的注解在编译器处理之后存在于<code>.class</code>文件中并且还被虚拟机载入, 所以可供后续处理. 接下来我们就来看看<code>Retrofit</code>中的注解定义和解析器的定义, 我们将会发现它所有的注解都是<code>RUNTIME</code>的.<br>注解都在<code>http</code>包下, 从名字也看得出来基本上对应了<code>http</code>协议中的各个实体. 我们只看其中<code>GET</code> <code>Headers</code> <code>Streaming</code>三个.<br>选这三个的原因是三个在<code>http</code>协议中分别代表三种类型: 请求方法, 结构参数, 传输标记. 如果不记得<code>http</code>协议的同学可以看我另一篇博客<a href="/images/blogs/network.md">Android源码解析-网络架构</a>.<br>三个注解的完整代码如下:  </p>
<pre><code>@Target(METHOD)
@Retention(RUNTIME)
public @interface GET {
  /**
   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
   * parameter of the method is annotated with {@link Url @Url}.
   * &lt;p&gt;
   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
   * this is resolved against a base URL to create the full endpoint URL.
   */
  String value() default &quot;&quot;;
}

/**
 * Adds headers literally supplied in the {@code value}.
 * &lt;pre&gt;&lt;code&gt;
 * &amp;#64;Headers(&quot;Cache-Control: max-age=640000&quot;)
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 *
 * &amp;#64;Headers({
 *   &quot;X-Foo: Bar&quot;,
 *   &quot;X-Ping: Pong&quot;
 * })
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; Headers do not overwrite each other. All headers with the same name will
 * be included in the request.
 *
 * @see Header
 * @see HeaderMap
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Headers {
  String[] value();
}

/**
 * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
 * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Streaming {
}
</code></pre><p>为避免各位说我凑篇幅, 请各位仔细看上文代码的注释部分和注解部分, 我们可以看到这几个注解的设计思路, 基本上是按照<code>http</code>协议的基本部分来分解的, 并且都有明确的作用对象和作用范围.<br>对这三种类型的注解的处理自然也是不太一样, 接下来我们就看看<code>Retrofit</code>为它的这些注解编写了怎样的处理器. 注解的转存在<code>ServiceMethod.Builder()</code>中, 处理则在<code>ServiceMethod.Builder.build()</code>中, 如下:  </p>
<pre><code>public ServiceMethod build() {
  ...
  // Method级别的Annotation, 主要是GET/POST等方法
  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }
  ...
  // Parameter级别的Annotation, 主要是Path等
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }
 ...
}

// 处理Method级别Annotation
private void parseMethodAnnotation(Annotation annotation) {
  if (annotation instanceof DELETE) {
    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
  } else if (annotation instanceof GET) {
    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
  } else if (annotation instanceof HEAD) {
    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);
    if (!Void.class.equals(responseType)) {
      throw methodError(&quot;HEAD method must use Void as response type.&quot;);
    }
  } else if (annotation instanceof PATCH) {
    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);
  } else if (annotation instanceof POST) {
    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
  } else if (annotation instanceof PUT) {
    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);
  } else if (annotation instanceof OPTIONS) {
    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);
  } else if (annotation instanceof HTTP) {
    HTTP http = (HTTP) annotation;
    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
  } else if (annotation instanceof retrofit2.http.Headers) {
    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    if (headersToParse.length == 0) {
      throw methodError(&quot;@Headers annotation is empty.&quot;);
    }
    headers = parseHeaders(headersToParse);
  } else if (annotation instanceof Multipart) {
    if (isFormEncoded) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isMultipart = true;
  } else if (annotation instanceof FormUrlEncoded) {
    if (isMultipart) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isFormEncoded = true;
  }
}

// 处理Parameter级别Annotation
private ParameterHandler&lt;?&gt; parseParameter(
    int p, Type parameterType, Annotation[] annotations) {
  ParameterHandler&lt;?&gt; result = null;
  for (Annotation annotation : annotations) {
    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(
        p, parameterType, annotations, annotation);

    ...// handleException

    result = annotationAction;
  }
  ...// handleException

  return result;
}

// 具体的处理Annotation的实现, 方法颇长就不贴详情了
private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type type, Annotation[] annotations, Annotation annotation) {
  if (annotation instanceof Url) { // handle @Url
    ...// throw Exception if necessary

    gotUrl = true;

    if (type == HttpUrl.class
        || type == String.class
        || type == URI.class
        || (type instanceof Class &amp;&amp; &quot;android.net.Uri&quot;.equals(((Class&lt;?&gt;) type).getName()))) {
      return new ParameterHandler.RelativeUrl();
    } else {
      ...// throw Exception
    }

  } else if (annotation instanceof Path) { // handle @Path
    ...// throw Exception if necessary

    gotPath = true;

    Path path = (Path) annotation;
    String name = path.value();
    validatePathName(p, name);

    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations); // 见Retrofit.stringConverter()
    return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded()); // 见ParameterHandler.Path&lt;&gt;

  } else if (annotation instanceof Query) { // handle @Query
  } else if (annotation instanceof QueryName) { // handle @QueryName
  } else if (annotation instanceof Header) { // handle @Header
  } else if (annotation instanceof FieldMap) { // handle @FieldMap
  } else if (annotation instanceof Part) { // handle @Part
  } else if (annotation instanceof PartMap) { // handle @PartMap
  } else if (annotation instanceof Body) { // handle @Body
  }
  return null; // Not a Retrofit annotation.
}
</code></pre><p>可见<code>Retrofit</code>对注解的处理分为两个部分: 一个是<code>Method</code>级别的<code>Annotation</code>, 所有<code>http</code>协议方法都被定义为该级别的<code>Annotation</code>, 在<code>ServiceMethod.parseHttpMethodAndPath</code>中处理(注意到, 基本方法<code>DELETE</code> <code>GET</code> <code>HEAD</code> <code>POST</code>等应该是互斥的, 但代码中没有进行判断, 而<code>Multipard</code>和<code>FormUrlEncoded</code>之间却进行了判断, 至于代码中没有对<code>Streaming</code>的处理, 是因为逻辑上它不在这一层, 而是在响应结果的解析, 所以其实是在<code>retrofit2/BuiltInConverters.java</code>中进行了处理); 另一个是<code>Parameter</code>级别的, 大多数是在进行基本预处理之后就委托给<code>ParameterHandler</code>接口的实现类进行处理.  </p>
<p>通过对某个方法的注解的处理, 在<code>ServiceMethod.Builder.build()</code>完成后<code>ServiceMethod</code>就获取到了调用该方法发起网络请求所需要的信息, 可以开始构造<code>Call</code>了.  </p>
<h3 id="Retrofit的Call与Response"><a href="#Retrofit的Call与Response" class="headerlink" title="Retrofit的Call与Response"></a>Retrofit的Call与Response</h3><p><code>Retrofit</code>的<code>Call</code>和<code>Response</code>是对<code>OkHttp</code>的<code>Call</code>和<code>Response</code>的封装, 为什么要进行这么一层封装呢? 接下来我们就看看它的源码.<br>我们选择从核心方法<code>Retrofit.create(Class)</code>开始.  </p>
<pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service); // #1
  if (validateEagerly) {
    eagerlyValidateMethods(service); // #2
  }

  // #3 below
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
        private final Platform platform = Platform.get();

        @Override public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
          // If the method is a method from Object then defer to normal invocation.
          if (method.getDeclaringClass() == Object.class) {
            return method.invoke(this, args);
          }
          if (platform.isDefaultMethod(method)) {
            return platform.invokeDefaultMethod(method, service, proxy, args);
          }
          ServiceMethod&lt;Object, Object&gt; serviceMethod =
              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); // #4
          OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // #5
          return serviceMethod.callAdapter.adapt(okHttpCall); // #6
        }
      });
}
</code></pre><p>这里面一共有三个步骤, 其中前两步是用来检查接口和提前载入方法的, 第三步是关键, 生成并返回了一个代理. 实例化代理时传入了三个参数, 第三个是<code>InvocationHandler</code>的实现, 我们可以看到里面最关键的步骤是<code>#4 #5 #6</code>, 分别完成方法载入(<code>Method-&gt;ServiceMethod</code>), <code>Call</code>构造和返回<code>Call</code>代理. 这里<code>Proxy</code>及<code>InvocationHandler</code>都是<code>Java</code>中就已经存在并引入了<code>Android</code>中的机制, 即动态代理机制. 关于动态代理机制, 思想成熟战法犀利, 是相当有意思的一个东西, 可以参见<a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">这篇文章</a><br>总之要使用动态代理呢, 委托类必须要实现某个接口, 而<code>Proxy</code>创建的代理类通过实现<code>InvocationHandler</code>来调用委托类的方法, 完成代理. 所有这一切都跟反射密不可分, 所以理所当然<code>Proxy</code>是在反射包下的.<br>从上面代码可以看出, <code>Platform.isDefaultMethod()</code>和<code>Object</code>的方法将被<code>InvocationHandler</code>直接代理执行, 而其他方法则被包装成<code>OkHttpCall</code>交给<code>ServiceMethod</code>的<code>CallAdapter</code>去执行. 这里也可以看出对<code>Call</code>和<code>Response</code>进行封装代理的作用: 屏蔽底层实现, 统一处理非核心逻辑, 统一接口, 令底层替换成其他网络访问库成为可能.  </p>
<p>下面我们来看<code>ServiceMethod</code>的构造过程, <code>OkHttpCall</code>的构造过程以及默认的<code>CallAdapter</code>的代码.<br>还记得在<code>create</code>里传入<code>loadServiceMethod</code>的是<code>Method method</code>, 它是代理方法, 通过它去访问委托(被代理)方法, 代码如下:  </p>
<pre><code>ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {
  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);
  if (result != null) return result;

  synchronized (serviceMethodCache) {
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); // 传入Retrofit, Method实例, 构造代理包装类ServiceMethod实例
      serviceMethodCache.put(method, result); // 缓存代理方法-代理包装实例映射
    }
  }
  return result;
}
</code></pre><p>然后根据传入的方法及其参数, 构造一个合适的<code>Call</code>, 这个<code>Call</code>是<code>OkHttp</code>中<code>Call</code>的代理, 所以<code>Retrofit</code>中它的类是<code>OkHttpCall</code>. 下面我们看它是怎么构造和代理的, 代码如下:  </p>
<pre><code>final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; {
    OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) {
      this.serviceMethod = serviceMethod;
      this.args = args;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      // 检查参数

      okhttp3.Call call;
      Throwable failure;

      synchronized (this) {
        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);
        executed = true;

        call = rawCall;
        failure = creationFailure;
        if (call == null &amp;&amp; failure == null) {
          try {
            call = rawCall = createRawCall();
          } catch (Throwable t) {
            failure = creationFailure = t;
          }
        }
      }

      if (failure != null) {
        callback.onFailure(this, failure);
        return;
      }

      if (canceled) {
        call.cancel();
      }

      call.enqueue(new okhttp3.Callback() { // okhttp3.Callback反向代理retrofit2.Callback
        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
            throws IOException {
          Response&lt;T&gt; response;
          try {
            response = parseResponse(rawResponse); // 解析响应
          } catch (Throwable e) {
            callFailure(e); // 回调自身callFailure
            return;
          }
          callSuccess(response); // 回调自身callSuccess
        }

        @Override public void onFailure(okhttp3.Call call, IOException e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callFailure(Throwable e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callSuccess(Response&lt;T&gt; response) {
          try {
            callback.onResponse(OkHttpCall.this, response);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }
      });
    }
}
</code></pre><p>结构清晰, 基本可以当做<code>OkHttpCall</code>来对待.  </p>
<p>接下来通过<code>ServiceMethod.callAdapter.adapt(OkHttpCall)</code>将<code>OkHttpCall</code>转换为<code>Call&lt;T&gt;</code>. <code>ServiceMethod</code>的建造模式如下:  </p>
<pre><code>Builder(Retrofit retrofit, Method method) {
  this.retrofit = retrofit;
  this.method = method;
  this.methodAnnotations = method.getAnnotations(); # 获取代理方法的方法注解
  this.parameterTypes = method.getGenericParameterTypes(); # 获取泛型参数类型
  this.parameterAnnotationsArray = method.getParameterAnnotations(); # 获取参数注解
}

public ServiceMethod build() {
  callAdapter = createCallAdapter(); # 根据泛型返回类型和方法注解, 通过retrofit.callAdapter(returnType, annotations)寻找适配器实例. Retrofit实例化时默认添加`DefaultCallAdapterFactory`工厂
  responseType = callAdapter.responseType(); # 获取返回类型
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;&apos;&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;); # 不允许以`Response`作为返回类型
  }
  responseConverter = createResponseConverter();

  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation); # 解析方法注解
  }

  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }

  ...// 判断方法注解合法性

  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    // 解析参数注解
    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    ...
    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  ...// 判断参数合法性

  return new ServiceMethod&lt;&gt;(this);
}

ServiceMethod(Builder&lt;R, T&gt; builder) {
  this.callFactory = builder.retrofit.callFactory();
  this.callAdapter = builder.callAdapter;
  this.baseUrl = builder.retrofit.baseUrl();
  this.responseConverter = builder.responseConverter;
  this.httpMethod = builder.httpMethod;
  this.relativeUrl = builder.relativeUrl;
  this.headers = builder.headers;
  this.contentType = builder.contentType;
  this.hasBody = builder.hasBody;
  this.isFormEncoded = builder.isFormEncoded;
  this.isMultipart = builder.isMultipart;
  this.parameterHandlers = builder.parameterHandlers;
}
</code></pre><p>始终别忘了以上内容都是通过<code>Java</code>自带的<code>Proxy</code>机制调用<code>InvocationHandler</code>来代理的, 所以<code>create</code>传入的是什么类, 返回的就是什么类的代理, 访问这个代理的方法时, 实际调用的是<code>InvocationHandler</code>. 通过<code>ServiceMethod.callAdapter.adapt()</code>可以将传入的方法适配为你自己定义的返回类型<code>Call&lt;T&gt;</code>的实例. 我们来看看默认情况下添加的<code>DefaultCallAdapterFactory</code>会生成什么<code>CallAdapter</code>:  </p>
<pre><code>public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { // 工厂方法, 传入返回类型, 注解数组, retrofit实例
  if (getRawType(returnType) != Call.class) { // 返回类型如果不是Call则直接返回null
    return null;
  }

  final Type responseType = Utils.getCallResponseType(returnType); // 获取ReturnType&lt;T&gt;中泛型参数T的上限类型
  return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
    @Override public Type responseType() {
      return responseType;
    }

    @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
      return call; // 默认返回传入参数
    }
  };
}
</code></pre><p>显然默认情况下这个适配器什么也不做, 直接把传入的<code>OkHttpCall</code>返回给你.  </p>
<h3 id="Retrofit的Converter与CallAdapter-开始使用RxJava"><a href="#Retrofit的Converter与CallAdapter-开始使用RxJava" class="headerlink" title="Retrofit的Converter与CallAdapter: 开始使用RxJava"></a>Retrofit的Converter与CallAdapter: 开始使用RxJava</h3><p>上文已经暗示了, 对结果的解析器<code>Converter</code>可以替换, 其实发送请求的代理<code>Call</code>也可以被替换, 只要换掉<code>CallAdapter</code>就可以了, 网上都说<code>RxJava+Retrofit</code>可以打出成吨输出, 原因就在于<code>CallAdapter</code>可以换成一个返回<code>Observable</code>类型的适配器, 这使得在<code>Retrofit.create()</code>之后可以直接以<code>RxJava</code>的风格做链式调用.<br>实现起来也非常简单, 只要<code>.addConverterFactory()</code> <code>.addCallAdapterFactory()</code>即可, 因为<code>Retrofit</code>对外提供了抽象类<code>Converter.Factory</code> <code>CallAdapter.Factory</code>, 并且实例全部使用泛型来表示, 通过对外提供统一接口, 只要外部可以继承抽象工厂类并返回实现了统一接口的实例类, 就可以在不改变<code>Retrofit</code>一行代码的情况下接入其他库, 或者原有逻辑代码变动不大的情况下接入<code>Retrofit</code>.  </p>
<p>是时候上一波图了:<br><img src="/images/blogs/retrofit_okhttp.png" alt="Retrofit, RxJava 和 OkHttp之间的关系"><br>上面这张图是我基于<a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Stay的这篇文章</a>改的, 荣耀归他, 另外由于图滞后于<code>Retrofit</code>版本, 所以如果有不一致的地方锅也归他(目前没看见不一致).  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这篇文章分析了<code>Retrofit</code>的实现, 其优缺点即使不是一目了然, 也是足够清晰了, 希望能够帮助到正在选择网络请求框架的各位.<br>本文参考如下:  </p>
<ul>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">Retrofit 源码解析</a>  </li>
<li><a href="http://www.jianshu.com/p/097947afddaf" target="_blank" rel="external">Retrofit源码分析（超详细）</a>  </li>
<li><a href="http://www.jianshu.com/p/07dac989272c" target="_blank" rel="external">Android网络框架源码分析二—Retrofit</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit源码</a>  </li>
<li><a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a>  </li>
<li><a href="https://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">Retrofit文档</a>  </li>
<li><a href="https://inthecheesefactory.com/blog/retrofit-2.0/en" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a>  </li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/android/">android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/android/">android</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/" data-title="【Android源码伴读】Retrofit源码探秘 | hjhjw1991&#39;s blog" data-tsina="1304671950" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/android/2017/03/05/[Android教程]ActivityManagerService全解-part1/" title="【Android教程】ActivityManagerService全解(1/5)">
  <strong>上一篇：</strong><br/>
  <span>
  【Android教程】ActivityManagerService全解(1/5)</span>
</a>
</div>


<div class="next">
<a href="/android/2017/02/28/[Android教程]Android网络架构/"  title="【Android教程】Android网络架构">
 <strong>下一篇：</strong><br/> 
 <span>【Android教程】Android网络架构
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit的使用"><span class="toc-number">1.</span> <span class="toc-text">Retrofit的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit源码探秘"><span class="toc-number">2.</span> <span class="toc-text">Retrofit源码探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit注解定义和解析"><span class="toc-number">2.1.</span> <span class="toc-text">Retrofit注解定义和解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit的Call与Response"><span class="toc-number">2.2.</span> <span class="toc-text">Retrofit的Call与Response</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Retrofit的Converter与CallAdapter-开始使用RxJava"><span class="toc-number">2.3.</span> <span class="toc-text">Retrofit的Converter与CallAdapter: 开始使用RxJava</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="hjhjw1991" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/android/" title="android">android<sup>24</sup></a></li>
		  
		
		  
			<li><a href="/categories/blog/" title="blog">blog<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/opinion/" title="opinion">opinion<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/tips/" title="tips">tips<sup>4</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/android/" title="android">android<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/guide/" title="guide">guide<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/interview/" title="interview">interview<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/windows/" title="windows">windows<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ssh/" title="ssh">ssh<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/jekyll/" title="jekyll">jekyll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/vps/" title="vps">vps<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/mac/" title="mac">mac<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/regex/" title="regex">regex<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/uwsgi/" title="uwsgi">uwsgi<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ios/" title="ios">ios<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vpn/" title="vpn">vpn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java/" title="java">java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://google.com" target="_blank" title="Google">Google</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="120" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1304671950&verifier=64e7ae81&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Huang Jun. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1304671950" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/hjhjw1991" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:hjhjw1991@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="hjhjw1991">hjhjw1991</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'hjhjw1991';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cd0e561542c22cc83da2e311ec57da84";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
