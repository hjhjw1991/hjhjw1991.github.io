
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>【Android教程】Binder全解 | hjhjw1991&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="hjhjw1991">
    

    
    <meta name="description" content="又叫【花样劝退教程】。本文讲Binder机制">
<meta property="og:type" content="article">
<meta property="og:title" content="【Android教程】Binder全解">
<meta property="og:url" content="http://blog.hjhjw1991.net/android/2017/01/10/[Android教程]Binder全解/index.html">
<meta property="og:site_name" content="hjhjw1991's blog">
<meta property="og:description" content="又叫【花样劝退教程】。本文讲Binder机制">
<meta property="og:image" content="http://blog.hjhjw1991.net/images/blogs/binder_native_stack.png">
<meta property="og:updated_time" content="2017-02-07T09:09:04.615Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Android教程】Binder全解">
<meta name="twitter:description" content="又叫【花样劝退教程】。本文讲Binder机制">
<meta name="twitter:image" content="http://blog.hjhjw1991.net/images/blogs/binder_native_stack.png">

    
    <link rel="alternative" href="/atom.xml" title="hjhjw1991&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.png">
    <link rel="apple-touch-icon-precomposed" href="/img/author.png">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="hjhjw1991&#39;s blog" title="hjhjw1991&#39;s blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="hjhjw1991&#39;s blog">hjhjw1991&#39;s blog</a></h1>
				<h2 class="blog-motto">Coder, Learn</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 8741923514077570040 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/android/2017/01/10/[Android教程]Binder全解/" title="【Android教程】Binder全解" itemprop="url">【Android教程】Binder全解</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="hjhjw1991" target="_blank" itemprop="author">hjhjw1991</a>
		
  <p class="article-time">
    <time datetime="2017-01-09T16:00:00.000Z" itemprop="datePublished"> 发表于 2017-01-10</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#某渣的凭印象回-hu-顾-zhou"><span class="toc-number">1.</span> <span class="toc-text">某渣的凭印象回(hu)顾(zhou)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder的设计思想-工作原理"><span class="toc-number">2.</span> <span class="toc-text">Binder的设计思想/工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder实践"><span class="toc-number">3.</span> <span class="toc-text">Binder实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service的启动过程"><span class="toc-number">3.1.</span> <span class="toc-text">Service的启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">4.</span> <span class="toc-text">结语</span></a></li></ol>
		
		</div>
		
		<h2 id="某渣的凭印象回-hu-顾-zhou"><a href="#某渣的凭印象回-hu-顾-zhou" class="headerlink" title="某渣的凭印象回(hu)顾(zhou)"></a>某渣的凭印象回(hu)顾(zhou)</h2><p>Binder是Android提供的一种RPC机制, 它是C/S架构, 可以远程调用服务, 调用其他进程甚至其他App的服务. 它利用AIDL描述服务接口, 通过bind和unbind绑定和解绑具体服务, 其内部使用代理完成服务功能的调用. 调用方需要知道AIDL, 被调用方需要实现AIDL. Android系统的服务就是通过Binder机制来使用的.  </p>
<h2 id="Binder的设计思想-工作原理"><a href="#Binder的设计思想-工作原理" class="headerlink" title="Binder的设计思想/工作原理"></a>Binder的设计思想/工作原理</h2><p>Binder是一种进程间通讯的机制, 不同于Handler的线程间通讯, 由于进程间没有共享区域, 所以Handler那种消息队列的机制在进程之间进行就会变得比较麻烦(进程A将消息拷贝到内核缓存空间, 另一进程B从内核缓存空间取消息), 特别是当进程间通讯涉及到接口调用等业务流程时. 出于安全性考虑, 一个进程的空间只对进程内部开放, 外部想要访问进程内的数据, 就只能曲线救国. Binder就是其中一种方式.  </p>
<p>Binder是一种特化的AIDL服务, 换句话说, AIDL是对Binder机制的上层封装, 它可以快速实现进程间通讯, 所以要想理解Binder就必须理解AIDL. 关于AIDL可以看我的博文<a href="http://hjhjw1991.github.io/android/2016/04/01/[Android%E6%95%99%E7%A8%8B]AIDL%E5%85%A5%E9%97%A8/" target="_blank" rel="external">AIDL入门</a>, 简单来说, AIDL是服务的接口描述文件, 它在服务端和客户端都共同存在且内容相同, SDK的aidl工具可以帮助我们把<code>.aidl</code>文件转换成同名的<code>.java</code>文件, 只要我们手工调用该工具转换一下, 并看一看转换后的文件, 我相信就能够完全理解aidl的使用原理了(其实跟Hessian之类的RPC框架大同小异). 具体到Binder, 我们可以去看看Binder的实现源码和Binder驱动的源码, 说白了就是系统为我们实现了一套基于Binder接口的获取/绑定/解绑/释放服务代理的业务逻辑, 我们只需要负责将具体的服务传给Binder就可以了. 如果没有Binder, 进行进程间通讯就必须要自己实现基于AIDL的业务逻辑, 实际上这样也是行得通的, 只不过系统服务都是基于Binder实现的, 所以我们有必要了解Binder的实现原理.<br>在最下层, Binder驱动通过Native代码实现, 它是Binder接口的最终实现, 关于Binder驱动的源码可以看这篇博客<a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>, 尤其是其代码注释.  </p>
<p>在Linux中有很多进程间通讯的方式, 为什么Android唯独自己实现了一个Binder机制? 我认为主要原因是现有的Linux进程间通讯方式都太”重”了, 含有许多虽然好但是在Android环境下并不实用的特性. 可以明确的是, 现有的进程间通讯方式肯定可以应用在Android这个基于Linux系统内核的操作系统上. 相比之下, Binder的设计使得它只进行一次数据拷贝, 传输更加高效, 而且发送方和接收方都互相知道对方身份, 更加安全.  </p>
<h2 id="Binder实践"><a href="#Binder实践" class="headerlink" title="Binder实践"></a>Binder实践</h2><p>依旧, 如果只想用Binder, 那直接继承它并实现相应接口即可, 这里的实践指的是看Binder源码. 默认大家已经看过并理解了AIDL的相关内容.<br>不同于上层Framework, 这里要理解Binder需要涉及到底层native代码, 所以我们要提前准备好Android系统源码, 当然前面看Java层代码时不需要. 这里我以4.0源码为基础.<br>照惯例我们先从Binder源码看起. 打开<code>frameworks/base/core/java/android/os/Binder.java</code>, 先来看看它都有哪些主要内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">注释, 大意是说这个类是一个用于远程调用的基类, 是IBinder中定义的轻量级RPC的核心部分, 提供了远程对象本地实现的标准支持, 多数情况下开发者不需要直接实现Binder类, 而是利用aidl工具描述服务接口, 让aidl自动生成合适的Binder子类, 但是开发这当然可以直接继承Binder来实现自己的RPC协议或者仅仅是实例化一个Binder对象作为token在进程之间共享.</div><div class="line">*/</div><div class="line">public class Binder implements IBinder&#123;// Binder类实现IBinder接口</div><div class="line">private int mObject;</div><div class="line">private IInterface mOwner;</div><div class="line">private String mDescriptor;</div><div class="line"></div><div class="line">public static final native int getCallingPid();// 调用者进程ID, 可以用来检查权限</div><div class="line">public static final native int getCallingUid();// 返回与进程绑定的调用者用户ID, 可以用来检查权限</div><div class="line">public static final native long clearCallingIdentity();// 重置调用者ID, 当你需要调用别的Interface的时候, 为了让被调用的Interface检查你自己的权限, 你需要重置调用者ID. 它返回的token可以通过下面这个方法恢复调用者ID  </div><div class="line">public static final native void restoreCallingIdentity(long token);// 恢复调用者ID</div><div class="line">public static final native void setThreadStrictModePolicy(int policyMask);// 设置native层StrictMode策略</div><div class="line">public static final native int getThreadStrictModePolicy();// 获取native层StrictMode策略</div><div class="line">public static final native void flushPendingCommands();// 把等待中的命令刷到内核驱动. 如果将要执行一个可能阻塞很长时间的命令, 那么本方法可以将线程中等待的命令刷到内核驱动, 以防止本线程过久地持有等待中命令的引用</div><div class="line">public static final native void joinThreadPool();// 把调用者线程加入IPC线程池, 该方法仅在进程退出时返回</div><div class="line"></div><div class="line">public Binder() &#123;</div><div class="line">	init();// native method</div><div class="line">	// code to check potential leaks</div><div class="line">&#125;</div><div class="line">public void attachInterface(IInterface owner, String descriptor);// 绑定IInterface和对应的descriptor</div><div class="line">public String getInterfaceDescriptor();</div><div class="line">public boolean pingBinder();// 默认返回true</div><div class="line">public boolean isBinderAlive();// 默认返回true</div><div class="line">public IInterface queryLocalInterface(String descriptor);// 返回descriptor对应的IInterface或者null</div><div class="line">protected boolean onTransact(int code, Parcel data, Parcel reply, int flags);// 真正的事务执行函数, 希望子类重写</div><div class="line">public final boolean transact(int code, Parcel data, Parcel reply, int flags);// 事务执行函数, 里面回调onTransact</div><div class="line">private boolean execTransact(int code, int dataObj, int replyObj, int flags);// 回调onTrasact, 如果抛出异常则返回true</div><div class="line">public void linkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line">public boolean unlinkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line"></div><div class="line">private native final void init();</div><div class="line">private native final void destroy();</div><div class="line">&#125;// Binder类</div><div class="line"></div><div class="line">final class BinderProxy implements IBinder &#123;// BinderProxy类</div><div class="line">    BinderProxy() &#123;</div><div class="line">        mSelf = new WeakReference(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 以下六个方法都成了native方法</div><div class="line">    public native boolean pingBinder();</div><div class="line">    public native boolean isBinderAlive();</div><div class="line">    public native String getInterfaceDescriptor();</div><div class="line">    public native boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line">    public native void linkToDeath(DeathRecipient recipient, int flags);</div><div class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</div><div class="line"></div><div class="line">    final private WeakReference mSelf;// 指向自身的弱引用</div><div class="line">    private int mObject;</div><div class="line">    private int mOrgue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完源码至少有三个疑问: 1. IInterface和IBinder定义了哪些接口? 2. BinderProxy是什么, 怎么用的? 3. <code>Binder.java</code>中涉及到的那些native方法, 是怎么实现的?<br>打开<code>frameworks/base/core/java/android/os/IBinder.java</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/** 注释中详细讲述了IBinder的设计思路. 核心API是transact(), 与Binder的onTransact成对. 作为本地对象的它发送一个调用到远程IBinder对象, 同时作为远程对象的它可以接受一个调用并放到一个Binder对象中. 这个API是同步的, 以保证仅在远程onTransact返回后, 本地transact才返回, 这是所期望的行为.  </div><div class="line">系统在每个进程中维护一个事务线程池, 用于分发所有从外部进程进来的IPC. Binder系统允许递归调用, 比如A调用B, B的onTransact中又调用了A. */</div><div class="line">    // 定义了用户可以使用的事务代码</div><div class="line">    int FIRST_CALL_TRANSACTION  = 0x00000001;</div><div class="line">    int LAST_CALL_TRANSACTION   = 0x00ffffff;</div><div class="line"></div><div class="line">    // IBinder协议的事务代码</div><div class="line">    int PING_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;P&apos;&lt;&lt;16)|(&apos;N&apos;&lt;&lt;8)|&apos;G&apos;;</div><div class="line">    int DUMP_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;D&apos;&lt;&lt;16)|(&apos;M&apos;&lt;&lt;8)|&apos;P&apos;;</div><div class="line">    int INTERFACE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;N&apos;&lt;&lt;16)|(&apos;T&apos;&lt;&lt;8)|&apos;F&apos;;</div><div class="line">    int TWEET_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;T&apos;&lt;&lt;16)|(&apos;W&apos;&lt;&lt;8)|&apos;T&apos;;</div><div class="line">    int LIKE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;L&apos;&lt;&lt;16)|(&apos;I&apos;&lt;&lt;8)|&apos;K&apos;;// 告诉app调用者喜欢它. 可选命令, 应用不必处理, 没啥卵用. 默认实现啥也不做.  </div><div class="line">    int SYSPROPS_TRANSACTION = (&apos;_&apos;&lt;&lt;24)|(&apos;S&apos;&lt;&lt;16)|(&apos;P&apos;&lt;&lt;8)|&apos;R&apos;;// hide</div><div class="line"></div><div class="line">    // transact的标记, 表示这是一个单向调用, 调用者不等待被调用者的结果, 而是立即返回</div><div class="line">    int FLAG_ONEWAY             = 0x00000001;</div><div class="line">    public static final int MAX_IPC_SIZE = 64 * 1024;// hide</div><div class="line"></div><div class="line">    public String getInterfaceDescriptor();</div><div class="line">    // 查询Binder是否可用有三种方式, 当Binder不可用时, transact()会抛出RemoteException, pingBinder()会返回false, linkToDeath()预先连接一个DeathRecipient, 不可用时会回调这个DeathRecipient的binderDied()</div><div class="line">    public boolean pingBinder();</div><div class="line">    public boolean isBinderAlive();</div><div class="line"></div><div class="line">    public IInterface queryLocalInterface(String descriptor);</div><div class="line"></div><div class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line"></div><div class="line">    public interface DeathRecipient &#123;</div><div class="line">        public void binderDied();</div><div class="line">    &#125;</div><div class="line">    public void linkToDeath(DeathRecipient recipient, int flags);// 连接一个DeathRecipient接收器, 当Binder不可用时回调</div><div class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</div></pre></td></tr></table></figure></p>
<p>可见, IBinder定义了一套Transaction协议用于指明发起的Transaction类型, 定义了<code>transact()</code>核心接口, 该接口与Binder中的<code>onTransact</code>配合使用才能完成远程调用的功能. 定义了查询接口, 返回一个<code>IInterface</code>实例. 下面看看这个接口定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IInterface</div><div class="line">&#123;</div><div class="line">    public IBinder asBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就这一个接口方法, 返回<code>IBinder</code>实例. 注释中说该方法返回与该Interface绑定的Binder实例.<br>以上这些内容, 定义了一个基本的Binder系统框架, 即通过同一套<code>Binder &amp; IBinder &amp; IInterface</code>接口, 本地以<code>transact()</code>发起远程调用, 远程在<code>onTransact()</code>中处理相应调用. 本地以<code>asInterface()</code>获取远程服务的实例(实际获得的是服务的代理, 代理内对每个服务接口中的方法, 调用远程服务的transact方法, 传递一个约定好的事务代码和方法参数, 远程服务的onTransact会对每个约定好的事务代码, 生成相应的switch case, 调用真正的服务接口实现. 由于客户端和服务端对服务接口的定义是相同的, 故生成的服务接口也相同, 可以在本地aidl生成的java文件中查看onTransact的实现), 远程以<code>asBinder()</code>返回远程服务的实例, 本地通过asInterface返回的代理来调用远程服务的方法, 跟调用本地服务方法表面上看起来没有差别.  </p>
<h3 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h3><p>离开具体实现的Binder是无法工作的, 我们自己当然可以自行继承Binder来写自己的远程服务. AIDL是Android为我们提供的一种方便快捷生成Binder实现的方式和工具, 而Service是由系统实现了服务端的Binder. 我们以它为例, 说明如何启动服务, 以及其中哪里用到了Binder.<br>我们知道, 要获取服务(系统服务除外, 其实系统服务就是提供了一个通过descriptor获取服务的接口), 首先我们要知道服务的全名, 在Intent中设定服务全名, 并指定一个ServiceConnection回调, 调用<code>bindService(Intent, ServiceConnection, CONTEXT_OPTION)</code>绑定服务(其中第三个参数的含义稍后解释), 在<code>ServiceConnection</code>中获取到服务实例. 我们已经知道<code>ServiceConnection</code>的回调方法被调用时已经得到了服务实例, 下面我们看看<code>bindService</code>如何绑定服务获取服务实例.  </p>
<p><code>bindService</code>方法的定义来自于<code>Context</code>, <code>Activity</code>的<code>bindService</code>调用的是<code>ContextWrapper.bindService</code>, 其默认实现是调用<code>mBase.bindService</code>, <code>mBase</code>是一个Context类型的成员变量, 这里的mBase是一个ContextImpl实例变量. 在<code>ContextImpl.java</code>中, bindService是这么定义的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public boolean bindService(Intent service, ServiceConnection conn,  </div><div class="line">            int flags) &#123;  </div><div class="line">        IServiceConnection sd;  </div><div class="line">        if (mPackageInfo != null) &#123;  </div><div class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),  </div><div class="line">                mMainThread.getHandler(), flags);  </div><div class="line">        &#125; else &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">        try &#123;  </div><div class="line">            int res = ActivityManagerNative.getDefault().bindService(  </div><div class="line">                mMainThread.getApplicationThread(), getActivityToken(),  </div><div class="line">                service, service.resolveTypeIfNeeded(getContentResolver()),  </div><div class="line">                sd, flags);  </div><div class="line">            ......  </div><div class="line">            return res != 0;  </div><div class="line">        &#125; catch (RemoteException e) &#123;  </div><div class="line">            return false;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的mMainThread是一个<code>ActivityThread</code>实例, 通过它的<code>getHandler</code>函数可以获得一个Handler对象(这里返回的Handler是在<code>ActivityThread</code>类内部从Handler类继承下来的一个H类实例变量), 有了这个Handler对象后, 就可以把消息分发到<code>ActivityThread</code>所在的线程消息队列中去了.  </p>
<p><div id="LoadedApk.ServiceDispatcher.InnerConnection"></div>获得了这个Handler对象后, 就调用<code>mPackageInfo.getServiceDispatcher</code>函数来获得一个<code>IServiceConnection</code>接口, 这里的<code>mPackageInfo</code>的类型是<code>LoadedApk</code>, 它的<code>getServiceDispatcher</code>函数比较长我就不贴了, 大致上它先以传进来的context为key查找<code>mServices</code>成员中是否已经有对应的<code>ServiceDispatcher</code>, 没有则新建一个, 将传进来的<code>ServiceConnection</code>和Handler都保存在<code>ServiceDispatcher</code>内部, 并创建一个<code>InnerConnection</code>, <font color="red">这是一个Binder对象!</font> 最后返回给sd的就是这个<code>InnerConnection</code>对象.<br>接着调用<code>ActivityManagerNative.getDefault().bindService()</code>, 在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>文件中, 函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class ActivityManagerProxy implements IActivityManager  </div><div class="line">&#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    public int bindService(IApplicationThread caller, IBinder token,  </div><div class="line">            Intent service, String resolvedType, IServiceConnection connection,  </div><div class="line">            int flags) throws RemoteException &#123;  </div><div class="line">        Parcel data = Parcel.obtain();  </div><div class="line">        Parcel reply = Parcel.obtain();  </div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);  </div><div class="line">        data.writeStrongBinder(caller != null ? caller.asBinder() : null);</div><div class="line">        data.writeStrongBinder(token);  </div><div class="line">        service.writeToParcel(data, 0);  </div><div class="line">        data.writeString(resolvedType);  </div><div class="line">        data.writeStrongBinder(connection.asBinder());// 被调用的服务的Binder作为数据传输给服务端</div><div class="line">        data.writeInt(flags);  </div><div class="line">        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);// 调用了transact, 进Binder驱动</div><div class="line">        reply.readException();  </div><div class="line">        int res = reply.readInt();  </div><div class="line">        data.recycle();  </div><div class="line">        reply.recycle();  </div><div class="line">        return res;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><div id="ActivityManagerService.bindService"></div>这个函数通过Binder驱动程序就进入到<code>ActivityManagerService</code>的<code>bindService</code>函数去了(到此为止, 代码执行就从Binder客户端进入到了Binder服务端), 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>文件中, 代码比较长就不贴了. 主要做了以下这些事:<br>函数首先根据传进来的参数token(是调用者Activity在<code>ActivityManagerService</code>里面的令牌), 将这个代表调用者Activity的<code>ActivityRecord</code>取回来.<br>接着通过<code>retrieveServiceLocked</code>函数, 得到一个<code>ServiceRecord</code>, 这个<code>ServiceReocrd</code>描述的是一个Service对象,这是根据传进来的参数service的内容获得的(service是个Intent, 带有我们要用的具体Service的信息).<br>接着把传进来的connection参数封装成一个<code>ConnectionRecord</code>对象, 并保存了它的一个引用到<code>activity.connections</code>中以方便后续取用.<br>最后, 传进来的第四个参数flags是有限的几种<code>BindServiceFlags</code>中的一种, 它决定了具体行为. 以<code>BIND_AUTO_CREATE</code>为例, 它会走到<code>private final boolean bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean whileRestarting)</code>, 第一个参数就是前面的Intent service, 第二个参数通过<code>service.getFlags()</code>得到, 第三个参数传的false. 该函数中, 首先判断应用进程是否存在, 如果存在则调用<code>realStartServiceLocked(r, app)</code>, app是通过进程名和uid获取到的<code>ProcessRecord</code>(如果不存在则启动新进程, 并将服务压栈等待进程启动完成, 在这个新进程上执行serivce). 来看这个函数实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public final class ActivityManagerService extends ActivityManagerNative  </div><div class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;  </div><div class="line">    ......  </div><div class="line">    private final void realStartServiceLocked(ServiceRecord r,  </div><div class="line">            ProcessRecord app) throws RemoteException &#123;  </div><div class="line">        ......  </div><div class="line">        r.app = app;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        app.services.add(r);  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        try &#123;  </div><div class="line">            ......  </div><div class="line">            app.thread.scheduleCreateService(r, r.serviceInfo);  </div><div class="line">            ......  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        requestServiceBindingsLocked(r);  </div><div class="line">  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数执行了两个操作, 一个是<code>app.thread.scheduleCreateService(r, r.serviceInfo)</code>在应用程序进程内部创建Service, 这个操作会导致Service的<code>onCreate</code>被调用; 另一个操作是调用<code>requestServiceBindingsLocked</code>函数向服务获取一个Binder对象, 这个操作会导致Service的<code>onBind</code>函数被调用. 可能有读者觉得有点偏题了, 实际不然, 这两个操作都依赖Binder机制. 先来看前者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class ApplicationThreadProxy implements IApplicationThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    public final void scheduleCreateService(IBinder token, ServiceInfo info)  </div><div class="line">            throws RemoteException &#123;  </div><div class="line">        Parcel data = Parcel.obtain();  </div><div class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);  </div><div class="line">        data.writeStrongBinder(token);  </div><div class="line">        info.writeToParcel(data, 0);  </div><div class="line">        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null,  </div><div class="line">            IBinder.FLAG_ONEWAY);// 又一次Binder调用, 进入到的是ApplicationThread.scheduleCreateService, flag引人注目</div><div class="line">        data.recycle();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过Binder驱动程序就进入到<code>ApplicationThread</code>的<code>scheduleCreateService</code>函数去了. 它的定义在<code>frameworks/base/core/java/android/app/ActivityThread.java</code>文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    private final class ApplicationThread extends ApplicationThreadNative &#123;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        public final void scheduleCreateService(IBinder token,  </div><div class="line">            ServiceInfo info) &#123;  </div><div class="line">            CreateServiceData s = new CreateServiceData();  </div><div class="line">            s.token = token;  </div><div class="line">            s.info = info;  </div><div class="line">  </div><div class="line">            queueOrSendMessage(H.CREATE_SERVICE, s);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>queueOrSendMessage</code>是<code>ActivityThread</code>的方法, 它用Handler把创建服务的操作放到了Activity线程的消息队列中, 在<code>handleMessage</code>时调用<code>handleCreateService</code>处理该消息, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    private final void handleCreateService(CreateServiceData data) &#123;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(  </div><div class="line">        data.info.applicationInfo);  </div><div class="line">        Service service = null;  </div><div class="line">        try &#123;  </div><div class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();  </div><div class="line">            service = (Service) cl.loadClass(data.info.name).newInstance();  // 加载类, 获得实例</div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        try &#123;  </div><div class="line">            ......  </div><div class="line">  </div><div class="line">            ContextImpl context = new ContextImpl();  </div><div class="line">            context.init(packageInfo, null, this);  </div><div class="line">  </div><div class="line">            Application app = packageInfo.makeApplication(false, mInstrumentation);  </div><div class="line">            context.setOuterContext(service);  </div><div class="line">            service.attach(context, this, data.info.name, data.token, app,  </div><div class="line">                ActivityManagerNative.getDefault());  // 绑定服务</div><div class="line">  </div><div class="line">            service.onCreate();  // 进入onCreate生命周期</div><div class="line">            mServices.put(data.token, service); // 保存服务映射</div><div class="line">            ......  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;  </div><div class="line">```  </div><div class="line">至此, 服务实例就创建出来了. 下面回到`realStartServiceLocked`看`requestServiceBindingsLocked`, 它的定义在`frameworks/base/services/java/com/android/server/am/ActivityManagerService.java`中:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityManagerService extends ActivityManagerNative<br>        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {<br>    ……  </p>
<pre><code>private final void requestServiceBindingsLocked(ServiceRecord r) {  
    Iterator&lt;IntentBindRecord&gt; bindings = r.bindings.values().iterator();  
    while (bindings.hasNext()) {  
        IntentBindRecord i = bindings.next();  
        if (!requestServiceBindingLocked(r, i, false)) {  
            break;  
        }  
    }  
}  

private final boolean requestServiceBindingLocked(ServiceRecord r,  
        IntentBindRecord i, boolean rebind) {  
    ......  
    if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) {  
      try {  
          ......  
          r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);  
          ......  
      } catch (RemoteException e) {  
          ......  
      }  
    }  
    return true;  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(下回分解)  </div><div class="line">1月9日, 继续分解Service启动过程.  </div><div class="line">前面说到经过`handleCreateService`之后, `Service`实例就通过ClassLoader载入到内存, 并通过newInstance创建了实例, 且进入到`onCreate`周期. 创建完毕后, 接着调用`requestServiceBindingsLocked`, 这个方法从名字看应该是要绑定服务了, 打开源码发现它实际调用了`app.thread.scheduleBindService`, 传的参数`ServiceRecord r`代表我们启动的自定义服务. `app.thread`是一个Binder对象的远程接口, 它的类型是`ApplicationThreadProxy`, 这一点从前面也看得出来. 通过代理和Binder驱动, 我们就进入到`ApplicationThread`的`scheduleBindService`中了:</div></pre></td></tr></table></figure></p>
<p>class ApplicationThreadProxy implements IApplicationThread {<br>    ……  </p>
<pre><code>public final void scheduleBindService(IBinder token, Intent intent, boolean rebind)  throws RemoteException {  
    Parcel data = Parcel.obtain();  
    data.writeInterfaceToken(IApplicationThread.descriptor);  
    data.writeStrongBinder(token);  
    intent.writeToParcel(data, 0);  
    data.writeInt(rebind ? 1 : 0);  
    mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, null,  
        IBinder.FLAG_ONEWAY);  
    data.recycle();  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">那么, 我们来看看`ApplicationThread`中`scheduleBindService`是怎么实现的:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityThread {<br>    ……  </p>
<pre><code>public final void scheduleBindService(IBinder token, Intent intent,  
        boolean rebind) {  
    BindServiceData s = new BindServiceData();  
    s.token = token;  
    s.intent = intent;  
    s.rebind = rebind;  

    queueOrSendMessage(H.BIND_SERVICE, s);  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">很眼熟对不对? 相信不用我说你也知道之后是什么了:</div></pre></td></tr></table></figure></p>
<p>switch (msg.what) {<br>……<br>case BIND_SERVICE:<br>    handleBindService((BindServiceData)msg.obj);<br>    break;<br>……<br>}  </p>
<p>…<br>private final void handleBindService(BindServiceData data) {<br>    Service s = mServices.get(data.token);<br>    if (s != null) {<br>        try {<br>            data.intent.setExtrasClassLoader(s.getClassLoader());<br>            try {<br>                if (!data.rebind) {<br>                    IBinder binder = s.onBind(data.intent);<br>                    ActivityManagerNative.getDefault().publishService(<br>                        data.token, data.intent, binder);<br>                } else {<br>                    ……<br>                }<br>                ……<br>            } catch (RemoteException ex) {<br>            }<br>        } catch (Exception e) {<br>            ……<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;Service.onBind&quot;&gt;&lt;/div&gt;首先将前面保存在`mServices`中的服务通过`data.token`取出来放到本地变量, 然后让它执行`onBind`获得一个Binder对象, 接着将这个对象传递给`ActivityManagerService.getDefa().publishService()`. `onBind`是自定义服务自己重写的, 就是返回一个实现了IBinder接口的Binder对象. `publishSerivce` 定义在`frameworks/base/core/java/android/app/ActivityManagerNative.java`中, 如下:</div></pre></td></tr></table></figure></p>
<p>class ActivityManagerProxy implements IActivityManager<br>{<br>    ……<br>    public void publishService(IBinder token,<br>    Intent intent, IBinder service) throws RemoteException {<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IActivityManager.descriptor);<br>        data.writeStrongBinder(token);<br>        intent.writeToParcel(data, 0);<br>        data.writeStrongBinder(service);<br>        mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0);// 眼熟不?<br>        reply.readException();<br>        data.recycle();<br>        reply.recycle();<br>    }<br>    ……<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">再来看`publishService`的实现, 理所当然它的定义在`frameworks/base/services/java/com/android/server/am/ActivityManagerService.java`中:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityManagerService extends ActivityManagerNative<br>        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {<br>    ……  </p>
<pre><code>public void publishService(IBinder token, Intent intent, IBinder service) {  
    ......  
    synchronized(this) {  
        ......  
        ServiceRecord r = (ServiceRecord)token;  
        ......  

        ......  
        if (r != null) {  
            Intent.FilterComparison filter  
                = new Intent.FilterComparison(intent);  
            IntentBindRecord b = r.bindings.get(filter);  
            if (b != null &amp;&amp; !b.received) {  
                b.binder = service;  
                b.requested = true;  
                b.received = true;  
                if (r.connections.size() &gt; 0) {  
                    Iterator&lt;ArrayList&lt;ConnectionRecord&gt;&gt; it  
                        = r.connections.values().iterator();  
                    while (it.hasNext()) {  
                        ArrayList&lt;ConnectionRecord&gt; clist = it.next();  
                        for (int i=0; i&lt;clist.size(); i++) {  
                            ConnectionRecord c = clist.get(i);  
                            ......  
                            try {  
                                c.conn.connected(r.name, service);  
                            } catch (Exception e) {  
                                ......  
                            }  
                        }  
                    }  
                }  
            }  

            ......  
        }  
    }  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这里传进来的service不出意外的话就是我们自定义`onBinder`返回的那个东西了, 也就是我们自定义服务的实例. 这里的`token`是一个`ServiceRecord`对象, 是在前面[bindService](#ActivityManagerService.bindService)中中创建的. 在那里, 我们保存了自定义服务的一个`ConnectionRecord`在这个`ServiceRecord.connections`列表中, 因此这里可以通过`r.connections`取出那个`ConnectionRecord`.  </div><div class="line">取出`ConnectionRecord`之后, 调用成员变量的函数`conn.connected()`. 这个conn是一个`IServiceConnection`类型, 它是一个Binder对象的远程接口, 这个Binder对象, 就是我们在[前面](#LoadedApk.ServiceDispatcher.InnerConnection)创建的`LoadedApk.ServiceDispatcher.InnerConnection`对象. 因此, 这里的`connected`就到了`InnerConnection.connected`:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/java/android/app/LoadedApk.java<br>final class LoadedApk {<br>    ……  </p>
<pre><code>static final class ServiceDispatcher {  
    ......  

    private static class InnerConnection extends IServiceConnection.Stub {  
        ......  

        public void connected(ComponentName name, IBinder service) throws RemoteException {  
            LoadedApk.ServiceDispatcher sd = mDispatcher.get();  
            if (sd != null) {  
                sd.connected(name, service);  // 转到了外层ServiceDispatcher类中的connected
            }  
        }  
        ......  
    }  
    ......  

    public void connected(ComponentName name, IBinder service) {  
        if (mActivityThread != null) {  
            mActivityThread.post(new RunConnection(name, service, 0)); // 放到ActivityThread的消息队列中. mActivityThread是一个Handler实例  
        } else {  
            ......  
        }  
    }  
    ......  

    private final class RunConnection implements Runnable {  
        ......  

        public void run() {  
            if (mCommand == 0) {  
                doConnected(mName, mService);  
            } else if (mCommand == 1) {  
                ......  
            }  
        }  
        ......  
    }  
    ......  

    public void doConnected(ComponentName name, IBinder service) {  
        ......  

        // If there is a new service, it is now connected.  
        if (service != null) {  
            mConnection.onServiceConnected(name, service);  
        }  
    }  
}  
......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">新建了一个`RunConnection`并调用`H.post`放到了`ActivityThread`的消息队列中. 当处理该消息时, 会运行的`RunConnection`的`run()`来处理, 原因见我另一篇文章[Handler原理](./handler.md). 此时`mCommand==0`, 最后就会执行到`mConnection.onServiceConnected`函数. 这里的`mConnection`的类型是`ServiceConnection`, 它是在[前面](#ActivityManagerService.bindService)设置好的, 它是我们调用`bindService`时传入的`ServiceConnection`实例, 在前面我们用它通过`ServiceDispatcher`换得了一个`IServiceConnection`对象.   </div><div class="line">传入的第二个参数`service`是一个IBinder对象, 它其实就是我们[前面](#Service.onBind)从自定义Service中得到的自定义Binder对象, 因此这里我们可以直接强转成那个自定义Binder类型, 并通过它的`getService`接口获取到自定义服务的接口. 至此, 我们经过`onServiceConnection`, 调用`getService`, 绑定并获取了自定义服务.  </div><div class="line"></div><div class="line">### Binder驱动的实现</div><div class="line">上面多次提到&quot;进入了Binder驱动&quot;, 可见Binder驱动在这个设计中具有重要的桥梁作用. 那么除了上面看到的那些, Binder驱动到底是什么样子呢? 接下来让我们深入Binder驱动源码.  </div><div class="line">首先我们要知道是哪里进入到Native Binder驱动的:  </div><div class="line">`IYourService.Stub.Proxy.YOUR_API()`中, 调用`android.os.IBinder(实现在 android.os.Binder.BinderProxy).transact()`发送`Stub.TRANSACTION_YOUR_API` ==&gt; **`BinderProxy.transact()`进入Native层** ==&gt; 由jni转到`android_os_BinderProxy_transact()`函数 ==&gt; 调用`IBinder-&gt;transact`函数.  </div><div class="line"></div><div class="line">#### 调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()</div><div class="line">直到jni为止的内容我们前面已经了解过了, 下面来看`android_os_BinderProxy_transact()`函数:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/jni/android_util_Binder.cpp</p>
<p>……</p>
<p>static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException<br>{<br>    // check and parse data<br>    ……</p>
<pre><code>IBinder* target = (IBinder*)
    env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);// 获取mObject指向的本地对象

status_t err = target-&gt;transact(code, *data, reply, flags);// 调用本地代码的transact

if (err == NO_ERROR) {
    return JNI_TRUE;
} else if (err == UNKNOWN_TRANSACTION) {
    return JNI_FALSE;
}

signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize());
return JNI_FALSE;
</code></pre><p>}<br>……</p>
<p>static const JNINativeMethod gBinderProxyMethods[] = {<br>     /<em> name, signature, funcPtr </em>/<br>    {“pingBinder”,          “()Z”, (void<em>)android_os_BinderProxy_pingBinder},<br>    {“isBinderAlive”,       “()Z”, (void</em>)android_os_BinderProxy_isBinderAlive},<br>    {“getInterfaceDescriptor”, “()Ljava/lang/String;”, (void<em>)android_os_BinderProxy_getInterfaceDescriptor},<br>    {“transactNative”,      “(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z”, (void</em>)android_os_BinderProxy_transact},<br>    {“linkToDeath”,         “(Landroid/os/IBinder$DeathRecipient;I)V”, (void<em>)android_os_BinderProxy_linkToDeath},<br>    {“unlinkToDeath”,       “(Landroid/os/IBinder$DeathRecipient;I)Z”, (void</em>)android_os_BinderProxy_unlinkToDeath},<br>    {“destroy”,             “()V”, (void*)android_os_BinderProxy_destroy},<br>};<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中, `gBinderProxyOffsets.mObject`是在Java层调用`IBinder.getContextObject()`时, 在`javaObjectForIBinder`函数中设置的:</div></pre></td></tr></table></figure>
<p>// in file frameworks/base/core/jni/android_util_Binder.cpp<br>……</p>
<p>static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)<br>{<br>    sp<ibinder> b = ProcessState::self()-&gt;getContextObject(NULL);<br>    return javaObjectForIBinder(env, b);<br>}</ibinder></p>
<p>jobject javaObjectForIBinder(JNIEnv<em> env, const sp<ibinder>&amp; val)<br>{<br>    …<br>    LOGDEATH(“objectForBinder %p: created new proxy %p !\n”, val.get(), object);<br>    // The proxy holds a reference to the native object.<br>    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());// 设置本地IBinder对象, 令mObject指向它<br>    val-&gt;incStrong((void</ibinder></em>)javaObjectForIBinder);<br>    …<br>}</p>
<p>…..</p>
<p>########################################################################</p>
<p>// in file frameworks/native/libs/binder/ProcessState.cpp<br>……</p>
<p>sp<ibinder> ProcessState::getContextObject(const sp<ibinder>&amp; /<em>caller</em>/)<br>{<br>    return getStrongProxyForHandle(0);<br>}</ibinder></ibinder></p>
<p>sp<ibinder> ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp<ibinder> result;<br>    …<br>    b = new BpBinder(handle);<br>    result = b;<br>    …<br>    return result;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">可见, `android_os_BinderProxy_transact()`函数实际上调用的是 `BpBinder::transact()` 函数.  </div><div class="line"></div><div class="line">#### jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState</div><div class="line">来看看`BpBinder::transact()`, 它位于`frameworks/native/libs/binder/BpBinder.cpp`:</div></pre></td></tr></table></figure></ibinder></ibinder></p>
<p>status_t BpBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    // Once a binder has died, it will never come back to life.<br>    if (mAlive) {<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);// 调用IPCThreadState::self()-&gt;transact<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }</p>
<pre><code>return DEAD_OBJECT;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`IPCThreadState`中是这么写的:</div></pre></td></tr></table></figure></p>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck();</p>
<pre><code>flags |= TF_ACCEPT_FDS;

if (err == NO_ERROR) {
    LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),
        (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);
    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
}

if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        err = waitForResponse(reply);
    } else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}

return err;
</code></pre><p>}</p>
<p>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,<br>    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)<br>{<br>    binder_transaction_data tr;</p>
<pre><code>tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */
tr.target.handle = handle;
tr.code = code;
...

mOut.writeInt32(cmd);
mOut.write(&amp;tr, sizeof(tr));

return NO_ERROR;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">由函数内容可以看出, 数据再一次通过 `writeTransactionData()` 传递给 `mOut` 进行写入操作. `mOut` 是一个 `Parcel` 对象, 声明在 `IPCThreadState.h` 文件中. 之后则调用 `waitForResponse()` 函数.</div><div class="line"></div><div class="line">#### IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回</div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/IPCThreadState.cpp<br>……</p>
<p>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t </em>acquireResult)<br>{<br>    int32_t cmd;<br>    int32_t err;</p>
<pre><code>while (1) { // 永真循环
    if ((err=talkWithDriver()) &lt; NO_ERROR) break; // 调用talkWithDriver, 当返回负时退出循环
    err = mIn.errorCheck();
    if (err &lt; NO_ERROR) break;
    if (mIn.dataAvail() == 0) continue;

    cmd = mIn.readInt32(); // 读取命令

    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;
            &lt;&lt; getReturnString(cmd) &lt;&lt; endl;
    }

    switch (cmd) {
    case BR_TRANSACTION_COMPLETE:
        if (!reply &amp;&amp; !acquireResult) goto finish;
        break;

    case BR_DEAD_REPLY:
        err = DEAD_OBJECT;
        goto finish;

    case BR_FAILED_REPLY:
        err = FAILED_TRANSACTION;
        goto finish;

    case BR_ACQUIRE_RESULT:
        {
            LOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);
            const int32_t result = mIn.readInt32();
            if (!acquireResult) continue;
            *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
        }
        goto finish;

    case BR_REPLY:
        {
            binder_transaction_data tr;
            err = mIn.read(&amp;tr, sizeof(tr));// 读取远端返回的数据
            LOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);
            if (err != NO_ERROR) goto finish;

            if (reply) {
                if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                    reply-&gt;ipcSetDataReference(
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t),
                        freeBuffer, this);
                } else {
                    err = *static_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);
                    freeBuffer(NULL,
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t), this);
                }
            } else {
                freeBuffer(NULL,
                    reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                    tr.data_size,
                    reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                    tr.offsets_size/sizeof(size_t), this);
                continue;
            }
        }
        goto finish;

    default:
        err = executeCommand(cmd); // 处理其他命令, 例如NO_ERROR
        if (err != NO_ERROR) goto finish;
        break;
    }
}
</code></pre><p>finish:<br>    if (err != NO_ERROR) {<br>        if (acquireResult) *acquireResult = err;<br>        if (reply) reply-&gt;setError(err);<br>        mLastError = err;<br>    }</p>
<pre><code>return err;
</code></pre><p>}<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;talkWithDriver&quot;&gt;&lt;/div&gt;</div><div class="line">#### IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现</div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure></p>
<p>……</p>
<p>status_t IPCThreadState::talkWithDriver(bool doReceive)<br>{<br>    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= 0, “Binder driver is not opened”);</p>
<pre><code>binder_write_read bwr;

// Is the read buffer empty?
const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();

// We don&apos;t want to write anything if we are still reading
// from data left in the input buffer and the caller
// has requested to read the next data.
const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

// 写入数据
bwr.write_size = outAvail;
bwr.write_buffer = (long unsigned int)mOut.data();

// This is what we&apos;ll read.
// 读取数据
if (doReceive &amp;&amp; needRead) {
    bwr.read_size = mIn.dataCapacity();
    bwr.read_buffer = (long unsigned int)mIn.data();
} else {
    bwr.read_size = 0;
}

IF_LOG_COMMANDS() {
    TextOutput::Bundle _b(alog);
    if (outAvail != 0) {
        alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;
        const void* cmds = (const void*)bwr.write_buffer;
        const void* end = ((const uint8_t*)cmds)+bwr.write_size;
        alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;
        while (cmds &lt; end) cmds = printCommand(alog, cmds);
        alog &lt;&lt; dedent;
    }
    alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size
        &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;
}

// Return immediately if there is nothing to do.
if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

bwr.write_consumed = 0;
bwr.read_consumed = 0;
status_t err;
do {
    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
    }
</code></pre><p>#if defined(HAVE_ANDROID_OS)<br>        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令<br>        // 该过程在下一节详述<br>        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)<br>            err = NO_ERROR;<br>        else<br>            err = -errno;</p>
<p>#else<br>        err = INVALID_OPERATION;</p>
<p>#endif<br>        IF_LOG_COMMANDS() {<br>            alog &lt;&lt; “Finished read/write, write size = “ &lt;&lt; mOut.dataSize() &lt;&lt; endl;<br>        }<br>    } while (err == -EINTR);</p>
<pre><code>IF_LOG_COMMANDS() {
    alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)err &lt;&lt; &quot;, write consumed: &quot;
        &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()
        &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;
}

if (err &gt;= NO_ERROR) {
    if (bwr.write_consumed &gt; 0) {
        if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
            mOut.remove(0, bwr.write_consumed);
        else
            mOut.setDataSize(0);
    }
    if (bwr.read_consumed &gt; 0) {
        mIn.setDataSize(bwr.read_consumed);
        mIn.setDataPosition(0);
    }
    IF_LOG_COMMANDS() {
        TextOutput::Bundle _b(alog);
        alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;
        const void* cmds = mIn.data();
        const void* end = mIn.data() + mIn.dataSize();
        alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;
        while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);
        alog &lt;&lt; dedent;
    }
    return NO_ERROR;
}

return err;
</code></pre><p>}<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">`ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)` 就是使用系统调用函数 `ioctl` 向 `binder` 设备文件 `/dev/binder` 发送 `BINDER_WRITE_READ` 命令.  </div><div class="line">回到上一步`waitForResponse`, 获取到`talkWithDriver`返回的命令`cmd`后默认执行`executeCommand(cmd)`, 来处理返回命令  </div><div class="line"></div><div class="line">#### IPCThreadState::executeCommand(int32_t cmd) 处理返回命令</div><div class="line">除了在switch case中处理的命令以外, 其他的命令都通过调用`executeCommand`来处理, 它的实现如下:  </div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure>
<p>……</p>
<p>status_t IPCThreadState::executeCommand(int32_t cmd)<br>{<br>    BBinder<em> obj;<br>    RefBase::weakref_type</em> refs;<br>    status_t result = NO_ERROR;</p>
<pre><code>switch (cmd) {
// switch能处理的命令很多, 我们省略掉其他命令, 重点看正常数据处理
...
case BR_TRANSACTION:
    {
        binder_transaction_data tr;
        result = mIn.read(&amp;tr, sizeof(tr));
        LOG_ASSERT(result == NO_ERROR,
            &quot;Not enough command data for brTRANSACTION&quot;);
        if (result != NO_ERROR) break;

        Parcel buffer;
        buffer.ipcSetDataReference(
            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
            tr.data_size,
            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
            tr.offsets_size/sizeof(size_t), freeBuffer, this);

        // 判断和设置优先级
        ...

        Parcel reply;
        if (tr.target.ptr) {
            sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
            const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);// 实际执行的是 BBinder.transact() !
            if (error &lt; NO_ERROR) reply.setError(error);

        } else {
            const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
            if (error &lt; NO_ERROR) reply.setError(error);
        }

        if ((tr.flags &amp; TF_ONE_WAY) == 0) {
            LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);
            sendReply(reply, 0);
        } else {
            LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);
        }
        ...
    }
    break;
...
return result;
</code></pre><p>}<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可见它调用了`BBinder::transact()`来处理数据, 该函数定义如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/Binder.cpp<br>status_t BBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    data.setDataPosition(0);</p>
<pre><code>status_t err = NO_ERROR;
switch (code) {
    case PING_TRANSACTION:
        reply-&gt;writeInt32(pingBinder());
        break;
    default:
        err = onTransact(code, data, reply, flags);// 调用onTransact
        break;
}

if (reply != NULL) {
    reply-&gt;setDataPosition(0);
}

return err;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在此处`b-&gt;transact`调用时, `b`是一个`JavaBBinder`实例, `JavaBBinder`继承了`BBinder`类, 重写了`onTransact`, 所以这里实际调用的是`JavaBBinder.onTransact`, 定义见`frameworks/base/core/jni/android_util_Binder.cpp`:</div></pre></td></tr></table></figure></p>
<p>virtual status_t onTransact(<br>    uint32_t code, const Parcel&amp; data, Parcel<em> reply, uint32_t flags = 0)<br>{<br>    JNIEnv</em> env = javavm_to_jnienv(mVM);<br>    …<br>    jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,<br>        code, (int32_t)&amp;data, (int32_t)reply, flags);// 调用gBinderOffsets.mExecTransact<br>    …<br>    return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;<br>}</p>
<p>static int int_register_android_os_Binder(JNIEnv* env)<br>{<br>    jclass clazz;</p>
<pre><code>clazz = env-&gt;FindClass(kBinderPathName);
LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Binder&quot;);
...
gBinderOffsets.mExecTransact
    = env-&gt;GetMethodID(clazz, &quot;execTransact&quot;, &quot;(IIII)Z&quot;);
...
return AndroidRuntime::registerNativeMethods(
    env, kBinderPathName,
    gBinderMethods, NELEM(gBinderMethods));
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由上可见, `JavaBBinder`通过JNI的`gBinderOffsets.mExecTransact`调用java方法`android.os.Binder.execTransact`. 执行的实际上是`android.os.Binder.onTransact`. 它的实现如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/java/android/os/Binder.java</p>
<p>// Entry point from android_util_Binder.cpp’s onTransact<br>private boolean execTransact(int code, int dataObj, int replyObj,<br>        int flags) {<br>    Parcel data = Parcel.obtain(dataObj);<br>    Parcel reply = Parcel.obtain(replyObj);<br>    // theoretically, we should call transact, which will call onTransact,<br>    // but all that does is rewind it, and we just got these from an IPC,<br>    // so we’ll just call it directly.<br>    boolean res;<br>    try {<br>        res = onTransact(code, data, reply, flags);<br>    }<br>    // catch clauses<br>    …<br>    reply.recycle();<br>    data.recycle();<br>    return res;<br>}</p>
<p>protected boolean onTransact(int code, Parcel data, Parcel reply,<br>       int flags) throws RemoteException {<br>   if (code == INTERFACE_TRANSACTION) {<br>       reply.writeString(getInterfaceDescriptor());<br>       return true;<br>   } else if (code == DUMP_TRANSACTION) {<br>       ParcelFileDescriptor fd = data.readFileDescriptor();<br>       String[] args = data.readStringArray();<br>       if (fd != null) {<br>           try {<br>               dump(fd.getFileDescriptor(), args);<br>           } finally {<br>               try {<br>                   fd.close();<br>               } catch (IOException e) {<br>                   // swallowed, not propagated back to the caller<br>               }<br>           }<br>       }<br>       // Write the StrictMode header.<br>       if (reply != null) {<br>           reply.writeNoException();<br>       } else {<br>           StrictMode.clearGatheredViolations();<br>       }<br>       return true;<br>   }<br>   return false;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">由此可见, 经过Binder驱动之后, 最终会在服务端进程的`android.os.Binder.onTransact`处理命令和数据. 而我们在服务端的`IYourService.Stub`中, 重写了`onTransact`来调用服务接口的服务端实现(大多数情况下, 这个重写是aidl工具帮你完成的). 至此, Binder驱动下的IPC通讯过程已全部明了(除了中间处理进程状态的过程以及打开Binder设备文件进行数据读写的过程以外).  </div><div class="line"></div><div class="line">一句话总结就是: 客户端发送`BC_TRANSACTION`命令到Binder驱动-&gt;服务端进程监听`BR_TRANSACTION`命令并处理;如果是服务端返回数据, 过程类似, 但发送的命令是`BC_REPLY`命令-&gt;客户端监听`BR_REPLY`命令  </div><div class="line"></div><div class="line">#### Binder设备驱动实现</div><div class="line">在[上一节中](#talkWithDriver), 我们只简单提了一下`ioctl`系统调用是对`/dev/binder`设备文件进行读写操作, 这一节详述该过程.  </div><div class="line"></div><div class="line">首先, `ioctl`第一个参数`mProcess-&gt;mDriverFD`是Binder驱动的文件描述符(File Descriptor), 它是在`ProcessState`初始化时由函数`open_driver()`初始化的, `open_driver`代码如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/ProcessState.cpp<br>static int open_driver()<br>{<br>    int fd = open(“/dev/binder”, O_RDWR);<br>    if (fd &gt;= 0) {<br>        fcntl(fd, F_SETFD, FD_CLOEXEC);<br>        int vers;<br>        // 获取驱动版本<br>        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);<br>        if (result == -1) {<br>            LOGE(“Binder ioctl to obtain version failed: %s”, strerror(errno));<br>            close(fd);<br>            fd = -1;<br>        }<br>        // 检查驱动版本是否一致<br>        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {<br>            LOGE(“Binder driver protocol does not match user space protocol!”);<br>            close(fd);<br>            fd = -1;<br>        }<br>        // 设置最多15个线程<br>        size_t maxThreads = 15;<br>        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<br>        if (result == -1) {<br>            LOGE(“Binder ioctl to set max threads failed: %s”, strerror(errno));<br>        }<br>    } else {<br>        LOGW(“Opening ‘/dev/binder’ failed: %s\n”, strerror(errno));<br>    }<br>    return fd;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">初始化后文件描述符保存在`mDriverFD`中, 以后通过它就可以和设备文件交互.  </div><div class="line"></div><div class="line">其次, 在经过`ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)`调用后, 对设备驱动文件的读写操作就被完全封装在了结构体`binder_write_read`中. 具体的读写过程见[talkWithDriver的实现代码](#talkWithDriver)及我的注释.  </div><div class="line">可见, 真正的数据读写都是通过`/dev/binder`来执行的, 其上封了命令`BINDER_WRITE_READ`用一个数据结构`binder_write_read`来存储读取和写入的数据, 再上封了`transact`处理不同逻辑概念下的事务. 再上通过`BBinder`接口联系到JNI代码和Java代码.  </div><div class="line"></div><div class="line">[深入分析Android Binder 驱动]: http://blog.csdn.net/yangwen123/article/details/9316987  </div><div class="line">最后, 让我们看看`/dev/binder`这个驱动程序的实现. 它是Binder的最终实现.  </div><div class="line">在看驱动代码前, 我们需要了解一些背景知识. 作为一个特殊的字符型设备, Binder的挂载节点是`/dev/binder`, 遵循Linux设备驱动模型, 在驱动实现过程中主要通过`binder_ioctl`函数与用户空间的进程交换数据. Android中的Service都是通过它来完成IPC的, 具体来说, 在Android虚拟机启动前, 系统会先启动`ServiceManager`进程, 它负责打开Binder驱动程序, 并告诉驱动程序自己将作为系统服务的管理者(通过特殊命令`BINDER_SET_CONTEXT_MGR`, 此后`ServiceManager`也通过Binder驱动与其他进程进行通讯), 然后`ServiceManager`进入循环, 等待处理来自其他进程的数据.  </div><div class="line">在Android系统中共有三种IPC机制:  </div><div class="line">- 标准Linux Kernel IPC 接口  </div><div class="line">- 标准D-BUS 接口  </div><div class="line">- Binder接口  </div><div class="line"></div><div class="line">由于我没有了解过其他两种方式, 所以这里我就不评价孰优孰劣了, 在Android系统中大部分程序都使用了Binder接口. Binder是OpenBinder的精简实现, 包含一个Binder驱动程序, 一个Binder服务器, 一个Binder客户端.  </div><div class="line"></div><div class="line">清楚了以上背景之后, 让我们看一下Binder驱动程序的实现. Android中Binder协议的定义在头文件`binder.h`中, 不同版本源码的路径不太一样, 4.0的路径在`external/kernel-headers/original/linux/binder.h`, 定义了五种Binder类型(`bhd`分别表示`binder` `handle` `FD`三个大类):</div></pre></td></tr></table></figure></p>
<p>enum {<br>    BINDER_TYPE_BINDER    = B_PACK_CHARS(‘s’, ‘b’, ‘<em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(‘w’, ‘b’, ‘</em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_HANDLE    = B_PACK_CHARS(‘s’, ‘h’, ‘<em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(‘w’, ‘h’, ‘</em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_FD        = B_PACK_CHARS(‘f’, ‘d’, ‘*’, B_TYPE_LARGE),<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同样是在这个头文件中, 定义了用于进程间传输的数据结构, 称作Binder Object, 它是一个`flat_binder_object`结构体, 定义如下(为方便理解我把注释也放上来了):</div></pre></td></tr></table></figure></p>
<p>/*</p>
<ul>
<li>This is the flattened representation of a Binder object for transfer</li>
<li>between processes.  The ‘offsets’ supplied as part of a binder transaction</li>
<li>contains offsets into the data where these structures occur.  The Binder</li>
<li>driver takes care of re-writing the structure type and data as it moves</li>
<li><p>between processes.<br><em>/<br>struct flat_binder_object {<br> /</em> 8 bytes for large_flat_header. */<br> unsigned long        type;// Binder对象类型, 即前面Binder协议中五种类型的一种<br> unsigned long        flags;// 传输方式, 见下面transaction_flags</p>
<p> /<em> 8 bytes of data. </em>/<br> union {</p>
<pre><code>void        *binder;    /* local object */
signed long    handle;        /* remote object */
</code></pre><p> };</p>
<p> /<em> extra data associated with local object </em>/<br> void            *cookie;<br>};</p>
</li>
</ul>
<p>…<br>enum transaction_flags {<br>    TF_ONE_WAY    = 0x01,    /<em> this is a one-way call: async, no return </em>/<br>    TF_ROOT_OBJECT    = 0x04,    /<em> contents are the component’s root object </em>/<br>    TF_STATUS_CODE    = 0x08,    /<em> contents are a 32-bit status code </em>/<br>    TF_ACCEPT_FDS    = 0x10,    /<em> allow replies with file descriptors </em>/<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">从注释可以知道, `flat_binder_object`中的union结构存的就是要传输的数据, 当类型为`Binder`时, 数据是一个本地对象`*binder`, 当类型为`Handle`时, 数据是一个远程对象`handle`. Binder对象在进程间传递时, Binder驱动会修改它的类型和数据.  </div><div class="line">正如Binder的客户端和服务端是相对而言的一样, 这里的本地Binder和远程Handle对象也是相对而言的, 其实他们都指向同一个对象, 所以他们共用一个union空间, 只不过A的本地对象binder对于另一进程B来说就是远程对象handle.  </div><div class="line"></div><div class="line">虽然`flat_binder_object`是要传输的Binder对象, 但实际上Binder驱动并不直接操作它, 而是将它封装成了一个`binder_transaction_data`, 操作的直接对象是这个封装的数据. 该封装的定义如下:</div></pre></td></tr></table></figure></p>
<p>struct binder_transaction_data {<br>    /* The first two are only used for bcTRANSACTION and brTRANSACTION,</p>
<pre><code> * identifying the target and contents of the transaction.
 */
union {
    size_t    handle;    /* target descriptor of command transaction */
    void    *ptr;    /* target descriptor of return transaction */
} target;
void        *cookie;    /* target object cookie */
unsigned int    code;        /* transaction command */

/* General information about the transaction. */
unsigned int    flags;
pid_t        sender_pid;
uid_t        sender_euid;
size_t        data_size;    /* number of bytes of data */
size_t        offsets_size;    /* number of bytes of offsets */

/* If this transaction is inline, the data immediately
 * follows here; otherwise, it ends with a pointer to
 * the data buffer.
 */
union {
    struct {
        /* transaction data */
        const void    *buffer;// flat_binder_object被封装在*buffer中
        /* offsets from buffer to flat_binder_object structs */
        const void    *offsets;
    } ptr;
    uint8_t    buf[8];
} data;
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;hr/&gt;</div><div class="line">了解了真正传输的数据结构之后, 让我们来深入Binder生命周期. 以下内容涉及到: Binder设备创建, Binder启动, Binder释放,  Binder数据关联, Binder接口及命令含义. 我尽量从我自己追踪代码的习惯来讲解, 这样虽然效率比较低但是好处是更容易理解和回忆. 以下内容与源码实现紧密关联, 再次声明, 本文基于`Android4.0`源码写就, 不适用于其他版本.  </div><div class="line"></div><div class="line">1. Binder设备创建  </div><div class="line">    作为一个特殊的符号设备, Binder设备也是需要进行创建的. 可以合理猜测系统有一个统一的创建驱动设备的过程, Binder作为其中一个设备一起被创建(如果不对, 就追踪调用栈, 看哪里引用了`frameworks/base/cmds/servicemanager/binder.c`, 特别是调用了里面的`binder_open`). 在这种猜测下, 我们来找一下符号设备的创建(我假设你跟我一样不知道Android下启动过程是否跟Linux一样). 到源码目录搜索`/dev/binder`, 除了前面提到的`ProcessState.open_driver`以外, 在以下三个文件中还出现了`/dev/binder`: `frameworks/base/cmds/servicemanager/binder.c`, `system/core/rootdir/ueventd.rc`, `system/extras/tests/fstest/perm_checker.conf`. 好像没有看出哪个是创建binder设备? 别急, 如果你看过老罗的&lt;[在Ubuntu上为Android系统编写Linux内核驱动程序]&gt;一文, 就可能猜测, 在文件`frameworks/base/cmds/servicemanager/binder.c`中, 有完整的`binder_open` `binder_release` `binder_write`实现, 正好这三个操作是实现Linux设备驱动时需要定义的基本操作的一部分, 这意味着该文件很可能就是Binder设备驱动文件. 我们假设它的确是, 那么应该有设备注册和初始化操作(模块加载, 卸载方法), 但很遗憾搜索之后发现没有. 难道Binder设备不用注册吗? 不是的, 进一步在整个源码范围搜索binder注册函数`binder_init`, 发现它匹配到了`prebuilt/android-arm/kernel/vmlinux-qemu`, 而这个我们知道是预编译好的Linux内核, 看来应该是在Linux内核源码里实现的设备注册, 遗憾的是直接下载Android源码的话是不带内核源码的, 我只好去下载了对应的内核源码(4.0系统对应3.0内核, 2.2系统对应2.6内核, 4.2~4.3系统对应3.4内核). 本文不讲怎么下载Android内核代码, 直接给出相关代码片段:</div></pre></td></tr></table></figure></p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

// 定义文件操作函数
static const struct file_operations binder_fops = {
    .owner = THIS_MODULE,
    .poll = binder_poll,
    .unlocked_ioctl = binder_ioctl,
    .mmap = binder_mmap,
    .open = binder_open,
    .flush = binder_flush,
    .release = binder_release,
};

static struct workqueue_struct *binder_deferred_workqueue;

// 初始化函数
static int __init binder_init(void)
{
    int ret;

    // 创建了一个内核工作队列对象workqueue, 用于执行可以延期执行的工作任务
    binder_deferred_workqueue = create_singlethread_workqueue(&quot;binder&quot;);
    if (!binder_deferred_workqueue)
        return -ENOMEM;

    // 创建调试目录 /sys/kernel/debug/binder
    binder_debugfs_dir_entry_root = debugfs_create_dir(&quot;binder&quot;, NULL);
    if (binder_debugfs_dir_entry_root)
        binder_debugfs_dir_entry_proc = debugfs_create_dir(&quot;proc&quot;,
                         binder_debugfs_dir_entry_root);
    // 注册字符设备
    ret = misc_register(&amp;binder_miscdev);
    // 创建调试文件
    if (binder_debugfs_dir_entry_root) {
        debugfs_create_file(&quot;state&quot;,
                    S_IRUGO,
                    binder_debugfs_dir_entry_root,
                    NULL,
                    &amp;binder_state_fops);
                    ...
    }
    return ret;
}

// 调用初始化函数加载内核, 基本等价于不支持动态编译驱动模块的module_init, 如果需要把Binder改成动态的内核模块, 直接把这个device_initcall改成module_init, 同时添加驱动卸载接口函数 module_exit即可
device_initcall(binder_init);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可见在系统装载设备的时候, 就加载了Binder设备模块, 并绑定了设备操作对应的函数.  </div><div class="line"></div><div class="line">好奇心重一点的读者可能会去自行发掘Linux设备模块怎么编写. Linux驱动程序的一个主要功能就是向用户空间的程序提供操作接口, 这个接口是标准的, Binder包含的接口有:</div></pre></td></tr></table></figure>

-Proc接口（/proc/binder）
    . /proc/binder/state
    . /proc/binder/stats
    . /proc/binder/transactions
    . /proc/binder/transaction_log
    . /proc/binder/failed_transaction_log
    . /proc/binder/proc/

-设备接口（/dev/binder）
    . binder_open
    . binder_release
    . binder_flush
    . binder_mmap
    . binder_poll
    . binder_ioctl
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">2. Binder启动  </div><div class="line">    在`frameworks/base/cmds/servicemanager/binder.c`中定义了binder设备打开的函数`binder_open`:</div></pre></td></tr></table></figure>

struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    if (!bs) {
        errno = ENOMEM;
        return 0;
    }

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (bs-&gt;fd &lt; 0) {
        fprintf(stderr,&quot;binder: cannot open device (%s)\n&quot;,
                strerror(errno));
        goto fail_open;
    }

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);
    if (bs-&gt;mapped == MAP_FAILED) {
        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,
                strerror(errno));
        goto fail_map;
    }

        /* TODO: check version */

    return bs;

fail_map:
    close(bs-&gt;fd);
fail_open:
    free(bs);
    return 0;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个函数作用是把设备映射到内存, 在Binder设备驱动中还有一个同名函数负责打开Binder设备和设置引用计数, 如下:</div></pre></td></tr></table></figure>

// in file kernel/goldfish/drivers/staging/android/binder.c

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    // 初始化, 分配 binder_proc 数据结构内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
        return -ENOMEM;

    // 增加当前线程/进程的引用计数并赋值给proc-&gt;tsk
    get_task_struct(current);
    proc-&gt;tsk = current;
    // 初始化binder_proc队列和默认优先级
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    init_waitqueue_head(&amp;proc-&gt;wait);
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    // 增加 BINDER_STAT_PROC对象计数
    binder_stats_created(BINDER_STAT_PROC);
    // 添加进程节点proc_node到binder_procs的全局列表中, 任何进程都可以访问其他进程的binder_proc对象
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 保存进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 驱动文件的private_data指向proc
    filp-&gt;private_data = proc;

    binder_unlock(__func__);
    ...

    return 0;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. Binder释放  </div><div class="line">    同样是在`frameworks/base/cmds/servicemanager/binder.c`文件中定义了设备释放函数`binder_release`:</div></pre></td></tr></table></figure>

void binder_release(struct binder_state *bs, void *ptr)
{
    uint32_t cmd[2];
    cmd[0] = BC_RELEASE;
    cmd[1] = (uint32_t) ptr;
    binder_write(bs, cmd, sizeof(cmd));
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可见只是发送了一个释放命令给Binder驱动, 那么可以肯定驱动中也有一个释放函数, 正好前面看到过设备操作的接口中有一个就是`binder_release`与这里的函数同名, 不会是巧合. `kernel/goldfish/drivers/staging/android/binder.c`中相关代码片段如下:</div></pre></td></tr></table></figure>

static int binder_release(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc = filp-&gt;private_data;
    debugfs_remove(proc-&gt;debugfs_entry);
    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);

    return 0;
}
```
好嘛, 释放操作给了`binder_defer_work`, 这又是嘛? 其实前面我们在初始化的时候就有内容涉及到它: 在`create_singlethread_workqueue`的时候创建了一个叫做`binder_deferred_workqueue`的队列, 该队列用来调度执行`binder_deferred_work`, 而两者发生联系就是在函数`binder_defer_work`中, `queue_work`使用了他们作为函数参数. 前面说过这个队列里都是可以延期执行的任务, 而`binder_deferred_work`有三种类型, 即枚举变量`binder_deferred_state`中定义的`PUT_FILES` `FLUSH` `RELEASE`.  
显然, 释放的具体操作就要看`queue_work`函数了, 很可惜我查的资料里没有详述这个函数做了啥. 它的定义在`kernel/goldfish/kernel/workqueue.c`中, 粗略看了下, 理解不一定对, 感觉它跟Handler类似, 在入队work的时候获取执行work的worker, 而由别的过程控制出队和实际执行, 只不过它所处的层次更靠近硬件.  
</code></pre><ol>
<li>Binder数据关联<br> 前面说过, 传输对象中<code>binder</code>和<code>handle</code>其实指向的是同一个对象, 现在来解释一下为什么. 在一次调用中, 对于客户端进程来说, handle存储的索引是一个远端对象的句柄, 当数据经由Binder驱动传达到服务端的时候, 服务端就会把这个索引解释为本地对象的地址, 对于第三方来说, 客户端的handle和服务端的binder都是指向了服务端的那个Binder对象. 对于Binder来说, 对象的索引和映射是通过<code>binder_node</code>和<code>binder_ref</code>两个核心数据结构来完成的, 两个定义都可以在文件<code>kernel/goldfish/drivers/staging/android/binder.c</code>中看到. 对于Binder本地对象, 对象的Binder地址保存在<code>binder_node-&gt;ptr</code>里, 对于远程对象, 索引保存在<code>binder_ref-&gt;desc</code>里, 每一个<code>binder_node</code>都有一个<code>binder_ref</code>与之对应, 他们通过<code>ptr</code>和<code>desc</code>来做映射. 前面说过进程间传递的Binder对象实际上是<code>flat_binder_object</code>这个数据结构, 每个<code>flat_binder_object</code>在内核都有一个唯一的<code>binder_node</code>对象与之对应, 这个对象挂载在<code>binder_proc</code>的一棵二叉树上, 而每一个<code>binder_node</code>又有唯一一个<code>binder_ref</code>对象与之对应. 可以这么理解, <code>binder_ref-&gt;desc</code> <code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code> <code>flat_binder_object-&gt;handle</code>四者都指向同一个对象, 其中<code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code>的<code>binder_node</code>位于服务端. <code>binder_ref</code>按照node和desc两种方式映射到<code>binder_proc</code>对象上, 因此可以通过<code>binder_node</code>或者<code>desc</code>查找到<code>binder_ref</code>或<code>binder_node</code>. 对于一个<code>flat_binder_object</code>对象来说, 它的<code>binder, cookie, handle</code>都指向的同一个<code>binder_node</code>对象.<br> Binder驱动中, flush操作在关闭一个设备文件描述符拷贝时被调用, 这里不做探究. 另一个操作mmap(memory map)负责把设备内存映射到用户进程地址空间中, 用户进程可以像操作内存一样操作设备. 一般的设备驱动, 设备内存是设备本身具有的, 或者在驱动初始化时由<code>vmalloc</code>或<code>kmalloc</code>等内核函数分配好, Binder不同于此, 它的设备内存是由mmap操作来分配的, 分配方法是现在内核虚拟映射表上获取一段可用区域, 再分配物理页, 并把物理页映射到获取的虚拟地址区域. 每个进程/线程只能做一次mmap操作, 其后重复操作都会返回错误. mmap分配内存的代码见文件<code>kernel/goldfish/drivers/staging/android/binder.c#binder_mmap</code>片段, 过程大致是先做检查调用合法性等准备工作, 然后申请虚拟内存空间, 再使用<code>binder_update_page_range</code>分配物理空间(实际是分配了1个页的物理内存用来存储指针buffer, 1个物理页是4K, 1个指针是4字节, 所以1页最多可存1K个指针, 每个指针对应一个物理页, 所以对应最多4M物理空间, 这是一次mmap最多可以分配的物理内存量, 这里不管实际申请了多大的物理内存, 内核总是提供1页物理内存用来放buffer指针, 即每次都允许申请最多的物理页), 在该函数中利用Linux系统中内存相关函数完成具体分配任务, 完成后由<code>binder_buffer</code>负责管理该内存区域, <code>binder_buffer</code>放到了<code>proc-&gt;buffers</code>链表中, 今后就可以通过这段内存区域完成设备数据读写了. 更形象的插图见[深入分析Android Binder 驱动]相关章节, 本段主要参考该文和内核代码完成.  </li>
<li>Binder接口及命令<br> Binder能得以正确工作, 首先要依赖于一致的Binder协议. 其中Binder类型在前文<code>external/kernel-headers/original/linux/binder.h</code>中提到过, 一共3大类5小类. 其实该文件中还定义了Binder驱动支持的命令格式和数据定义, 分为客户端的<code>BinderDriverCommandProtocol</code>和服务端的<code>BinderDriverReturnProtocol</code>, 两个都是枚举类型, 很可惜以我现在的C水平, 看不懂枚举成员<code>BC_TRANSACTION = _IOW_BAD(&#39;c&#39;, 0, struct binder_transaction_data)</code>的写法是什么意思, 大概猜测是第一个参数是访问模式, 第二个参数是指令, 第三个参数是数据指针. 客户端命令(BC)中第一个参数都是’c’, 宏<code>_IOR_BAD</code>根据资料应该是指向的<code>ioctl</code>的, 也就是说这里的参数传给了<code>ioctl</code>. 服务端返回(BR)的第一个参数都是’r’, 表示read. 两个数据结构定义了Binder客户端和服务端可以执行的全部命令. 既然有协议, 自然就有版本, 细心的读者可能发现, 前文<code>binder_open</code>函数里面就隐藏了一段注释, 说明以后会有<code>check version</code>的步骤.  </li>
</ol>
<p>本节主要参考:  </p>
<ul>
<li>[深入分析Android Binder 驱动]  </li>
<li><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>  </li>
<li><a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">BinderIPC原理</a>  </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>给两个主要结论和一个图(图不是我画的, 但来源记不得了), 方便大家按图索骥.  </p>
<p><img src="/images/blogs/binder_native_stack.png" alt="binder native stack">  </p>
<ol>
<li><p>Binder的实现从上到下涉及到Java层(Application层)/JNI层/Native层(Runtime层)/Linux kernel层, 可以说涉及到了Android的整个架构, 说是它的核心之一一点不过分. 系统服务的注册/获取/使用/Intent传递都通过Binder驱动, 对它的深入理解将会起到提纲挈领的效果.  </p>
</li>
<li><p>上层的<code>android.os.Binder</code>是对Binder的一层封装, 一般不直接使用. 如果定义服务, 使用系统提供的<code>Service</code>接口即可(它完成了一个默认的<code>android.os.Binder</code>实现), 如果是自定义跨进程服务, 使用<code>AIDL</code>将是更快的方式, 它本质是一个对Binder操作进行封装的工具. 如果不嫌麻烦, 直接使用<code>android.os.Binder</code>来定义客户端和服务端也是完全可行的.  </p>
</li>
</ol>
<p>说实话这篇文章写得有点吃力, 一个是时间拉太长, 记忆跟不上, 另一个是这个内容本身比较难用平白的语言讲清楚. 感谢大家阅读, 难免理解有误或以讹传讹, 欢迎大家指正.  </p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/android/">android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/教程/">教程</a><a href="/tags/android/">android</a><a href="/tags/面试/">面试</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://blog.hjhjw1991.net/android/2017/01/10/[Android教程]Binder全解/" data-title="【Android教程】Binder全解 | hjhjw1991&#39;s blog" data-tsina="1304671950" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/android/2017/01/23/[Android教程]SharedPreference详解/" title="【Android教程】SharedPreference详解">
  <strong>上一篇：</strong><br/>
  <span>
  【Android教程】SharedPreference详解</span>
</a>
</div>


<div class="next">
<a href="/android/2017/01/06/[Android教程]Handler全解/"  title="【Android教程】Handler全解">
 <strong>下一篇：</strong><br/> 
 <span>【Android教程】Handler全解
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#某渣的凭印象回-hu-顾-zhou"><span class="toc-number">1.</span> <span class="toc-text">某渣的凭印象回(hu)顾(zhou)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder的设计思想-工作原理"><span class="toc-number">2.</span> <span class="toc-text">Binder的设计思想/工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder实践"><span class="toc-number">3.</span> <span class="toc-text">Binder实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service的启动过程"><span class="toc-number">3.1.</span> <span class="toc-text">Service的启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">4.</span> <span class="toc-text">结语</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="hjhjw1991" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/android/" title="android">android<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/blog/" title="blog">blog<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/opinion/" title="opinion">opinion<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/tips/" title="tips">tips<sup>4</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/android/" title="android">android<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/教程/" title="教程">教程<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/windows/" title="windows">windows<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/vps/" title="vps">vps<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ssh/" title="ssh">ssh<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/jekyll/" title="jekyll">jekyll<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式/" title="正则表达式">正则表达式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/vpn/" title="vpn">vpn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/mac/" title="mac">mac<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/uwsgi/" title="uwsgi">uwsgi<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ios/" title="ios">ios<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://google.com" target="_blank" title="Google">Google</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="120" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1304671950&verifier=64e7ae81&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Huang Jun. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1304671950" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/hjhjw1991" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:hjhjw1991@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="hjhjw1991">hjhjw1991</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'hjhjw1991';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cd0e561542c22cc83da2e311ec57da84";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
