<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hjhjw1991&#39;s blog</title>
  <subtitle>Coder, Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.hjhjw1991.net/"/>
  <updated>2017-02-07T09:14:15.423Z</updated>
  <id>http://blog.hjhjw1991.net/</id>
  
  <author>
    <name>hjhjw1991</name>
    <email>hjhjw1991@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Android教程】Context全解</title>
    <link href="http://blog.hjhjw1991.net/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DContext%E5%85%A8%E8%A7%A3/"/>
    <id>http://blog.hjhjw1991.net/android/2017/01/23/[Android教程]Context全解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-02-07T09:14:15.423Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中会遇到很多场景需要Context, 包括但不限于: 获取资源, 创建View, 显示UI元素… 稍微追踪一下知道Context是一个接口, 当然从名字知道它是提供环境信息的接口, 今天我们就来看看, Context以及它的衍生类.  </p>
<h2 id="Context接口和作用"><a href="#Context接口和作用" class="headerlink" title="Context接口和作用"></a>Context接口和作用</h2><p>位于<code>frameworks/base/core/java/android/content/Context.java</code>, 是一个抽象类, 它定义了所有可用的接口, 在AS中查看它的类继承关系, 可以发现它有<code>MockContext</code>和<code>ContextWrapper</code>两个直接子类, 继续追下去会发现它有数量不少的间接子类, <code>Application</code> <code>Activity</code> <code>Service</code>都是它的子类, 这也正是在这些类中用到Context参数时可以直接传<code>this</code>的原因. 我们来看Context定义了哪些接口, 接口及其说明在官网Context页都有说明, 我这里只是相当于翻译一下. 大致上可以分为两类:  </p>
<ol>
<li><p>全局信息资源接口及其配套常量. 包括但不限于以下接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">getResources 返回Resources实例, 提供应用包的资源管理接口.  </div><div class="line">getAssets 返回AssetManager实例, 它提供资源管理接口. 它管理的资源应当和getResources管理的资源保持一致, 即它们维护同一套资源.  </div><div class="line">getPackageManager 返回PackageManager实例, 提供全局包信息.  </div><div class="line">getContentResolver 返回ContentResolver实例, 提供内容解析接口.  </div><div class="line">getText 封装Resources.getText  </div><div class="line">getString 封装Resources.getString</div><div class="line">getClassLoader 获取ClassLoader实例, 可以由此获取包内所有类</div><div class="line">getPackageName 获取应用包的包名  </div><div class="line">getSystemService 获取系统服务, 系统服务的名字以常量形式存在Context类中</div></pre></td></tr></table></figure>
</li>
<li><p>公共方法及其配套常量. 包括但不限于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getMainLooper 返回当前Context的Looper实例  </div><div class="line">getApplicationContext 获取应用的Context实例, 它不同于当前Context实例, 而是一个属于当前进程的, 全局的, 单例的, Application对象, 这意味着它的生命周期不同于当前Context, 而是跟当前进程捆绑  </div><div class="line">registerComponentCallbacks 注册组件回调  </div><div class="line">unregisterComponentCallbacks 注销组件回调  </div><div class="line">deleteFile 删除与当前应用包关联的私有文件  </div><div class="line">deleteDatabase 删除与当前应用包关联的私有SQLiteDatabase数据库  </div><div class="line">startActivity 开始一个Activity  </div><div class="line">registerReceiver 注册广播接收器  </div><div class="line">unregisterReceiver 注销广播接收器</div><div class="line">bindService 绑定服务  </div><div class="line">unbindService 解绑服务  </div><div class="line">startService 开始服务  </div><div class="line">stopService 停止服务  </div><div class="line">createPackageContext 以给定应用包名创建该应用的Context</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Context默认实现"><a href="#Context默认实现" class="headerlink" title="Context默认实现"></a>Context默认实现</h2><p>前文说了, Activity和Application都是Context的间接子类. 但是他们处于不同层级, 拥有不同的继承链, <code>Application</code>继承了<code>ContextWrapper</code>(<code>Service</code>也继承了它), 而<code>Activity</code>继承了<code>ContextThemeWrapper</code>(它是<code>ContextWrapper</code>的直接子类). 在<code>ContextWrapper</code>中提供了大多数方法的默认实现, 正如其名, 它只是包装了一个Context实现, 这个实现就是它的<code>mBase</code>成员变量, 是通过构造函数或者<code>attachBaseContext</code>传入的Context实例. 在应用启动过程中, <code>performLaunchActivity</code>会将一个<code>ContextImpl</code>实例作为参数传入<code>Activity.attach</code>方法, 该方法就用这个实例调用<code>attachBaseContext</code>设置好Context. 换句话说, Activity所拥有的Context就是一个随Activity生命周期的<code>ContextImpl</code>实例, Activity中对Context接口的调用, 中途经过<code>ContextThemeWrapper</code>和<code>ContextWrapper</code>, 最终到达这个<code>mBase</code>指向的<code>ContextImpl</code>的相应接口调用. 也就是说, 它就是我们要找的Activity Context默认实现.<br>那么Application Context呢? 它调用Context接口时最终同样会传达到mBase上, 它的mBase对象又是什么呢? 我们考察应用启动过程, 发现在<code>performLaunchActivity</code>中, 有一步是<code>makeApplication</code>, 返回一个<code>Application</code>对象. 该方法属于<code>LoadedApk</code>类, 打开该类查看, 发现它维护了一个<code>Application mApplication</code>成员变量, <code>makeApplication</code>方法在该变量非空时直接返回该变量(意味着无论调用多少次, 都返回同一个Application实例), 否则新建一个<code>ContextImpl</code>对象, 并以它为参数之一, 调用<code>mActivityThread.mInstrumentation.newApplication</code>返回一个<code>Application</code>对象. 再查看<code>newApplication</code>方法, 它位于<code>frameworks/base/core/java/android/app/Instrumentation.java</code>中, 其行为是使用给定的<code>ClassLoader</code>先装载给定的类(这里是<code>LoadedApk.makeApplication</code>中字符串<code>appClass</code>代表的<code>Application</code>类, 如果没有指定或强制使用默认appClass, 则该值为”android.app.Application”), 再用该类对象的<code>newInstance</code>创建实例并调用<code>attach</code>方法绑定Context实例. 可见, <code>Application</code>的Context仍然是<code>ContextImpl</code>实例, 不同的是它的生命周期与<code>Application</code>一致.<br><code>ContextImpl</code>类中对Context大多数接口方法都有了默认实现, 我们重点只看<code>getApplicationContext</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// in file ContextImpl.java</div><div class="line"></div><div class="line">@Override</div><div class="line">public Context getApplicationContext() &#123;</div><div class="line">    return (mPackageInfo != null) ?</div><div class="line">            mPackageInfo.getApplication() : mMainThread.getApplication();</div><div class="line">&#125;// mPackageInfo是LoadedApk类型</div></pre></td></tr></table></figure></p>
<p>方法<code>Activity.getApplication</code>返回的是成员变量<code>mApplication</code>, 根据其构造过程, 是在<code>attach</code>时赋值的<code>Application</code>实例, 换句话说, 在同一个应用中时, <code>Activity</code>中调用<code>getApplication</code>跟调用<code>getApplicationContext</code>返回的是同一个对象, 这可以很方便地验证.  </p>
<h2 id="Context使用中需要注意的问题"><a href="#Context使用中需要注意的问题" class="headerlink" title="Context使用中需要注意的问题"></a>Context使用中需要注意的问题</h2><p>前文中我们曾特地指出, <code>Activity</code>的Context跟<code>Application</code>的Context生命周期不同, 细心的同学可能要问了, 强调这个是因为有什么坑吗? 是的, 这里有坑.<br>原因就在于我们在创建组件的时候经常会用到Context这个参数, 有时为了图方便就直接传<code>this</code>, 大多数情况下也挺好使, 但其实这里存在很大的内存泄漏风险.<br>举个例子, 我们假设在<code>Activity</code>中创建了一个<code>Bitmap</code>, 为了在手机横竖屏切换的时候不至于重新装载这个资源, 我们将它写成<code>static</code>, 这样它的生命周期也就跟<code>Activity.class</code>相同了. 然后我们通过<code>setBackgroundDrawable</code>将它设置成了某个<code>View</code>(该<code>View</code>是通过<code>new View(this)</code>方法构造的实例)的背景. 我们知道, 在手机横竖屏切换的时候, 当前Activity会被销毁再重新创建, 因此此间会有一个gc标记过程. 这里存在什么问题呢? <code>setBackgroundDrawable</code>之后, 静态变量<code>Bitmap</code>会持有一个该<code>View</code>的引用, 而这个<code>View</code>持有一个<code>Activity</code>的引用, 这就导致<code>Activity</code>的引用计数不为0, gc过程无法回收该对象内存, 但是该对象已经不被任何过程使用, 于是就泄露了. 归根到底是因为创建<code>View</code>的时候使用了<code>Activity</code>作为Context, 但是该<code>View</code>由于存在被静态变量<code>Bitmap</code>引用的情况, 其实际生命周期要长于<code>Activity</code>.<br>解决这种泄露的方法是, 保证在<code>Activity</code>中使用<code>Activity</code>或<code>this</code>作为Context的任何对象, 其生命周期都不长于<code>Activity</code>本身, 否则应该考虑使用<code>Application Context</code>.<br>另外, 如果定义了非静态内部类, 那么对非静态内部类实例的引用也有可能导致外部类实例内存泄漏, 解决这种内存泄漏的方法是控制内部类的引用, 对于生命周期长于外部类的内部类, 应定义为静态内部类.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Android中的Context
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】SharedPreference详解</title>
    <link href="http://blog.hjhjw1991.net/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DSharedPreference%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.hjhjw1991.net/android/2017/01/23/[Android教程]SharedPreference详解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-02-07T09:12:54.883Z</updated>
    
    <content type="html"><![CDATA[<p>Android为各位开发者提供了简单的数据存储和交换的方式, 就是<code>SharedPreference</code>, 它是一个在应用数据目录下的<code>.xml</code>文件, 无论是从名字还是实际应用来看, 它都是存取轻量不涉及安全问题的数据(例如设置项)的趁手方式之一. 当然, 它采用xml这样的格式有其自己的考虑, 但未必是最合适的. 当然它的缺点也跟优点一样明显, 今天我们就来看看它在源码中是怎样实现的, 由此也可看出它的优缺点何在.<br>老方法, 我们从实际使用场景来倒推.<br>本文结构:  </p>
<ol>
<li>SharedPreference实现  </li>
<li>SharedPreference优缺点  </li>
</ol>
<h2 id="SharedPreference实现"><a href="#SharedPreference实现" class="headerlink" title="SharedPreference实现"></a>SharedPreference实现</h2><p>一个简单的读写场景通常用到<code>getSharedPreferences</code>接口, 和<code>SharedPreferences.Editor</code>. 例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// TextView ttvv has been initiated before</div><div class="line">SharedPreferences sp = getSharedPreferences(&quot;Test&quot;, MODE_PRIVATE);</div><div class="line">sp.edit().putBoolean(&quot;Another test key&quot;, true).commit();</div><div class="line">Map&lt;String, ?&gt; content = sp.getAll();</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">for(String key : content.keySet())&#123;</div><div class="line">    sb.append(String.format(&quot;%s=%s\n&quot;, key, content.get(key).toString()));</div><div class="line">&#125;</div><div class="line">ttvv.setText(&quot;SharedPreference测试:\n &quot;);</div><div class="line">ttvv.append(sb.toString());</div></pre></td></tr></table></figure></p>
<p>首先追踪<code>getSharedPreferences</code>发现它调用的是<code>ContextWrapper.mBase.getSharedPreferences</code>, <code>mBase</code>这个东西我在另一篇分析<code>Context</code>的博客中讲过, 这里不赘述, 我们直接看它的实现, 发现它返回的是一个<code>SharedPreferencesImpl</code>实例, 其首先在静态成员变量<code>sSharedPrefs</code>中获取以传入的参数<code>name</code>为key的实例, 如果没有则在一个固定目录<code>getPreferencesDir()</code>(默认是<code>shared_prefs</code>)以传入的参数(name)创建一个新的<code>SharedPreference</code>文件<code>name.xml</code>(默认实现中, name不能包含路径分隔符), 然后以(name, mode)创建一个<code>SharedPreferencesImpl</code>实例. 第一个参数很好理解, 就是SharedPreference文件的文件名, 第二个参数指的是文件创建模式, 可选的值在<code>Context</code>抽象类中有定义, 主要是<code>MODE_PRIVATE</code>(默认文件打开方式就是这个, 即仅有创建者所在的应用或共享该应用User ID的其他应用有访问权限) <code>MODE_WORLD_READABLE</code>等常量, 在<code>SharedPreference</code>写的时候会根据创建模式判断是否有写权限.<br><code>SharedPreferencesImpl</code>构造方法中, 开启了一个线程从文件系统中载入指定名称的<code>SharedPreference</code>文件(构造方法中会先备份文件, 载入时如果存在备份文件, 先删除当前文件, 再从备份文件恢复), 并解析成Map存在成员变量<code>mMap</code>中. 可见, 我们实际获得的就是一个普通的xml文件解析成的<code>HashMap</code>.<br>以上, 我们知道了一个<code>SharedPreference</code>文件的创建和读取. 至于<code>edit()</code>接口返回的<code>Editor</code>接口很好理解, 它就是提供了对<code>SharedPreference</code>文件操作的封装, 它的默认实现是<code>SharedPreferencesImpl.EditorImpl</code>, 基本上就是同步地读写<code>mModified</code>成员变量, 它是<code>Maps.newHashMap</code>创建的实例, 它只存储有更改的键值对. 这里我们需要重点关注Editor两个地方的实现<code>boolean commit()</code>和<code>void apply()</code>.<br>相信用过<code>SharedPreference</code>的同学都知道, 这两个接口都是用来提交变化到文件的, 但具体提交过程可能不是人人都清楚. 我们先来看两个接口的说明, 通常源码里面会有重要信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call commit wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line"> * using this from your application&apos;s main thread, consider</div><div class="line"> * using &#123;@link #apply&#125; instead.</div><div class="line"> *</div><div class="line"> * @return Returns true if the new values were successfully written</div><div class="line"> * to persistent storage.</div><div class="line"> */</div><div class="line">boolean commit();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call apply wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line"> * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line"> * commits its changes to the in-memory</div><div class="line"> * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line"> * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line"> * any failures.  If another editor on this</div><div class="line"> * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line"> * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line"> * &#123;@link #commit&#125; will block until all async commits are</div><div class="line"> * completed as well as the commit itself.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line"> * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line"> * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line"> * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line"> * writing to disk.  The framework makes sure in-flight disk</div><div class="line"> * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line"> * states.</div><div class="line"> *</div><div class="line"> * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line"> * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line"> * previously did implement it and are now getting errors</div><div class="line"> * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line"> * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line"> */</div><div class="line">void apply();</div></pre></td></tr></table></figure></p>
<p>果不其然, 接口注释中有重要提示. 首先对于<code>commit</code>接口, 源码注释给出了三个信息: 1. 返回值表示是否成功写入到存储器; 2. 两个Editor竞争时, 后调用commit的Editor最终生效; 3. 它<code>原子地</code>写入新值, 如果不关心返回值, 而且是在主线程中调用, 应该考虑<code>apply</code>接口. 第1点和第3点预示着commit方法是同步写入, 可能效率会比较低, 在主线程中调用会引起响应变慢, 同时暗示着<code>apply</code>可能是异步写入. 再来看<code>apply</code> 接口, 源码注释给出了三个信息: 1. commit是同步写入外存, 而apply是先写到内存, 再异步写入到外存, 并且不会给出失败通知; 2. 对于同一个<code>SharedPreference</code>, 如果一个apply在等待时, 另一个editor调用了一个commit, 那么这个commit会被阻塞直到所有异步提交以及这个commit本身完成为止; 3. 它<code>原子地</code>写入新值, 在<code>SharedPreference</code>本身是单例实现的情况下(现在默认情况就是), 将所有的<code>commit</code>替换成<code>apply</code>是安全的, Android Framework保证在改变状态前完成已入队的apply操作, 所以你也不用担心组件生命周期会影响apply.<br>可见二者的最主要区别就是, commit是同步地, apply是异步的. 那么它们写入<code>SharedPreference</code>时候, 是具体怎么写入的呢? 这就要看<code>SharedPreferencesImpl.EditorImpl</code>的实现了.<br>先看<code>EditorImpl.commit()</code>, 它首先调用<code>commitToMemory</code>提交到内存, 然后调用<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把提交结果<code>MemoryCommitResult</code>入队, 再调用<code>MemoryCommitResult.writtenToDiskLatch.await()</code>阻塞直到<code>MemoryCommitResult.setDiskWriteResult</code>被调用, 即该结果已经被处理. 到这里我们知道写入工作分两步, 先写入到内存, 再写入到外存. 稍后我们分别来看这两步具体内容, 这里先看<code>EditorImpl.apply()</code>的实现. 它首先调用<code>commitToMemory</code>提交到内存, 然后新建了一个<code>Runnable awaitCommit</code>内容是<code>MemoryCommitResult.writtenToDiskLatch.await()</code>, 所以这个<code>Runnable</code>中会阻塞直到结果被处理. 然后它把这个<code>Runnable</code>加入到了<code>QueuedWork</code>中, 并且再新建了一个<code>Runnable postWriteRunnable</code>, 里面调用<code>awaitCommit.run()</code>, 并从<code>QueueWork</code>中移除<code>awaitCommit</code>. 最后, 它通过<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把这个<code>postWriteRunnable</code>入队. 可见, 它是一个异步的提交过程. 以上两个方法的具体实现, 也解释了apply和commit冲突时commit将会阻塞直到所有的apply完成的原因: commit会等待直到自己的提交被执行, 而它之前调用的apply在队列中会先于它处理.<br>现在清楚了提交过程, 来看Editor的数据是如何写入到内存的.<br>在<code>commitToMemory</code>中, 首先实例化了一个<code>MemoryCommitResult mcr</code>, 并让它保存了一个<code>mMap</code>的引用在<code>mapToWriteToDisk</code>成员中. 存在监听器时, 初始化它的<code>keysModified</code>和<code>listeners</code>成员, 并在后面把变化了的键放到<code>keysModified</code>中. 然后遍历<code>mModified</code>, 将新的值写入到<code>mMap</code>中, 或者从<code>mMap</code>中移除预定要移除的值, 最后清空<code>mModified</code>并返回<code>mcr</code>. 简单来说, 它把变化的内容复制到了<code>mMap</code>这个原始内容中.<br>最后, 来看被加入到队列中的<code>MemoryCommitResult</code>是如何被处理的. 先把源码放上方便各位对照:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                              final Runnable postWriteRunnable) &#123;</div><div class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr);</div><div class="line">                &#125;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                if (postWriteRunnable != null) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</div><div class="line"></div><div class="line">    // Typical #commit() path with fewer allocations, doing a write on</div><div class="line">    // the current thread.</div><div class="line">    if (isFromSyncCommit) &#123;</div><div class="line">        boolean wasEmpty = false;</div><div class="line">        synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">        &#125;</div><div class="line">        if (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看<code>enqueueDiskWrite</code>函数, 发现它先定义了一个<code>Runnable writeToDiskRunnable</code>, 内容是同步地调用<code>writeToFile(mcr)</code>, 递减<code>mDiskWritesInFlight</code>计数(该计数在调用<code>commitToMemory</code>时递增), 调用<code>postWriteRunnable.run</code>. 然后判断是否commit, 判断的方法也是非常暴力: <code>postWriteRunnable == null</code>就是同步commit. 此时先判断当前是否只有自己一个任务在执行, 是的话直接在当前线程上调用<code>writeToDiskRunnable.run</code>然后返回, 否则调用<code>QueueWork.singleThreadExecutor().execute(writeToDiskRunnable)</code>来执行. 我另一篇讲Java并发的博客讲过<code>singleThreadExecutor</code>是什么鬼. 显然, 无论是commit还是apply, 最后都是在用一个单线程池在跑, 跑的内容主要就是<code>writeToFile</code>. 在<code>QueueWork</code>中, 添加的任务都在<code>ConcurrentLinkedQueue sPendingWorkFinishers</code>队列中, 这里我们不再讲该队列的处理.<br>查看<code>writeToFile</code>的实现, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// Note: must hold mWritingToDiskLock</div><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mcr.changesMade) &#123;</div><div class="line">            // If the file already exists, but no changes were</div><div class="line">            // made to the underlying map, it&apos;s wasteful to</div><div class="line">            // re-write the file.  Return as if we wrote it</div><div class="line">            // out.</div><div class="line">            mcr.setDiskWriteResult(true);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mBackupFile.exists()) &#123;</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, &quot;Couldn&apos;t rename file &quot; + mFile</div><div class="line">                      + &quot; to backup file &quot; + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        if (str == null) &#123;</div><div class="line">            mcr.setDiskWriteResult(false);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        FileStatus stat = new FileStatus();</div><div class="line">        if (FileUtils.getFileStatus(mFile.getPath(), stat)) &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                mStatTimestamp = stat.mtime;</div><div class="line">                mStatSize = stat.size;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125; // catch exceptions</div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, &quot;Couldn&apos;t clean up partially-written file &quot; + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码放在博客里有一丢丢长, 但是除了log以外我都没舍得删, 因为我觉得写得很美, 尤其是虽然代码不多但注释不少. 该函数首先判断是否有改变, 没有改变就返回了, 然后判断备份文件是否存在, 不存在则把当前文件作为备份文件. 备份好了后在原文件位置创建新的文件来操作, 把整个<code>mcr.mapToWriteToDisk</code>写入到新文件中, 一切顺利的情况下, 更新<code>SharedPreferencesImpl</code>文件状态信息, 删除备份文件, 并设置写入结果为true, 然后返回. 一旦出错, 就会执行到后面的扫尾代码, 此时将新文件删除, 并设置写入结果为false. 注释里面有一个小提示, <code>Attempt to write the file, delete the backup and return true as atomically as possible</code>, 也就是说这个写入过程可能不是原子的, 只是实现上尽量保证原子而已.<br>至此, <code>SharedPreference</code>的实现原理我们已经大致了解.  </p>
<h2 id="SharedPreference优缺点"><a href="#SharedPreference优缺点" class="headerlink" title="SharedPreference优缺点"></a>SharedPreference优缺点</h2><p><code>SharedPreference</code>的优点是显而易见的: 系统实现, 拿来即可用; 接口定义清晰, 容易使用; 采用Map数据结构实现, 可以存储对象; 在Application中全局可见, 并且全局单例.<br>同时它的缺点也是很明显:  </p>
<ol>
<li>从第一节的分析可以看出, 每次有变化时, 系统默认是将整个<code>SharedPreference</code>文件备份, 写入新文件, 再删除备份文件. 这就意味着<code>SharedPreference</code>不适合存储大量内容, 也不适合对内容改动很少但很频繁的场景, 否则会因为文件读写而存在性能瓶颈. 前者是天然限制, 而后者可以通过尽量少调用commit和apply来规避;  </li>
<li>apply中混用commit可能导致效率降低. 原因在上面分析中讲过, commit会等待前面所有的apply完成, 也就意味着无论前面用了多少次apply, 一旦后面跟着一个commit, 对于commit所在的线程来说, apply的优势就荡然无存了.<br>另外, 由于该文件是通过应用创建的, 所以可以直接在应用数据目录下看到文件内容, 安全性不能保证, 不过这就不在本文讨论范围之内了.  </li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>分析了这些, 对于我们有什么用呢? 虽然我很讨厌什么都用”有没有用”来衡量, 但不写个结论确实也感觉文章虎头蛇尾. <code>SharedPreference</code>源码分析至少给我们几点启示:  </p>
<ol>
<li>注意<code>SharedPreference</code>的使用场景, 尽量规避它所不擅长的情景. 使用时如果对实时性和写入结果要求不高, 尽量只使用<code>apply</code>提交改动.  </li>
<li>完全可以仿照源码自行实现<code>SharedPreference</code>读写接口. 一个应用显然可以有多个<code>SharedPreference</code>文件, 将强耦合的内容分别聚拢到各自的<code>SharedPreference</code>文件中, 理论上可以提高读写效率, 如果有更高效的<code>SharedPreference</code>内容管理方式, 可以完全抛开系统实现, 自行管理<code>SharedPreference</code>文件.  </li>
<li><code>SharedPreference</code>的访问权限是创建时决定的, 依赖于文件创建模式参数, 不一定只有本应用可以访问.  </li>
<li>它一点也不神秘, 甚至在Android系统架构中地位也不太重要, 任何时候它被别的方式取代我也不会吃惊, 但它的实现代码, 透露着一种简洁的优雅.  </li>
</ol>
<p>本篇博客没有参考文献, 唯一参考来源是Android 4.0源码及其注释, 当然自己写来验证想法的Demo不算.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲SharedPreference共享设置
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Binder全解</title>
    <link href="http://blog.hjhjw1991.net/android/2017/01/10/%5BAndroid%E6%95%99%E7%A8%8B%5DBinder%E5%85%A8%E8%A7%A3/"/>
    <id>http://blog.hjhjw1991.net/android/2017/01/10/[Android教程]Binder全解/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-02-07T09:09:04.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回-hu-顾-zhou"><a href="#某渣的凭印象回-hu-顾-zhou" class="headerlink" title="某渣的凭印象回(hu)顾(zhou)"></a>某渣的凭印象回(hu)顾(zhou)</h2><p>Binder是Android提供的一种RPC机制, 它是C/S架构, 可以远程调用服务, 调用其他进程甚至其他App的服务. 它利用AIDL描述服务接口, 通过bind和unbind绑定和解绑具体服务, 其内部使用代理完成服务功能的调用. 调用方需要知道AIDL, 被调用方需要实现AIDL. Android系统的服务就是通过Binder机制来使用的.  </p>
<h2 id="Binder的设计思想-工作原理"><a href="#Binder的设计思想-工作原理" class="headerlink" title="Binder的设计思想/工作原理"></a>Binder的设计思想/工作原理</h2><p>Binder是一种进程间通讯的机制, 不同于Handler的线程间通讯, 由于进程间没有共享区域, 所以Handler那种消息队列的机制在进程之间进行就会变得比较麻烦(进程A将消息拷贝到内核缓存空间, 另一进程B从内核缓存空间取消息), 特别是当进程间通讯涉及到接口调用等业务流程时. 出于安全性考虑, 一个进程的空间只对进程内部开放, 外部想要访问进程内的数据, 就只能曲线救国. Binder就是其中一种方式.  </p>
<p>Binder是一种特化的AIDL服务, 换句话说, AIDL是对Binder机制的上层封装, 它可以快速实现进程间通讯, 所以要想理解Binder就必须理解AIDL. 关于AIDL可以看我的博文<a href="http://hjhjw1991.github.io/android/2016/04/01/[Android%E6%95%99%E7%A8%8B]AIDL%E5%85%A5%E9%97%A8/" target="_blank" rel="external">AIDL入门</a>, 简单来说, AIDL是服务的接口描述文件, 它在服务端和客户端都共同存在且内容相同, SDK的aidl工具可以帮助我们把<code>.aidl</code>文件转换成同名的<code>.java</code>文件, 只要我们手工调用该工具转换一下, 并看一看转换后的文件, 我相信就能够完全理解aidl的使用原理了(其实跟Hessian之类的RPC框架大同小异). 具体到Binder, 我们可以去看看Binder的实现源码和Binder驱动的源码, 说白了就是系统为我们实现了一套基于Binder接口的获取/绑定/解绑/释放服务代理的业务逻辑, 我们只需要负责将具体的服务传给Binder就可以了. 如果没有Binder, 进行进程间通讯就必须要自己实现基于AIDL的业务逻辑, 实际上这样也是行得通的, 只不过系统服务都是基于Binder实现的, 所以我们有必要了解Binder的实现原理.<br>在最下层, Binder驱动通过Native代码实现, 它是Binder接口的最终实现, 关于Binder驱动的源码可以看这篇博客<a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>, 尤其是其代码注释.  </p>
<p>在Linux中有很多进程间通讯的方式, 为什么Android唯独自己实现了一个Binder机制? 我认为主要原因是现有的Linux进程间通讯方式都太”重”了, 含有许多虽然好但是在Android环境下并不实用的特性. 可以明确的是, 现有的进程间通讯方式肯定可以应用在Android这个基于Linux系统内核的操作系统上. 相比之下, Binder的设计使得它只进行一次数据拷贝, 传输更加高效, 而且发送方和接收方都互相知道对方身份, 更加安全.  </p>
<h2 id="Binder实践"><a href="#Binder实践" class="headerlink" title="Binder实践"></a>Binder实践</h2><p>依旧, 如果只想用Binder, 那直接继承它并实现相应接口即可, 这里的实践指的是看Binder源码. 默认大家已经看过并理解了AIDL的相关内容.<br>不同于上层Framework, 这里要理解Binder需要涉及到底层native代码, 所以我们要提前准备好Android系统源码, 当然前面看Java层代码时不需要. 这里我以4.0源码为基础.<br>照惯例我们先从Binder源码看起. 打开<code>frameworks/base/core/java/android/os/Binder.java</code>, 先来看看它都有哪些主要内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">注释, 大意是说这个类是一个用于远程调用的基类, 是IBinder中定义的轻量级RPC的核心部分, 提供了远程对象本地实现的标准支持, 多数情况下开发者不需要直接实现Binder类, 而是利用aidl工具描述服务接口, 让aidl自动生成合适的Binder子类, 但是开发这当然可以直接继承Binder来实现自己的RPC协议或者仅仅是实例化一个Binder对象作为token在进程之间共享.</div><div class="line">*/</div><div class="line">public class Binder implements IBinder&#123;// Binder类实现IBinder接口</div><div class="line">private int mObject;</div><div class="line">private IInterface mOwner;</div><div class="line">private String mDescriptor;</div><div class="line"></div><div class="line">public static final native int getCallingPid();// 调用者进程ID, 可以用来检查权限</div><div class="line">public static final native int getCallingUid();// 返回与进程绑定的调用者用户ID, 可以用来检查权限</div><div class="line">public static final native long clearCallingIdentity();// 重置调用者ID, 当你需要调用别的Interface的时候, 为了让被调用的Interface检查你自己的权限, 你需要重置调用者ID. 它返回的token可以通过下面这个方法恢复调用者ID  </div><div class="line">public static final native void restoreCallingIdentity(long token);// 恢复调用者ID</div><div class="line">public static final native void setThreadStrictModePolicy(int policyMask);// 设置native层StrictMode策略</div><div class="line">public static final native int getThreadStrictModePolicy();// 获取native层StrictMode策略</div><div class="line">public static final native void flushPendingCommands();// 把等待中的命令刷到内核驱动. 如果将要执行一个可能阻塞很长时间的命令, 那么本方法可以将线程中等待的命令刷到内核驱动, 以防止本线程过久地持有等待中命令的引用</div><div class="line">public static final native void joinThreadPool();// 把调用者线程加入IPC线程池, 该方法仅在进程退出时返回</div><div class="line"></div><div class="line">public Binder() &#123;</div><div class="line">	init();// native method</div><div class="line">	// code to check potential leaks</div><div class="line">&#125;</div><div class="line">public void attachInterface(IInterface owner, String descriptor);// 绑定IInterface和对应的descriptor</div><div class="line">public String getInterfaceDescriptor();</div><div class="line">public boolean pingBinder();// 默认返回true</div><div class="line">public boolean isBinderAlive();// 默认返回true</div><div class="line">public IInterface queryLocalInterface(String descriptor);// 返回descriptor对应的IInterface或者null</div><div class="line">protected boolean onTransact(int code, Parcel data, Parcel reply, int flags);// 真正的事务执行函数, 希望子类重写</div><div class="line">public final boolean transact(int code, Parcel data, Parcel reply, int flags);// 事务执行函数, 里面回调onTransact</div><div class="line">private boolean execTransact(int code, int dataObj, int replyObj, int flags);// 回调onTrasact, 如果抛出异常则返回true</div><div class="line">public void linkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line">public boolean unlinkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line"></div><div class="line">private native final void init();</div><div class="line">private native final void destroy();</div><div class="line">&#125;// Binder类</div><div class="line"></div><div class="line">final class BinderProxy implements IBinder &#123;// BinderProxy类</div><div class="line">    BinderProxy() &#123;</div><div class="line">        mSelf = new WeakReference(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 以下六个方法都成了native方法</div><div class="line">    public native boolean pingBinder();</div><div class="line">    public native boolean isBinderAlive();</div><div class="line">    public native String getInterfaceDescriptor();</div><div class="line">    public native boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line">    public native void linkToDeath(DeathRecipient recipient, int flags);</div><div class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</div><div class="line"></div><div class="line">    final private WeakReference mSelf;// 指向自身的弱引用</div><div class="line">    private int mObject;</div><div class="line">    private int mOrgue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完源码至少有三个疑问: 1. IInterface和IBinder定义了哪些接口? 2. BinderProxy是什么, 怎么用的? 3. <code>Binder.java</code>中涉及到的那些native方法, 是怎么实现的?<br>打开<code>frameworks/base/core/java/android/os/IBinder.java</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/** 注释中详细讲述了IBinder的设计思路. 核心API是transact(), 与Binder的onTransact成对. 作为本地对象的它发送一个调用到远程IBinder对象, 同时作为远程对象的它可以接受一个调用并放到一个Binder对象中. 这个API是同步的, 以保证仅在远程onTransact返回后, 本地transact才返回, 这是所期望的行为.  </div><div class="line">系统在每个进程中维护一个事务线程池, 用于分发所有从外部进程进来的IPC. Binder系统允许递归调用, 比如A调用B, B的onTransact中又调用了A. */</div><div class="line">    // 定义了用户可以使用的事务代码</div><div class="line">    int FIRST_CALL_TRANSACTION  = 0x00000001;</div><div class="line">    int LAST_CALL_TRANSACTION   = 0x00ffffff;</div><div class="line"></div><div class="line">    // IBinder协议的事务代码</div><div class="line">    int PING_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;P&apos;&lt;&lt;16)|(&apos;N&apos;&lt;&lt;8)|&apos;G&apos;;</div><div class="line">    int DUMP_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;D&apos;&lt;&lt;16)|(&apos;M&apos;&lt;&lt;8)|&apos;P&apos;;</div><div class="line">    int INTERFACE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;N&apos;&lt;&lt;16)|(&apos;T&apos;&lt;&lt;8)|&apos;F&apos;;</div><div class="line">    int TWEET_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;T&apos;&lt;&lt;16)|(&apos;W&apos;&lt;&lt;8)|&apos;T&apos;;</div><div class="line">    int LIKE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;L&apos;&lt;&lt;16)|(&apos;I&apos;&lt;&lt;8)|&apos;K&apos;;// 告诉app调用者喜欢它. 可选命令, 应用不必处理, 没啥卵用. 默认实现啥也不做.  </div><div class="line">    int SYSPROPS_TRANSACTION = (&apos;_&apos;&lt;&lt;24)|(&apos;S&apos;&lt;&lt;16)|(&apos;P&apos;&lt;&lt;8)|&apos;R&apos;;// hide</div><div class="line"></div><div class="line">    // transact的标记, 表示这是一个单向调用, 调用者不等待被调用者的结果, 而是立即返回</div><div class="line">    int FLAG_ONEWAY             = 0x00000001;</div><div class="line">    public static final int MAX_IPC_SIZE = 64 * 1024;// hide</div><div class="line"></div><div class="line">    public String getInterfaceDescriptor();</div><div class="line">    // 查询Binder是否可用有三种方式, 当Binder不可用时, transact()会抛出RemoteException, pingBinder()会返回false, linkToDeath()预先连接一个DeathRecipient, 不可用时会回调这个DeathRecipient的binderDied()</div><div class="line">    public boolean pingBinder();</div><div class="line">    public boolean isBinderAlive();</div><div class="line"></div><div class="line">    public IInterface queryLocalInterface(String descriptor);</div><div class="line"></div><div class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line"></div><div class="line">    public interface DeathRecipient &#123;</div><div class="line">        public void binderDied();</div><div class="line">    &#125;</div><div class="line">    public void linkToDeath(DeathRecipient recipient, int flags);// 连接一个DeathRecipient接收器, 当Binder不可用时回调</div><div class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</div></pre></td></tr></table></figure></p>
<p>可见, IBinder定义了一套Transaction协议用于指明发起的Transaction类型, 定义了<code>transact()</code>核心接口, 该接口与Binder中的<code>onTransact</code>配合使用才能完成远程调用的功能. 定义了查询接口, 返回一个<code>IInterface</code>实例. 下面看看这个接口定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IInterface</div><div class="line">&#123;</div><div class="line">    public IBinder asBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就这一个接口方法, 返回<code>IBinder</code>实例. 注释中说该方法返回与该Interface绑定的Binder实例.<br>以上这些内容, 定义了一个基本的Binder系统框架, 即通过同一套<code>Binder &amp; IBinder &amp; IInterface</code>接口, 本地以<code>transact()</code>发起远程调用, 远程在<code>onTransact()</code>中处理相应调用. 本地以<code>asInterface()</code>获取远程服务的实例(实际获得的是服务的代理, 代理内对每个服务接口中的方法, 调用远程服务的transact方法, 传递一个约定好的事务代码和方法参数, 远程服务的onTransact会对每个约定好的事务代码, 生成相应的switch case, 调用真正的服务接口实现. 由于客户端和服务端对服务接口的定义是相同的, 故生成的服务接口也相同, 可以在本地aidl生成的java文件中查看onTransact的实现), 远程以<code>asBinder()</code>返回远程服务的实例, 本地通过asInterface返回的代理来调用远程服务的方法, 跟调用本地服务方法表面上看起来没有差别.  </p>
<h3 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h3><p>离开具体实现的Binder是无法工作的, 我们自己当然可以自行继承Binder来写自己的远程服务. AIDL是Android为我们提供的一种方便快捷生成Binder实现的方式和工具, 而Service是由系统实现了服务端的Binder. 我们以它为例, 说明如何启动服务, 以及其中哪里用到了Binder.<br>我们知道, 要获取服务(系统服务除外, 其实系统服务就是提供了一个通过descriptor获取服务的接口), 首先我们要知道服务的全名, 在Intent中设定服务全名, 并指定一个ServiceConnection回调, 调用<code>bindService(Intent, ServiceConnection, CONTEXT_OPTION)</code>绑定服务(其中第三个参数的含义稍后解释), 在<code>ServiceConnection</code>中获取到服务实例. 我们已经知道<code>ServiceConnection</code>的回调方法被调用时已经得到了服务实例, 下面我们看看<code>bindService</code>如何绑定服务获取服务实例.  </p>
<p><code>bindService</code>方法的定义来自于<code>Context</code>, <code>Activity</code>的<code>bindService</code>调用的是<code>ContextWrapper.bindService</code>, 其默认实现是调用<code>mBase.bindService</code>, <code>mBase</code>是一个Context类型的成员变量, 这里的mBase是一个ContextImpl实例变量. 在<code>ContextImpl.java</code>中, bindService是这么定义的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class ContextImpl extends Context &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    public boolean bindService(Intent service, ServiceConnection conn,  </div><div class="line">            int flags) &#123;  </div><div class="line">        IServiceConnection sd;  </div><div class="line">        if (mPackageInfo != null) &#123;  </div><div class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),  </div><div class="line">                mMainThread.getHandler(), flags);  </div><div class="line">        &#125; else &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">        try &#123;  </div><div class="line">            int res = ActivityManagerNative.getDefault().bindService(  </div><div class="line">                mMainThread.getApplicationThread(), getActivityToken(),  </div><div class="line">                service, service.resolveTypeIfNeeded(getContentResolver()),  </div><div class="line">                sd, flags);  </div><div class="line">            ......  </div><div class="line">            return res != 0;  </div><div class="line">        &#125; catch (RemoteException e) &#123;  </div><div class="line">            return false;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的mMainThread是一个<code>ActivityThread</code>实例, 通过它的<code>getHandler</code>函数可以获得一个Handler对象(这里返回的Handler是在<code>ActivityThread</code>类内部从Handler类继承下来的一个H类实例变量), 有了这个Handler对象后, 就可以把消息分发到<code>ActivityThread</code>所在的线程消息队列中去了.  </p>
<p><div id="LoadedApk.ServiceDispatcher.InnerConnection"></div>获得了这个Handler对象后, 就调用<code>mPackageInfo.getServiceDispatcher</code>函数来获得一个<code>IServiceConnection</code>接口, 这里的<code>mPackageInfo</code>的类型是<code>LoadedApk</code>, 它的<code>getServiceDispatcher</code>函数比较长我就不贴了, 大致上它先以传进来的context为key查找<code>mServices</code>成员中是否已经有对应的<code>ServiceDispatcher</code>, 没有则新建一个, 将传进来的<code>ServiceConnection</code>和Handler都保存在<code>ServiceDispatcher</code>内部, 并创建一个<code>InnerConnection</code>, <font color="red">这是一个Binder对象!</font> 最后返回给sd的就是这个<code>InnerConnection</code>对象.<br>接着调用<code>ActivityManagerNative.getDefault().bindService()</code>, 在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>文件中, 函数定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class ActivityManagerProxy implements IActivityManager  </div><div class="line">&#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    public int bindService(IApplicationThread caller, IBinder token,  </div><div class="line">            Intent service, String resolvedType, IServiceConnection connection,  </div><div class="line">            int flags) throws RemoteException &#123;  </div><div class="line">        Parcel data = Parcel.obtain();  </div><div class="line">        Parcel reply = Parcel.obtain();  </div><div class="line">        data.writeInterfaceToken(IActivityManager.descriptor);  </div><div class="line">        data.writeStrongBinder(caller != null ? caller.asBinder() : null);</div><div class="line">        data.writeStrongBinder(token);  </div><div class="line">        service.writeToParcel(data, 0);  </div><div class="line">        data.writeString(resolvedType);  </div><div class="line">        data.writeStrongBinder(connection.asBinder());// 被调用的服务的Binder作为数据传输给服务端</div><div class="line">        data.writeInt(flags);  </div><div class="line">        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);// 调用了transact, 进Binder驱动</div><div class="line">        reply.readException();  </div><div class="line">        int res = reply.readInt();  </div><div class="line">        data.recycle();  </div><div class="line">        reply.recycle();  </div><div class="line">        return res;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><div id="ActivityManagerService.bindService"></div>这个函数通过Binder驱动程序就进入到<code>ActivityManagerService</code>的<code>bindService</code>函数去了(到此为止, 代码执行就从Binder客户端进入到了Binder服务端), 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>文件中, 代码比较长就不贴了. 主要做了以下这些事:<br>函数首先根据传进来的参数token(是调用者Activity在<code>ActivityManagerService</code>里面的令牌), 将这个代表调用者Activity的<code>ActivityRecord</code>取回来.<br>接着通过<code>retrieveServiceLocked</code>函数, 得到一个<code>ServiceRecord</code>, 这个<code>ServiceReocrd</code>描述的是一个Service对象,这是根据传进来的参数service的内容获得的(service是个Intent, 带有我们要用的具体Service的信息).<br>接着把传进来的connection参数封装成一个<code>ConnectionRecord</code>对象, 并保存了它的一个引用到<code>activity.connections</code>中以方便后续取用.<br>最后, 传进来的第四个参数flags是有限的几种<code>BindServiceFlags</code>中的一种, 它决定了具体行为. 以<code>BIND_AUTO_CREATE</code>为例, 它会走到<code>private final boolean bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean whileRestarting)</code>, 第一个参数就是前面的Intent service, 第二个参数通过<code>service.getFlags()</code>得到, 第三个参数传的false. 该函数中, 首先判断应用进程是否存在, 如果存在则调用<code>realStartServiceLocked(r, app)</code>, app是通过进程名和uid获取到的<code>ProcessRecord</code>(如果不存在则启动新进程, 并将服务压栈等待进程启动完成, 在这个新进程上执行serivce). 来看这个函数实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public final class ActivityManagerService extends ActivityManagerNative  </div><div class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;  </div><div class="line">    ......  </div><div class="line">    private final void realStartServiceLocked(ServiceRecord r,  </div><div class="line">            ProcessRecord app) throws RemoteException &#123;  </div><div class="line">        ......  </div><div class="line">        r.app = app;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        app.services.add(r);  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        try &#123;  </div><div class="line">            ......  </div><div class="line">            app.thread.scheduleCreateService(r, r.serviceInfo);  </div><div class="line">            ......  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        requestServiceBindingsLocked(r);  </div><div class="line">  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数执行了两个操作, 一个是<code>app.thread.scheduleCreateService(r, r.serviceInfo)</code>在应用程序进程内部创建Service, 这个操作会导致Service的<code>onCreate</code>被调用; 另一个操作是调用<code>requestServiceBindingsLocked</code>函数向服务获取一个Binder对象, 这个操作会导致Service的<code>onBind</code>函数被调用. 可能有读者觉得有点偏题了, 实际不然, 这两个操作都依赖Binder机制. 先来看前者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class ApplicationThreadProxy implements IApplicationThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    public final void scheduleCreateService(IBinder token, ServiceInfo info)  </div><div class="line">            throws RemoteException &#123;  </div><div class="line">        Parcel data = Parcel.obtain();  </div><div class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);  </div><div class="line">        data.writeStrongBinder(token);  </div><div class="line">        info.writeToParcel(data, 0);  </div><div class="line">        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null,  </div><div class="line">            IBinder.FLAG_ONEWAY);// 又一次Binder调用, 进入到的是ApplicationThread.scheduleCreateService, flag引人注目</div><div class="line">        data.recycle();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过Binder驱动程序就进入到<code>ApplicationThread</code>的<code>scheduleCreateService</code>函数去了. 它的定义在<code>frameworks/base/core/java/android/app/ActivityThread.java</code>文件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    private final class ApplicationThread extends ApplicationThreadNative &#123;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        public final void scheduleCreateService(IBinder token,  </div><div class="line">            ServiceInfo info) &#123;  </div><div class="line">            CreateServiceData s = new CreateServiceData();  </div><div class="line">            s.token = token;  </div><div class="line">            s.info = info;  </div><div class="line">  </div><div class="line">            queueOrSendMessage(H.CREATE_SERVICE, s);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>queueOrSendMessage</code>是<code>ActivityThread</code>的方法, 它用Handler把创建服务的操作放到了Activity线程的消息队列中, 在<code>handleMessage</code>时调用<code>handleCreateService</code>处理该消息, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    private final void handleCreateService(CreateServiceData data) &#123;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        LoadedApk packageInfo = getPackageInfoNoCheck(  </div><div class="line">        data.info.applicationInfo);  </div><div class="line">        Service service = null;  </div><div class="line">        try &#123;  </div><div class="line">            java.lang.ClassLoader cl = packageInfo.getClassLoader();  </div><div class="line">            service = (Service) cl.loadClass(data.info.name).newInstance();  // 加载类, 获得实例</div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        try &#123;  </div><div class="line">            ......  </div><div class="line">  </div><div class="line">            ContextImpl context = new ContextImpl();  </div><div class="line">            context.init(packageInfo, null, this);  </div><div class="line">  </div><div class="line">            Application app = packageInfo.makeApplication(false, mInstrumentation);  </div><div class="line">            context.setOuterContext(service);  </div><div class="line">            service.attach(context, this, data.info.name, data.token, app,  </div><div class="line">                ActivityManagerNative.getDefault());  // 绑定服务</div><div class="line">  </div><div class="line">            service.onCreate();  // 进入onCreate生命周期</div><div class="line">            mServices.put(data.token, service); // 保存服务映射</div><div class="line">            ......  </div><div class="line">        &#125; catch (Exception e) &#123;  </div><div class="line">            ......  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;  </div><div class="line">```  </div><div class="line">至此, 服务实例就创建出来了. 下面回到`realStartServiceLocked`看`requestServiceBindingsLocked`, 它的定义在`frameworks/base/services/java/com/android/server/am/ActivityManagerService.java`中:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityManagerService extends ActivityManagerNative<br>        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {<br>    ……  </p>
<pre><code>private final void requestServiceBindingsLocked(ServiceRecord r) {  
    Iterator&lt;IntentBindRecord&gt; bindings = r.bindings.values().iterator();  
    while (bindings.hasNext()) {  
        IntentBindRecord i = bindings.next();  
        if (!requestServiceBindingLocked(r, i, false)) {  
            break;  
        }  
    }  
}  

private final boolean requestServiceBindingLocked(ServiceRecord r,  
        IntentBindRecord i, boolean rebind) {  
    ......  
    if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) {  
      try {  
          ......  
          r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);  
          ......  
      } catch (RemoteException e) {  
          ......  
      }  
    }  
    return true;  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(下回分解)  </div><div class="line">1月9日, 继续分解Service启动过程.  </div><div class="line">前面说到经过`handleCreateService`之后, `Service`实例就通过ClassLoader载入到内存, 并通过newInstance创建了实例, 且进入到`onCreate`周期. 创建完毕后, 接着调用`requestServiceBindingsLocked`, 这个方法从名字看应该是要绑定服务了, 打开源码发现它实际调用了`app.thread.scheduleBindService`, 传的参数`ServiceRecord r`代表我们启动的自定义服务. `app.thread`是一个Binder对象的远程接口, 它的类型是`ApplicationThreadProxy`, 这一点从前面也看得出来. 通过代理和Binder驱动, 我们就进入到`ApplicationThread`的`scheduleBindService`中了:</div></pre></td></tr></table></figure></p>
<p>class ApplicationThreadProxy implements IApplicationThread {<br>    ……  </p>
<pre><code>public final void scheduleBindService(IBinder token, Intent intent, boolean rebind)  throws RemoteException {  
    Parcel data = Parcel.obtain();  
    data.writeInterfaceToken(IApplicationThread.descriptor);  
    data.writeStrongBinder(token);  
    intent.writeToParcel(data, 0);  
    data.writeInt(rebind ? 1 : 0);  
    mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, null,  
        IBinder.FLAG_ONEWAY);  
    data.recycle();  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">那么, 我们来看看`ApplicationThread`中`scheduleBindService`是怎么实现的:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityThread {<br>    ……  </p>
<pre><code>public final void scheduleBindService(IBinder token, Intent intent,  
        boolean rebind) {  
    BindServiceData s = new BindServiceData();  
    s.token = token;  
    s.intent = intent;  
    s.rebind = rebind;  

    queueOrSendMessage(H.BIND_SERVICE, s);  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">很眼熟对不对? 相信不用我说你也知道之后是什么了:</div></pre></td></tr></table></figure></p>
<p>switch (msg.what) {<br>……<br>case BIND_SERVICE:<br>    handleBindService((BindServiceData)msg.obj);<br>    break;<br>……<br>}  </p>
<p>…<br>private final void handleBindService(BindServiceData data) {<br>    Service s = mServices.get(data.token);<br>    if (s != null) {<br>        try {<br>            data.intent.setExtrasClassLoader(s.getClassLoader());<br>            try {<br>                if (!data.rebind) {<br>                    IBinder binder = s.onBind(data.intent);<br>                    ActivityManagerNative.getDefault().publishService(<br>                        data.token, data.intent, binder);<br>                } else {<br>                    ……<br>                }<br>                ……<br>            } catch (RemoteException ex) {<br>            }<br>        } catch (Exception e) {<br>            ……<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;Service.onBind&quot;&gt;&lt;/div&gt;首先将前面保存在`mServices`中的服务通过`data.token`取出来放到本地变量, 然后让它执行`onBind`获得一个Binder对象, 接着将这个对象传递给`ActivityManagerService.getDefa().publishService()`. `onBind`是自定义服务自己重写的, 就是返回一个实现了IBinder接口的Binder对象. `publishSerivce` 定义在`frameworks/base/core/java/android/app/ActivityManagerNative.java`中, 如下:</div></pre></td></tr></table></figure></p>
<p>class ActivityManagerProxy implements IActivityManager<br>{<br>    ……<br>    public void publishService(IBinder token,<br>    Intent intent, IBinder service) throws RemoteException {<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        data.writeInterfaceToken(IActivityManager.descriptor);<br>        data.writeStrongBinder(token);<br>        intent.writeToParcel(data, 0);<br>        data.writeStrongBinder(service);<br>        mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0);// 眼熟不?<br>        reply.readException();<br>        data.recycle();<br>        reply.recycle();<br>    }<br>    ……<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">再来看`publishService`的实现, 理所当然它的定义在`frameworks/base/services/java/com/android/server/am/ActivityManagerService.java`中:</div></pre></td></tr></table></figure></p>
<p>public final class ActivityManagerService extends ActivityManagerNative<br>        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {<br>    ……  </p>
<pre><code>public void publishService(IBinder token, Intent intent, IBinder service) {  
    ......  
    synchronized(this) {  
        ......  
        ServiceRecord r = (ServiceRecord)token;  
        ......  

        ......  
        if (r != null) {  
            Intent.FilterComparison filter  
                = new Intent.FilterComparison(intent);  
            IntentBindRecord b = r.bindings.get(filter);  
            if (b != null &amp;&amp; !b.received) {  
                b.binder = service;  
                b.requested = true;  
                b.received = true;  
                if (r.connections.size() &gt; 0) {  
                    Iterator&lt;ArrayList&lt;ConnectionRecord&gt;&gt; it  
                        = r.connections.values().iterator();  
                    while (it.hasNext()) {  
                        ArrayList&lt;ConnectionRecord&gt; clist = it.next();  
                        for (int i=0; i&lt;clist.size(); i++) {  
                            ConnectionRecord c = clist.get(i);  
                            ......  
                            try {  
                                c.conn.connected(r.name, service);  
                            } catch (Exception e) {  
                                ......  
                            }  
                        }  
                    }  
                }  
            }  

            ......  
        }  
    }  
}  

......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这里传进来的service不出意外的话就是我们自定义`onBinder`返回的那个东西了, 也就是我们自定义服务的实例. 这里的`token`是一个`ServiceRecord`对象, 是在前面[bindService](#ActivityManagerService.bindService)中中创建的. 在那里, 我们保存了自定义服务的一个`ConnectionRecord`在这个`ServiceRecord.connections`列表中, 因此这里可以通过`r.connections`取出那个`ConnectionRecord`.  </div><div class="line">取出`ConnectionRecord`之后, 调用成员变量的函数`conn.connected()`. 这个conn是一个`IServiceConnection`类型, 它是一个Binder对象的远程接口, 这个Binder对象, 就是我们在[前面](#LoadedApk.ServiceDispatcher.InnerConnection)创建的`LoadedApk.ServiceDispatcher.InnerConnection`对象. 因此, 这里的`connected`就到了`InnerConnection.connected`:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/java/android/app/LoadedApk.java<br>final class LoadedApk {<br>    ……  </p>
<pre><code>static final class ServiceDispatcher {  
    ......  

    private static class InnerConnection extends IServiceConnection.Stub {  
        ......  

        public void connected(ComponentName name, IBinder service) throws RemoteException {  
            LoadedApk.ServiceDispatcher sd = mDispatcher.get();  
            if (sd != null) {  
                sd.connected(name, service);  // 转到了外层ServiceDispatcher类中的connected
            }  
        }  
        ......  
    }  
    ......  

    public void connected(ComponentName name, IBinder service) {  
        if (mActivityThread != null) {  
            mActivityThread.post(new RunConnection(name, service, 0)); // 放到ActivityThread的消息队列中. mActivityThread是一个Handler实例  
        } else {  
            ......  
        }  
    }  
    ......  

    private final class RunConnection implements Runnable {  
        ......  

        public void run() {  
            if (mCommand == 0) {  
                doConnected(mName, mService);  
            } else if (mCommand == 1) {  
                ......  
            }  
        }  
        ......  
    }  
    ......  

    public void doConnected(ComponentName name, IBinder service) {  
        ......  

        // If there is a new service, it is now connected.  
        if (service != null) {  
            mConnection.onServiceConnected(name, service);  
        }  
    }  
}  
......  
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">新建了一个`RunConnection`并调用`H.post`放到了`ActivityThread`的消息队列中. 当处理该消息时, 会运行的`RunConnection`的`run()`来处理, 原因见我另一篇文章[Handler原理](./handler.md). 此时`mCommand==0`, 最后就会执行到`mConnection.onServiceConnected`函数. 这里的`mConnection`的类型是`ServiceConnection`, 它是在[前面](#ActivityManagerService.bindService)设置好的, 它是我们调用`bindService`时传入的`ServiceConnection`实例, 在前面我们用它通过`ServiceDispatcher`换得了一个`IServiceConnection`对象.   </div><div class="line">传入的第二个参数`service`是一个IBinder对象, 它其实就是我们[前面](#Service.onBind)从自定义Service中得到的自定义Binder对象, 因此这里我们可以直接强转成那个自定义Binder类型, 并通过它的`getService`接口获取到自定义服务的接口. 至此, 我们经过`onServiceConnection`, 调用`getService`, 绑定并获取了自定义服务.  </div><div class="line"></div><div class="line">### Binder驱动的实现</div><div class="line">上面多次提到&quot;进入了Binder驱动&quot;, 可见Binder驱动在这个设计中具有重要的桥梁作用. 那么除了上面看到的那些, Binder驱动到底是什么样子呢? 接下来让我们深入Binder驱动源码.  </div><div class="line">首先我们要知道是哪里进入到Native Binder驱动的:  </div><div class="line">`IYourService.Stub.Proxy.YOUR_API()`中, 调用`android.os.IBinder(实现在 android.os.Binder.BinderProxy).transact()`发送`Stub.TRANSACTION_YOUR_API` ==&gt; **`BinderProxy.transact()`进入Native层** ==&gt; 由jni转到`android_os_BinderProxy_transact()`函数 ==&gt; 调用`IBinder-&gt;transact`函数.  </div><div class="line"></div><div class="line">#### 调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()</div><div class="line">直到jni为止的内容我们前面已经了解过了, 下面来看`android_os_BinderProxy_transact()`函数:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/jni/android_util_Binder.cpp</p>
<p>……</p>
<p>static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,<br>        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException<br>{<br>    // check and parse data<br>    ……</p>
<pre><code>IBinder* target = (IBinder*)
    env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);// 获取mObject指向的本地对象

status_t err = target-&gt;transact(code, *data, reply, flags);// 调用本地代码的transact

if (err == NO_ERROR) {
    return JNI_TRUE;
} else if (err == UNKNOWN_TRANSACTION) {
    return JNI_FALSE;
}

signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize());
return JNI_FALSE;
</code></pre><p>}<br>……</p>
<p>static const JNINativeMethod gBinderProxyMethods[] = {<br>     /<em> name, signature, funcPtr </em>/<br>    {“pingBinder”,          “()Z”, (void<em>)android_os_BinderProxy_pingBinder},<br>    {“isBinderAlive”,       “()Z”, (void</em>)android_os_BinderProxy_isBinderAlive},<br>    {“getInterfaceDescriptor”, “()Ljava/lang/String;”, (void<em>)android_os_BinderProxy_getInterfaceDescriptor},<br>    {“transactNative”,      “(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z”, (void</em>)android_os_BinderProxy_transact},<br>    {“linkToDeath”,         “(Landroid/os/IBinder$DeathRecipient;I)V”, (void<em>)android_os_BinderProxy_linkToDeath},<br>    {“unlinkToDeath”,       “(Landroid/os/IBinder$DeathRecipient;I)Z”, (void</em>)android_os_BinderProxy_unlinkToDeath},<br>    {“destroy”,             “()V”, (void*)android_os_BinderProxy_destroy},<br>};<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其中, `gBinderProxyOffsets.mObject`是在Java层调用`IBinder.getContextObject()`时, 在`javaObjectForIBinder`函数中设置的:</div></pre></td></tr></table></figure>
<p>// in file frameworks/base/core/jni/android_util_Binder.cpp<br>……</p>
<p>static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)<br>{<br>    sp<ibinder> b = ProcessState::self()-&gt;getContextObject(NULL);<br>    return javaObjectForIBinder(env, b);<br>}</ibinder></p>
<p>jobject javaObjectForIBinder(JNIEnv<em> env, const sp<ibinder>&amp; val)<br>{<br>    …<br>    LOGDEATH(“objectForBinder %p: created new proxy %p !\n”, val.get(), object);<br>    // The proxy holds a reference to the native object.<br>    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());// 设置本地IBinder对象, 令mObject指向它<br>    val-&gt;incStrong((void</ibinder></em>)javaObjectForIBinder);<br>    …<br>}</p>
<p>…..</p>
<p>########################################################################</p>
<p>// in file frameworks/native/libs/binder/ProcessState.cpp<br>……</p>
<p>sp<ibinder> ProcessState::getContextObject(const sp<ibinder>&amp; /<em>caller</em>/)<br>{<br>    return getStrongProxyForHandle(0);<br>}</ibinder></ibinder></p>
<p>sp<ibinder> ProcessState::getStrongProxyForHandle(int32_t handle)<br>{<br>    sp<ibinder> result;<br>    …<br>    b = new BpBinder(handle);<br>    result = b;<br>    …<br>    return result;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">可见, `android_os_BinderProxy_transact()`函数实际上调用的是 `BpBinder::transact()` 函数.  </div><div class="line"></div><div class="line">#### jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState</div><div class="line">来看看`BpBinder::transact()`, 它位于`frameworks/native/libs/binder/BpBinder.cpp`:</div></pre></td></tr></table></figure></ibinder></ibinder></p>
<p>status_t BpBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    // Once a binder has died, it will never come back to life.<br>    if (mAlive) {<br>        status_t status = IPCThreadState::self()-&gt;transact(<br>            mHandle, code, data, reply, flags);// 调用IPCThreadState::self()-&gt;transact<br>        if (status == DEAD_OBJECT) mAlive = 0;<br>        return status;<br>    }</p>
<pre><code>return DEAD_OBJECT;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`IPCThreadState`中是这么写的:</div></pre></td></tr></table></figure></p>
<p>status_t IPCThreadState::transact(int32_t handle,<br>                                  uint32_t code, const Parcel&amp; data,<br>                                  Parcel* reply, uint32_t flags)<br>{<br>    status_t err = data.errorCheck();</p>
<pre><code>flags |= TF_ACCEPT_FDS;

if (err == NO_ERROR) {
    LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),
        (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);
    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
}

if ((flags &amp; TF_ONE_WAY) == 0) {
    if (reply) {
        err = waitForResponse(reply);
    } else {
        Parcel fakeReply;
        err = waitForResponse(&amp;fakeReply);
    }
} else {
    err = waitForResponse(NULL, NULL);
}

return err;
</code></pre><p>}</p>
<p>status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,<br>    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)<br>{<br>    binder_transaction_data tr;</p>
<pre><code>tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */
tr.target.handle = handle;
tr.code = code;
...

mOut.writeInt32(cmd);
mOut.write(&amp;tr, sizeof(tr));

return NO_ERROR;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">由函数内容可以看出, 数据再一次通过 `writeTransactionData()` 传递给 `mOut` 进行写入操作. `mOut` 是一个 `Parcel` 对象, 声明在 `IPCThreadState.h` 文件中. 之后则调用 `waitForResponse()` 函数.</div><div class="line"></div><div class="line">#### IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回</div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/IPCThreadState.cpp<br>……</p>
<p>status_t IPCThreadState::waitForResponse(Parcel <em>reply, status_t </em>acquireResult)<br>{<br>    int32_t cmd;<br>    int32_t err;</p>
<pre><code>while (1) { // 永真循环
    if ((err=talkWithDriver()) &lt; NO_ERROR) break; // 调用talkWithDriver, 当返回负时退出循环
    err = mIn.errorCheck();
    if (err &lt; NO_ERROR) break;
    if (mIn.dataAvail() == 0) continue;

    cmd = mIn.readInt32(); // 读取命令

    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;
            &lt;&lt; getReturnString(cmd) &lt;&lt; endl;
    }

    switch (cmd) {
    case BR_TRANSACTION_COMPLETE:
        if (!reply &amp;&amp; !acquireResult) goto finish;
        break;

    case BR_DEAD_REPLY:
        err = DEAD_OBJECT;
        goto finish;

    case BR_FAILED_REPLY:
        err = FAILED_TRANSACTION;
        goto finish;

    case BR_ACQUIRE_RESULT:
        {
            LOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);
            const int32_t result = mIn.readInt32();
            if (!acquireResult) continue;
            *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
        }
        goto finish;

    case BR_REPLY:
        {
            binder_transaction_data tr;
            err = mIn.read(&amp;tr, sizeof(tr));// 读取远端返回的数据
            LOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);
            if (err != NO_ERROR) goto finish;

            if (reply) {
                if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                    reply-&gt;ipcSetDataReference(
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t),
                        freeBuffer, this);
                } else {
                    err = *static_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);
                    freeBuffer(NULL,
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t), this);
                }
            } else {
                freeBuffer(NULL,
                    reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                    tr.data_size,
                    reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                    tr.offsets_size/sizeof(size_t), this);
                continue;
            }
        }
        goto finish;

    default:
        err = executeCommand(cmd); // 处理其他命令, 例如NO_ERROR
        if (err != NO_ERROR) goto finish;
        break;
    }
}
</code></pre><p>finish:<br>    if (err != NO_ERROR) {<br>        if (acquireResult) *acquireResult = err;<br>        if (reply) reply-&gt;setError(err);<br>        mLastError = err;<br>    }</p>
<pre><code>return err;
</code></pre><p>}<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;talkWithDriver&quot;&gt;&lt;/div&gt;</div><div class="line">#### IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现</div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure></p>
<p>……</p>
<p>status_t IPCThreadState::talkWithDriver(bool doReceive)<br>{<br>    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= 0, “Binder driver is not opened”);</p>
<pre><code>binder_write_read bwr;

// Is the read buffer empty?
const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();

// We don&apos;t want to write anything if we are still reading
// from data left in the input buffer and the caller
// has requested to read the next data.
const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

// 写入数据
bwr.write_size = outAvail;
bwr.write_buffer = (long unsigned int)mOut.data();

// This is what we&apos;ll read.
// 读取数据
if (doReceive &amp;&amp; needRead) {
    bwr.read_size = mIn.dataCapacity();
    bwr.read_buffer = (long unsigned int)mIn.data();
} else {
    bwr.read_size = 0;
}

IF_LOG_COMMANDS() {
    TextOutput::Bundle _b(alog);
    if (outAvail != 0) {
        alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;
        const void* cmds = (const void*)bwr.write_buffer;
        const void* end = ((const uint8_t*)cmds)+bwr.write_size;
        alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;
        while (cmds &lt; end) cmds = printCommand(alog, cmds);
        alog &lt;&lt; dedent;
    }
    alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size
        &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;
}

// Return immediately if there is nothing to do.
if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

bwr.write_consumed = 0;
bwr.read_consumed = 0;
status_t err;
do {
    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
    }
</code></pre><p>#if defined(HAVE_ANDROID_OS)<br>        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令<br>        // 该过程在下一节详述<br>        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)<br>            err = NO_ERROR;<br>        else<br>            err = -errno;</p>
<p>#else<br>        err = INVALID_OPERATION;</p>
<p>#endif<br>        IF_LOG_COMMANDS() {<br>            alog &lt;&lt; “Finished read/write, write size = “ &lt;&lt; mOut.dataSize() &lt;&lt; endl;<br>        }<br>    } while (err == -EINTR);</p>
<pre><code>IF_LOG_COMMANDS() {
    alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)err &lt;&lt; &quot;, write consumed: &quot;
        &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()
        &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;
}

if (err &gt;= NO_ERROR) {
    if (bwr.write_consumed &gt; 0) {
        if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
            mOut.remove(0, bwr.write_consumed);
        else
            mOut.setDataSize(0);
    }
    if (bwr.read_consumed &gt; 0) {
        mIn.setDataSize(bwr.read_consumed);
        mIn.setDataPosition(0);
    }
    IF_LOG_COMMANDS() {
        TextOutput::Bundle _b(alog);
        alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;
        const void* cmds = mIn.data();
        const void* end = mIn.data() + mIn.dataSize();
        alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;
        while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);
        alog &lt;&lt; dedent;
    }
    return NO_ERROR;
}

return err;
</code></pre><p>}<br>……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">`ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)` 就是使用系统调用函数 `ioctl` 向 `binder` 设备文件 `/dev/binder` 发送 `BINDER_WRITE_READ` 命令.  </div><div class="line">回到上一步`waitForResponse`, 获取到`talkWithDriver`返回的命令`cmd`后默认执行`executeCommand(cmd)`, 来处理返回命令  </div><div class="line"></div><div class="line">#### IPCThreadState::executeCommand(int32_t cmd) 处理返回命令</div><div class="line">除了在switch case中处理的命令以外, 其他的命令都通过调用`executeCommand`来处理, 它的实现如下:  </div><div class="line">&lt;!-- 此处插代码 --&gt;</div></pre></td></tr></table></figure>
<p>……</p>
<p>status_t IPCThreadState::executeCommand(int32_t cmd)<br>{<br>    BBinder<em> obj;<br>    RefBase::weakref_type</em> refs;<br>    status_t result = NO_ERROR;</p>
<pre><code>switch (cmd) {
// switch能处理的命令很多, 我们省略掉其他命令, 重点看正常数据处理
...
case BR_TRANSACTION:
    {
        binder_transaction_data tr;
        result = mIn.read(&amp;tr, sizeof(tr));
        LOG_ASSERT(result == NO_ERROR,
            &quot;Not enough command data for brTRANSACTION&quot;);
        if (result != NO_ERROR) break;

        Parcel buffer;
        buffer.ipcSetDataReference(
            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
            tr.data_size,
            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
            tr.offsets_size/sizeof(size_t), freeBuffer, this);

        // 判断和设置优先级
        ...

        Parcel reply;
        if (tr.target.ptr) {
            sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
            const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);// 实际执行的是 BBinder.transact() !
            if (error &lt; NO_ERROR) reply.setError(error);

        } else {
            const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
            if (error &lt; NO_ERROR) reply.setError(error);
        }

        if ((tr.flags &amp; TF_ONE_WAY) == 0) {
            LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);
            sendReply(reply, 0);
        } else {
            LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);
        }
        ...
    }
    break;
...
return result;
</code></pre><p>}<br>……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可见它调用了`BBinder::transact()`来处理数据, 该函数定义如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/Binder.cpp<br>status_t BBinder::transact(<br>    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)<br>{<br>    data.setDataPosition(0);</p>
<pre><code>status_t err = NO_ERROR;
switch (code) {
    case PING_TRANSACTION:
        reply-&gt;writeInt32(pingBinder());
        break;
    default:
        err = onTransact(code, data, reply, flags);// 调用onTransact
        break;
}

if (reply != NULL) {
    reply-&gt;setDataPosition(0);
}

return err;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在此处`b-&gt;transact`调用时, `b`是一个`JavaBBinder`实例, `JavaBBinder`继承了`BBinder`类, 重写了`onTransact`, 所以这里实际调用的是`JavaBBinder.onTransact`, 定义见`frameworks/base/core/jni/android_util_Binder.cpp`:</div></pre></td></tr></table></figure></p>
<p>virtual status_t onTransact(<br>    uint32_t code, const Parcel&amp; data, Parcel<em> reply, uint32_t flags = 0)<br>{<br>    JNIEnv</em> env = javavm_to_jnienv(mVM);<br>    …<br>    jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,<br>        code, (int32_t)&amp;data, (int32_t)reply, flags);// 调用gBinderOffsets.mExecTransact<br>    …<br>    return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;<br>}</p>
<p>static int int_register_android_os_Binder(JNIEnv* env)<br>{<br>    jclass clazz;</p>
<pre><code>clazz = env-&gt;FindClass(kBinderPathName);
LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Binder&quot;);
...
gBinderOffsets.mExecTransact
    = env-&gt;GetMethodID(clazz, &quot;execTransact&quot;, &quot;(IIII)Z&quot;);
...
return AndroidRuntime::registerNativeMethods(
    env, kBinderPathName,
    gBinderMethods, NELEM(gBinderMethods));
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由上可见, `JavaBBinder`通过JNI的`gBinderOffsets.mExecTransact`调用java方法`android.os.Binder.execTransact`. 执行的实际上是`android.os.Binder.onTransact`. 它的实现如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/core/java/android/os/Binder.java</p>
<p>// Entry point from android_util_Binder.cpp’s onTransact<br>private boolean execTransact(int code, int dataObj, int replyObj,<br>        int flags) {<br>    Parcel data = Parcel.obtain(dataObj);<br>    Parcel reply = Parcel.obtain(replyObj);<br>    // theoretically, we should call transact, which will call onTransact,<br>    // but all that does is rewind it, and we just got these from an IPC,<br>    // so we’ll just call it directly.<br>    boolean res;<br>    try {<br>        res = onTransact(code, data, reply, flags);<br>    }<br>    // catch clauses<br>    …<br>    reply.recycle();<br>    data.recycle();<br>    return res;<br>}</p>
<p>protected boolean onTransact(int code, Parcel data, Parcel reply,<br>       int flags) throws RemoteException {<br>   if (code == INTERFACE_TRANSACTION) {<br>       reply.writeString(getInterfaceDescriptor());<br>       return true;<br>   } else if (code == DUMP_TRANSACTION) {<br>       ParcelFileDescriptor fd = data.readFileDescriptor();<br>       String[] args = data.readStringArray();<br>       if (fd != null) {<br>           try {<br>               dump(fd.getFileDescriptor(), args);<br>           } finally {<br>               try {<br>                   fd.close();<br>               } catch (IOException e) {<br>                   // swallowed, not propagated back to the caller<br>               }<br>           }<br>       }<br>       // Write the StrictMode header.<br>       if (reply != null) {<br>           reply.writeNoException();<br>       } else {<br>           StrictMode.clearGatheredViolations();<br>       }<br>       return true;<br>   }<br>   return false;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">由此可见, 经过Binder驱动之后, 最终会在服务端进程的`android.os.Binder.onTransact`处理命令和数据. 而我们在服务端的`IYourService.Stub`中, 重写了`onTransact`来调用服务接口的服务端实现(大多数情况下, 这个重写是aidl工具帮你完成的). 至此, Binder驱动下的IPC通讯过程已全部明了(除了中间处理进程状态的过程以及打开Binder设备文件进行数据读写的过程以外).  </div><div class="line"></div><div class="line">一句话总结就是: 客户端发送`BC_TRANSACTION`命令到Binder驱动-&gt;服务端进程监听`BR_TRANSACTION`命令并处理;如果是服务端返回数据, 过程类似, 但发送的命令是`BC_REPLY`命令-&gt;客户端监听`BR_REPLY`命令  </div><div class="line"></div><div class="line">#### Binder设备驱动实现</div><div class="line">在[上一节中](#talkWithDriver), 我们只简单提了一下`ioctl`系统调用是对`/dev/binder`设备文件进行读写操作, 这一节详述该过程.  </div><div class="line"></div><div class="line">首先, `ioctl`第一个参数`mProcess-&gt;mDriverFD`是Binder驱动的文件描述符(File Descriptor), 它是在`ProcessState`初始化时由函数`open_driver()`初始化的, `open_driver`代码如下:</div></pre></td></tr></table></figure></p>
<p>// in file frameworks/base/libs/binder/ProcessState.cpp<br>static int open_driver()<br>{<br>    int fd = open(“/dev/binder”, O_RDWR);<br>    if (fd &gt;= 0) {<br>        fcntl(fd, F_SETFD, FD_CLOEXEC);<br>        int vers;<br>        // 获取驱动版本<br>        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);<br>        if (result == -1) {<br>            LOGE(“Binder ioctl to obtain version failed: %s”, strerror(errno));<br>            close(fd);<br>            fd = -1;<br>        }<br>        // 检查驱动版本是否一致<br>        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {<br>            LOGE(“Binder driver protocol does not match user space protocol!”);<br>            close(fd);<br>            fd = -1;<br>        }<br>        // 设置最多15个线程<br>        size_t maxThreads = 15;<br>        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);<br>        if (result == -1) {<br>            LOGE(“Binder ioctl to set max threads failed: %s”, strerror(errno));<br>        }<br>    } else {<br>        LOGW(“Opening ‘/dev/binder’ failed: %s\n”, strerror(errno));<br>    }<br>    return fd;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">初始化后文件描述符保存在`mDriverFD`中, 以后通过它就可以和设备文件交互.  </div><div class="line"></div><div class="line">其次, 在经过`ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)`调用后, 对设备驱动文件的读写操作就被完全封装在了结构体`binder_write_read`中. 具体的读写过程见[talkWithDriver的实现代码](#talkWithDriver)及我的注释.  </div><div class="line">可见, 真正的数据读写都是通过`/dev/binder`来执行的, 其上封了命令`BINDER_WRITE_READ`用一个数据结构`binder_write_read`来存储读取和写入的数据, 再上封了`transact`处理不同逻辑概念下的事务. 再上通过`BBinder`接口联系到JNI代码和Java代码.  </div><div class="line"></div><div class="line">[深入分析Android Binder 驱动]: http://blog.csdn.net/yangwen123/article/details/9316987  </div><div class="line">最后, 让我们看看`/dev/binder`这个驱动程序的实现. 它是Binder的最终实现.  </div><div class="line">在看驱动代码前, 我们需要了解一些背景知识. 作为一个特殊的字符型设备, Binder的挂载节点是`/dev/binder`, 遵循Linux设备驱动模型, 在驱动实现过程中主要通过`binder_ioctl`函数与用户空间的进程交换数据. Android中的Service都是通过它来完成IPC的, 具体来说, 在Android虚拟机启动前, 系统会先启动`ServiceManager`进程, 它负责打开Binder驱动程序, 并告诉驱动程序自己将作为系统服务的管理者(通过特殊命令`BINDER_SET_CONTEXT_MGR`, 此后`ServiceManager`也通过Binder驱动与其他进程进行通讯), 然后`ServiceManager`进入循环, 等待处理来自其他进程的数据.  </div><div class="line">在Android系统中共有三种IPC机制:  </div><div class="line">- 标准Linux Kernel IPC 接口  </div><div class="line">- 标准D-BUS 接口  </div><div class="line">- Binder接口  </div><div class="line"></div><div class="line">由于我没有了解过其他两种方式, 所以这里我就不评价孰优孰劣了, 在Android系统中大部分程序都使用了Binder接口. Binder是OpenBinder的精简实现, 包含一个Binder驱动程序, 一个Binder服务器, 一个Binder客户端.  </div><div class="line"></div><div class="line">清楚了以上背景之后, 让我们看一下Binder驱动程序的实现. Android中Binder协议的定义在头文件`binder.h`中, 不同版本源码的路径不太一样, 4.0的路径在`external/kernel-headers/original/linux/binder.h`, 定义了五种Binder类型(`bhd`分别表示`binder` `handle` `FD`三个大类):</div></pre></td></tr></table></figure></p>
<p>enum {<br>    BINDER_TYPE_BINDER    = B_PACK_CHARS(‘s’, ‘b’, ‘<em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(‘w’, ‘b’, ‘</em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_HANDLE    = B_PACK_CHARS(‘s’, ‘h’, ‘<em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(‘w’, ‘h’, ‘</em>‘, B_TYPE_LARGE),<br>    BINDER_TYPE_FD        = B_PACK_CHARS(‘f’, ‘d’, ‘*’, B_TYPE_LARGE),<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同样是在这个头文件中, 定义了用于进程间传输的数据结构, 称作Binder Object, 它是一个`flat_binder_object`结构体, 定义如下(为方便理解我把注释也放上来了):</div></pre></td></tr></table></figure></p>
<p>/*</p>
<ul>
<li>This is the flattened representation of a Binder object for transfer</li>
<li>between processes.  The ‘offsets’ supplied as part of a binder transaction</li>
<li>contains offsets into the data where these structures occur.  The Binder</li>
<li>driver takes care of re-writing the structure type and data as it moves</li>
<li><p>between processes.<br><em>/<br>struct flat_binder_object {<br> /</em> 8 bytes for large_flat_header. */<br> unsigned long        type;// Binder对象类型, 即前面Binder协议中五种类型的一种<br> unsigned long        flags;// 传输方式, 见下面transaction_flags</p>
<p> /<em> 8 bytes of data. </em>/<br> union {</p>
<pre><code>void        *binder;    /* local object */
signed long    handle;        /* remote object */
</code></pre><p> };</p>
<p> /<em> extra data associated with local object </em>/<br> void            *cookie;<br>};</p>
</li>
</ul>
<p>…<br>enum transaction_flags {<br>    TF_ONE_WAY    = 0x01,    /<em> this is a one-way call: async, no return </em>/<br>    TF_ROOT_OBJECT    = 0x04,    /<em> contents are the component’s root object </em>/<br>    TF_STATUS_CODE    = 0x08,    /<em> contents are a 32-bit status code </em>/<br>    TF_ACCEPT_FDS    = 0x10,    /<em> allow replies with file descriptors </em>/<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">从注释可以知道, `flat_binder_object`中的union结构存的就是要传输的数据, 当类型为`Binder`时, 数据是一个本地对象`*binder`, 当类型为`Handle`时, 数据是一个远程对象`handle`. Binder对象在进程间传递时, Binder驱动会修改它的类型和数据.  </div><div class="line">正如Binder的客户端和服务端是相对而言的一样, 这里的本地Binder和远程Handle对象也是相对而言的, 其实他们都指向同一个对象, 所以他们共用一个union空间, 只不过A的本地对象binder对于另一进程B来说就是远程对象handle.  </div><div class="line"></div><div class="line">虽然`flat_binder_object`是要传输的Binder对象, 但实际上Binder驱动并不直接操作它, 而是将它封装成了一个`binder_transaction_data`, 操作的直接对象是这个封装的数据. 该封装的定义如下:</div></pre></td></tr></table></figure></p>
<p>struct binder_transaction_data {<br>    /* The first two are only used for bcTRANSACTION and brTRANSACTION,</p>
<pre><code> * identifying the target and contents of the transaction.
 */
union {
    size_t    handle;    /* target descriptor of command transaction */
    void    *ptr;    /* target descriptor of return transaction */
} target;
void        *cookie;    /* target object cookie */
unsigned int    code;        /* transaction command */

/* General information about the transaction. */
unsigned int    flags;
pid_t        sender_pid;
uid_t        sender_euid;
size_t        data_size;    /* number of bytes of data */
size_t        offsets_size;    /* number of bytes of offsets */

/* If this transaction is inline, the data immediately
 * follows here; otherwise, it ends with a pointer to
 * the data buffer.
 */
union {
    struct {
        /* transaction data */
        const void    *buffer;// flat_binder_object被封装在*buffer中
        /* offsets from buffer to flat_binder_object structs */
        const void    *offsets;
    } ptr;
    uint8_t    buf[8];
} data;
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;hr/&gt;</div><div class="line">了解了真正传输的数据结构之后, 让我们来深入Binder生命周期. 以下内容涉及到: Binder设备创建, Binder启动, Binder释放,  Binder数据关联, Binder接口及命令含义. 我尽量从我自己追踪代码的习惯来讲解, 这样虽然效率比较低但是好处是更容易理解和回忆. 以下内容与源码实现紧密关联, 再次声明, 本文基于`Android4.0`源码写就, 不适用于其他版本.  </div><div class="line"></div><div class="line">1. Binder设备创建  </div><div class="line">    作为一个特殊的符号设备, Binder设备也是需要进行创建的. 可以合理猜测系统有一个统一的创建驱动设备的过程, Binder作为其中一个设备一起被创建(如果不对, 就追踪调用栈, 看哪里引用了`frameworks/base/cmds/servicemanager/binder.c`, 特别是调用了里面的`binder_open`). 在这种猜测下, 我们来找一下符号设备的创建(我假设你跟我一样不知道Android下启动过程是否跟Linux一样). 到源码目录搜索`/dev/binder`, 除了前面提到的`ProcessState.open_driver`以外, 在以下三个文件中还出现了`/dev/binder`: `frameworks/base/cmds/servicemanager/binder.c`, `system/core/rootdir/ueventd.rc`, `system/extras/tests/fstest/perm_checker.conf`. 好像没有看出哪个是创建binder设备? 别急, 如果你看过老罗的&lt;[在Ubuntu上为Android系统编写Linux内核驱动程序]&gt;一文, 就可能猜测, 在文件`frameworks/base/cmds/servicemanager/binder.c`中, 有完整的`binder_open` `binder_release` `binder_write`实现, 正好这三个操作是实现Linux设备驱动时需要定义的基本操作的一部分, 这意味着该文件很可能就是Binder设备驱动文件. 我们假设它的确是, 那么应该有设备注册和初始化操作(模块加载, 卸载方法), 但很遗憾搜索之后发现没有. 难道Binder设备不用注册吗? 不是的, 进一步在整个源码范围搜索binder注册函数`binder_init`, 发现它匹配到了`prebuilt/android-arm/kernel/vmlinux-qemu`, 而这个我们知道是预编译好的Linux内核, 看来应该是在Linux内核源码里实现的设备注册, 遗憾的是直接下载Android源码的话是不带内核源码的, 我只好去下载了对应的内核源码(4.0系统对应3.0内核, 2.2系统对应2.6内核, 4.2~4.3系统对应3.4内核). 本文不讲怎么下载Android内核代码, 直接给出相关代码片段:</div></pre></td></tr></table></figure></p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

// 定义文件操作函数
static const struct file_operations binder_fops = {
    .owner = THIS_MODULE,
    .poll = binder_poll,
    .unlocked_ioctl = binder_ioctl,
    .mmap = binder_mmap,
    .open = binder_open,
    .flush = binder_flush,
    .release = binder_release,
};

static struct workqueue_struct *binder_deferred_workqueue;

// 初始化函数
static int __init binder_init(void)
{
    int ret;

    // 创建了一个内核工作队列对象workqueue, 用于执行可以延期执行的工作任务
    binder_deferred_workqueue = create_singlethread_workqueue(&quot;binder&quot;);
    if (!binder_deferred_workqueue)
        return -ENOMEM;

    // 创建调试目录 /sys/kernel/debug/binder
    binder_debugfs_dir_entry_root = debugfs_create_dir(&quot;binder&quot;, NULL);
    if (binder_debugfs_dir_entry_root)
        binder_debugfs_dir_entry_proc = debugfs_create_dir(&quot;proc&quot;,
                         binder_debugfs_dir_entry_root);
    // 注册字符设备
    ret = misc_register(&amp;binder_miscdev);
    // 创建调试文件
    if (binder_debugfs_dir_entry_root) {
        debugfs_create_file(&quot;state&quot;,
                    S_IRUGO,
                    binder_debugfs_dir_entry_root,
                    NULL,
                    &amp;binder_state_fops);
                    ...
    }
    return ret;
}

// 调用初始化函数加载内核, 基本等价于不支持动态编译驱动模块的module_init, 如果需要把Binder改成动态的内核模块, 直接把这个device_initcall改成module_init, 同时添加驱动卸载接口函数 module_exit即可
device_initcall(binder_init);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可见在系统装载设备的时候, 就加载了Binder设备模块, 并绑定了设备操作对应的函数.  </div><div class="line"></div><div class="line">好奇心重一点的读者可能会去自行发掘Linux设备模块怎么编写. Linux驱动程序的一个主要功能就是向用户空间的程序提供操作接口, 这个接口是标准的, Binder包含的接口有:</div></pre></td></tr></table></figure>

-Proc接口（/proc/binder）
    . /proc/binder/state
    . /proc/binder/stats
    . /proc/binder/transactions
    . /proc/binder/transaction_log
    . /proc/binder/failed_transaction_log
    . /proc/binder/proc/

-设备接口（/dev/binder）
    . binder_open
    . binder_release
    . binder_flush
    . binder_mmap
    . binder_poll
    . binder_ioctl
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">2. Binder启动  </div><div class="line">    在`frameworks/base/cmds/servicemanager/binder.c`中定义了binder设备打开的函数`binder_open`:</div></pre></td></tr></table></figure>

struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    if (!bs) {
        errno = ENOMEM;
        return 0;
    }

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (bs-&gt;fd &lt; 0) {
        fprintf(stderr,&quot;binder: cannot open device (%s)\n&quot;,
                strerror(errno));
        goto fail_open;
    }

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);
    if (bs-&gt;mapped == MAP_FAILED) {
        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,
                strerror(errno));
        goto fail_map;
    }

        /* TODO: check version */

    return bs;

fail_map:
    close(bs-&gt;fd);
fail_open:
    free(bs);
    return 0;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个函数作用是把设备映射到内存, 在Binder设备驱动中还有一个同名函数负责打开Binder设备和设置引用计数, 如下:</div></pre></td></tr></table></figure>

// in file kernel/goldfish/drivers/staging/android/binder.c

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    // 初始化, 分配 binder_proc 数据结构内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
        return -ENOMEM;

    // 增加当前线程/进程的引用计数并赋值给proc-&gt;tsk
    get_task_struct(current);
    proc-&gt;tsk = current;
    // 初始化binder_proc队列和默认优先级
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    init_waitqueue_head(&amp;proc-&gt;wait);
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    // 增加 BINDER_STAT_PROC对象计数
    binder_stats_created(BINDER_STAT_PROC);
    // 添加进程节点proc_node到binder_procs的全局列表中, 任何进程都可以访问其他进程的binder_proc对象
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 保存进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 驱动文件的private_data指向proc
    filp-&gt;private_data = proc;

    binder_unlock(__func__);
    ...

    return 0;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. Binder释放  </div><div class="line">    同样是在`frameworks/base/cmds/servicemanager/binder.c`文件中定义了设备释放函数`binder_release`:</div></pre></td></tr></table></figure>

void binder_release(struct binder_state *bs, void *ptr)
{
    uint32_t cmd[2];
    cmd[0] = BC_RELEASE;
    cmd[1] = (uint32_t) ptr;
    binder_write(bs, cmd, sizeof(cmd));
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可见只是发送了一个释放命令给Binder驱动, 那么可以肯定驱动中也有一个释放函数, 正好前面看到过设备操作的接口中有一个就是`binder_release`与这里的函数同名, 不会是巧合. `kernel/goldfish/drivers/staging/android/binder.c`中相关代码片段如下:</div></pre></td></tr></table></figure>

static int binder_release(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc = filp-&gt;private_data;
    debugfs_remove(proc-&gt;debugfs_entry);
    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);

    return 0;
}
```
好嘛, 释放操作给了`binder_defer_work`, 这又是嘛? 其实前面我们在初始化的时候就有内容涉及到它: 在`create_singlethread_workqueue`的时候创建了一个叫做`binder_deferred_workqueue`的队列, 该队列用来调度执行`binder_deferred_work`, 而两者发生联系就是在函数`binder_defer_work`中, `queue_work`使用了他们作为函数参数. 前面说过这个队列里都是可以延期执行的任务, 而`binder_deferred_work`有三种类型, 即枚举变量`binder_deferred_state`中定义的`PUT_FILES` `FLUSH` `RELEASE`.  
显然, 释放的具体操作就要看`queue_work`函数了, 很可惜我查的资料里没有详述这个函数做了啥. 它的定义在`kernel/goldfish/kernel/workqueue.c`中, 粗略看了下, 理解不一定对, 感觉它跟Handler类似, 在入队work的时候获取执行work的worker, 而由别的过程控制出队和实际执行, 只不过它所处的层次更靠近硬件.  
</code></pre><ol>
<li>Binder数据关联<br> 前面说过, 传输对象中<code>binder</code>和<code>handle</code>其实指向的是同一个对象, 现在来解释一下为什么. 在一次调用中, 对于客户端进程来说, handle存储的索引是一个远端对象的句柄, 当数据经由Binder驱动传达到服务端的时候, 服务端就会把这个索引解释为本地对象的地址, 对于第三方来说, 客户端的handle和服务端的binder都是指向了服务端的那个Binder对象. 对于Binder来说, 对象的索引和映射是通过<code>binder_node</code>和<code>binder_ref</code>两个核心数据结构来完成的, 两个定义都可以在文件<code>kernel/goldfish/drivers/staging/android/binder.c</code>中看到. 对于Binder本地对象, 对象的Binder地址保存在<code>binder_node-&gt;ptr</code>里, 对于远程对象, 索引保存在<code>binder_ref-&gt;desc</code>里, 每一个<code>binder_node</code>都有一个<code>binder_ref</code>与之对应, 他们通过<code>ptr</code>和<code>desc</code>来做映射. 前面说过进程间传递的Binder对象实际上是<code>flat_binder_object</code>这个数据结构, 每个<code>flat_binder_object</code>在内核都有一个唯一的<code>binder_node</code>对象与之对应, 这个对象挂载在<code>binder_proc</code>的一棵二叉树上, 而每一个<code>binder_node</code>又有唯一一个<code>binder_ref</code>对象与之对应. 可以这么理解, <code>binder_ref-&gt;desc</code> <code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code> <code>flat_binder_object-&gt;handle</code>四者都指向同一个对象, 其中<code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code>的<code>binder_node</code>位于服务端. <code>binder_ref</code>按照node和desc两种方式映射到<code>binder_proc</code>对象上, 因此可以通过<code>binder_node</code>或者<code>desc</code>查找到<code>binder_ref</code>或<code>binder_node</code>. 对于一个<code>flat_binder_object</code>对象来说, 它的<code>binder, cookie, handle</code>都指向的同一个<code>binder_node</code>对象.<br> Binder驱动中, flush操作在关闭一个设备文件描述符拷贝时被调用, 这里不做探究. 另一个操作mmap(memory map)负责把设备内存映射到用户进程地址空间中, 用户进程可以像操作内存一样操作设备. 一般的设备驱动, 设备内存是设备本身具有的, 或者在驱动初始化时由<code>vmalloc</code>或<code>kmalloc</code>等内核函数分配好, Binder不同于此, 它的设备内存是由mmap操作来分配的, 分配方法是现在内核虚拟映射表上获取一段可用区域, 再分配物理页, 并把物理页映射到获取的虚拟地址区域. 每个进程/线程只能做一次mmap操作, 其后重复操作都会返回错误. mmap分配内存的代码见文件<code>kernel/goldfish/drivers/staging/android/binder.c#binder_mmap</code>片段, 过程大致是先做检查调用合法性等准备工作, 然后申请虚拟内存空间, 再使用<code>binder_update_page_range</code>分配物理空间(实际是分配了1个页的物理内存用来存储指针buffer, 1个物理页是4K, 1个指针是4字节, 所以1页最多可存1K个指针, 每个指针对应一个物理页, 所以对应最多4M物理空间, 这是一次mmap最多可以分配的物理内存量, 这里不管实际申请了多大的物理内存, 内核总是提供1页物理内存用来放buffer指针, 即每次都允许申请最多的物理页), 在该函数中利用Linux系统中内存相关函数完成具体分配任务, 完成后由<code>binder_buffer</code>负责管理该内存区域, <code>binder_buffer</code>放到了<code>proc-&gt;buffers</code>链表中, 今后就可以通过这段内存区域完成设备数据读写了. 更形象的插图见[深入分析Android Binder 驱动]相关章节, 本段主要参考该文和内核代码完成.  </li>
<li>Binder接口及命令<br> Binder能得以正确工作, 首先要依赖于一致的Binder协议. 其中Binder类型在前文<code>external/kernel-headers/original/linux/binder.h</code>中提到过, 一共3大类5小类. 其实该文件中还定义了Binder驱动支持的命令格式和数据定义, 分为客户端的<code>BinderDriverCommandProtocol</code>和服务端的<code>BinderDriverReturnProtocol</code>, 两个都是枚举类型, 很可惜以我现在的C水平, 看不懂枚举成员<code>BC_TRANSACTION = _IOW_BAD(&#39;c&#39;, 0, struct binder_transaction_data)</code>的写法是什么意思, 大概猜测是第一个参数是访问模式, 第二个参数是指令, 第三个参数是数据指针. 客户端命令(BC)中第一个参数都是’c’, 宏<code>_IOR_BAD</code>根据资料应该是指向的<code>ioctl</code>的, 也就是说这里的参数传给了<code>ioctl</code>. 服务端返回(BR)的第一个参数都是’r’, 表示read. 两个数据结构定义了Binder客户端和服务端可以执行的全部命令. 既然有协议, 自然就有版本, 细心的读者可能发现, 前文<code>binder_open</code>函数里面就隐藏了一段注释, 说明以后会有<code>check version</code>的步骤.  </li>
</ol>
<p>本节主要参考:  </p>
<ul>
<li>[深入分析Android Binder 驱动]  </li>
<li><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>  </li>
<li><a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">BinderIPC原理</a>  </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>给两个主要结论和一个图(图不是我画的, 但来源记不得了), 方便大家按图索骥.  </p>
<p><img src="/images/blogs/binder_native_stack.png" alt="binder native stack">  </p>
<ol>
<li><p>Binder的实现从上到下涉及到Java层(Application层)/JNI层/Native层(Runtime层)/Linux kernel层, 可以说涉及到了Android的整个架构, 说是它的核心之一一点不过分. 系统服务的注册/获取/使用/Intent传递都通过Binder驱动, 对它的深入理解将会起到提纲挈领的效果.  </p>
</li>
<li><p>上层的<code>android.os.Binder</code>是对Binder的一层封装, 一般不直接使用. 如果定义服务, 使用系统提供的<code>Service</code>接口即可(它完成了一个默认的<code>android.os.Binder</code>实现), 如果是自定义跨进程服务, 使用<code>AIDL</code>将是更快的方式, 它本质是一个对Binder操作进行封装的工具. 如果不嫌麻烦, 直接使用<code>android.os.Binder</code>来定义客户端和服务端也是完全可行的.  </p>
</li>
</ol>
<p>说实话这篇文章写得有点吃力, 一个是时间拉太长, 记忆跟不上, 另一个是这个内容本身比较难用平白的语言讲清楚. 感谢大家阅读, 难免理解有误或以讹传讹, 欢迎大家指正.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Binder机制
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Handler全解</title>
    <link href="http://blog.hjhjw1991.net/android/2017/01/06/%5BAndroid%E6%95%99%E7%A8%8B%5DHandler%E5%85%A8%E8%A7%A3/"/>
    <id>http://blog.hjhjw1991.net/android/2017/01/06/[Android教程]Handler全解/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-02-07T09:11:13.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回顾"><a href="#某渣的凭印象回顾" class="headerlink" title="某渣的凭印象回顾"></a>某渣的凭印象回顾</h2><p>Handler是线程间消息通讯的一种方式. 使用它需要Message, MessageQueue, Looper几个东西的配合. 每个线程都有一个Looper对象, 它里面有个方法loop()会去轮询消息队列MessageQueue中的Message, 对每个Message去调用它目标线程的Handler来处理这个消息. 轮询的操作会调用native方法使用epoll机制来获得Message. 最常见的使用场景就是子线程中做计算, 将结果返回给主线程, 此时子线程就需要使用主线程的Handler来发送消息到主线程的消息队列, 再由主线程的Handler来处理消息.  </p>
<h2 id="为什么需要Handler"><a href="#为什么需要Handler" class="headerlink" title="为什么需要Handler"></a>为什么需要Handler</h2><p>参考: <a href="http://blog.csdn.net/innost/article/details/47317823" target="_blank" rel="external">&lt;&lt;深入理解Android 卷III&gt;&gt;第二章 深入理解Java Binder和MessageQueue</a>  </p>
<ol>
<li>线程之间通信的需要. 在Android中, 系统做了一个隐含假设, 即用来显示UI的线程应该只用来显示UI包括更新UI, 不应该做过多的事情, 而同时, 其他线程应该做他们该做的事情, 而不应该更新UI. 因此, 如果试图在一个非UI线程中更新UI组件, 会抛出异常(如果你知道某个叫<code>runOnMainThread</code>的黑科技你当然可以用), 而如果在UI线程中做了过多的事情, 会导致UI线程阻塞(ANR). 这就造成一个问题, 我们经常需要根据业务逻辑或计算结果去更新UI, 这怎么办呢? 就需要其他线程和UI线程之间进行通信, 传递需要的信息.  </li>
<li>事件异步处理的需要. 有时候我们会遇到这样一种情况: 我们希望过一段时间去做某件事, 但又不希望线程阻塞去等待这个时间, 这时候我们当然可以通过新建一个线程在一段时间后与主线程通信的方式来实现这个目的, 但这样显然有点小题大做了, 有没有更好的机制能够异步处理消息而不需要额外创建子线程呢? 答案就是Handler.  </li>
</ol>
<h2 id="Handler的设计思想-工作原理"><a href="#Handler的设计思想-工作原理" class="headerlink" title="Handler的设计思想/工作原理"></a>Handler的设计思想/工作原理</h2><p>Handler不是一个孤立的类, 它与MessageQueue, Message, Looper几个类共同构成了线程间消息传递的系统.<br>其中, Message是具体消息的载体, Handler负责生产和消耗Message, MessageQueue负责把Message构成一个有序的队列, Looper负责从MessageQueue中取出Message对象. Handler, MessageQueue, Looper三个类构成了一个Message流动的循环.  </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>对于一般的线程, 我们只需要定义一个MyHandler类, 让它继承Handler类, 实现我们自己的<code>handleMessage</code>方法, 处理对应类型的Message就可以了, 大多数情况下甚至我们只需要在UI线程代码中定义一个继承Handler的匿名内部类并实现其<code>handleMessage</code>方法足矣. <code>Handler</code>中的<code>sendMessage</code>系列方法可以完成将Message入队的操作. <code>obtainMessage</code>可以获取一个空闲的Message对象. 如果你只满足于<code>Handler</code>的基本使用方法, 那知道这些就足够用了.(完)  </p>
<p><div name="empty"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><br>很好, 看来你跟我一样不只想要知道怎么用, 还想知道为什么这样用. Android那帮大牛将Handler设计得很巧妙, 机制简单易懂, 封装得非常好, 以至于我们一般情况下只需要知道上面那段话就行了. 不一般的情况呢, 我们从问题入手, 随便抛出几个问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?  </li>
</ol>
<p>以上都是很容易想到的问题, 而要彻底搞懂它们, 免不了要打开Android源码.<br>我说的”实践”, 就是看Android源码对Handler的实现.<br>现在, 先让我们抛开那些问题, 从Handler开始, 一步一步看清这背后的真相. 打开Handler源码查看它的定义, 发现它有以下几个成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final MessageQueue mQueue;</div><div class="line">final Looper mLooper;</div><div class="line">final Callback mCallback;</div><div class="line">final boolean mAsynchronous;</div></pre></td></tr></table></figure></p>
<p>一看到这几个我们心里就有点猜测了, 前两个不就是前面提到的消息队列和消息循环器吗! 不过后两个是什么鬼? 别急, 先看Handler构造方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来上面几个成员变量都在构造函数中初始化了. 其中<code>mLooper</code>使用的是<code>Looper.myLooper()</code>的返回结果, 而<code>mQueue</code>直接使用了<code>mLooper.mQueue</code>. 可以猜测MessageQueue实例是由Looper来创建的, Handler持有这个Looper实例的引用, Handler和mLooper共同持有MessageQueue实例的引用. 构造方法传进来的两个参数用来初始化其余两个成员变量.<br>来看<code>Looper.myLooper()</code>, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从Looper的静态成员变量<code>sThreadLocal</code>中获取的Looper实例. 那么有<code>get()</code>应该也有<code>set()</code>, 可我们好像没有看到哪里有调用<code>set()</code>? 以及<code>ThreadLocal</code>这个类是个什么东西?<br>关于ThreadLocal可以看<a href="http://blog.csdn.net/singwhatiwanna/article/details/48350919" target="_blank" rel="external">任玉刚的这篇博客</a>了解, 简单来说就是一个可以存储和访问仅对当前线程可见的数据的类.<br>我们直奔<code>set()</code>方法去看看, 发现了下面这段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来是<code>prepare()</code>这个方法直接新建了一个<code>Looper</code>对象放在里面, 这样在之后取的话就能取到这个Looper了. 可是我们好像也没有调用<code>prepare()</code>? 事实上, 如果我们没有调用<code>prepare()</code>的话, 就会抛出上面Handler构造方法里面mLooper为空时的那个异常啦! 所以<code>prepare()</code>这个方法是必调的, 而且一定是在Handler所在线程中先于Handler实例创建.<br>再来看Looper的构造函数, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">       mQueue = new MessageQueue(quitAllowed);</div><div class="line">       mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>明白了, 在Looper构造函数中, 新建了MessageQueue, 并且持有了当前线程的引用.<br>细心的同学可能会问了: “我在Activity里面没有调用prepare方法, 可我用Handler也用得很6啊!”. 这位同学, 我很欣赏你的细心. <code>Activity</code>就是我们的UI线程了, 为什么我们在UI线程里面可以不调用<code>prepare</code>呢? 答案是, 系统已经帮我们调用过了. 有看过Activity启动源码的同学可能会知道, 在Android中Activity的启动是通过<code>ActivityManagerService</code>做到的, 其中在<code>ActivityThread</code>里面, 会调用<code>Looper.prepareMainLooper()</code>为主线程准备一个Looper, 并且调用<code>Looper.loop()</code>开始轮询. 其中<code>prepareMainLooper()</code>大体上就是调用了<code>prepare</code>方法, 只不过加了个锁来保证主线程Looper对象的唯一性.  </p>
<p>到此, 我们已经知道了Looper对象从哪里来, 到哪里去, 我们也知道调用<code>loop()</code>方法之后Looper就开始轮询MessageQueue了, 但我们还不知道Looper对象的<code>loop()</code>方法在干嘛. 看看源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line"></div><div class="line">    //获得一个 Looper 对象</div><div class="line">    final Looper me = myLooper();</div><div class="line"></div><div class="line">    // 拿到 looper 对应的 mQueue 对象</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    //死循环监听(如果没有消息变化，他不会工作的) 不断轮询 queue 中的 Message</div><div class="line">    for (;;) &#123;</div><div class="line">        // 通过 queue 的 next 方法拿到一个 Message</div><div class="line">        Message msg = queue.next(); // 可能会阻塞, 具体是调用native方法时可能阻塞</div><div class="line">        //空判断</div><div class="line">        if (msg == null)return;</div><div class="line">        //消息分发   </div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        //回收操作  </div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取到MessageQueue实例, 死循环读取下一个消息, 再调用<code>Message.target.dispatchMessage(msg)</code>将消息分发到<code>target</code>中去处理.<br>诶? 这个target是啥? 显然, 它是在Message中设置好的东西, 让我们看看Handler的<code>sendMessage</code>源码. Handler中有许多发送消息的方法, 但追本溯源会到达下面这个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Handler target;</div><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    // 使用默认的 handler 构造方法时，mAsynchronous 为 false。</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">       msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有意思, 发送消息时首先检验MessageQueue是不是为空, 不空的话就执行入队操作, 在入队的方法中让Message对象持有当前Handler的引用, 然后调用MessageQueue的入队方法. 有兴趣的同学可以再深入看一下MessageQueue的入队方法是怎么实现的, 里面会涉及到更加具体的所使用的数据结构, 由于它不影响咱们理解Handler机制, 这里就暂不展开了.<br>再看<code>dispatchMessage</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一切都连起来了. 在这里, 如果你的Message对象中, callback为空, 那么就会执行到Handler成员<code>mCallback</code>的<code>handleMessage</code>方法或Handler的<code>handleMessage</code>方法, 否则会直接执行<code>handleCallback</code>. 我们去看一下<code>handleCallback</code>和<code>Message</code>的源码, 就会发现<code>callback</code>是一个<code>Runnable</code>对象, 而<code>handleCallback</code>中直接调用了这个对象的<code>run()</code>方法. 所以我们可以得出结论, 如果设置了Message的callback, 那handleMessage就不起作用了, 转而用callback来处理这个消息. 按Android那帮天才的习惯, Handler里应该有对应的API来供开发者调用. 果不其然, 可以找到<code>post</code>等相关方法.  </p>
<p>至此, Message是怎么进入和退出MessageQueue, 又是怎么被Handler处理的, 这个过程我们都已经清楚了. 尝试回答一下本节开头时提出的问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: 看源码.  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: 看源码.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 看源码, 看我上面的分析.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 看我上面的分析.  </li>
</ol>
<p>如果你有种上当的感觉的话, 你的感觉是对的, 我上面这一段分析基本上没有回答这几个问题. 其实看到这里你应该也有所感觉, 重要的是这种设计的思路, 厘清了思路之后, 具体能做什么/怎么做, 就是可以自己把控的了.  </p>
<p>然鹅, 这里我正正经经回答一下上面那些问题, 免得搜索那些问题进来的同学们失望:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: <code>android.os.Message</code>是一个<code>final</code>类, 它实现了<code>Parcelable</code>接口, 通过一个<code>int</code>型的<code>flags</code>来标记状态, 状态包括<code>FLAG_IN_USE</code>, <code>FLAG_ASYNCHRONOUS</code>, <code>FLAGS_TO_CLEAR_ON_COPY_FROM</code>三种. <code>Message</code>内主要的成员变量有:  <ul>
<li>公共成员变量what/arg1/arg2/obj/replyTo/sendingUid, 前三个是整型, 后三个分别是<code>Object</code>, <code>Message</code>, <code>int</code>型. 我们可以通过<code>obtain</code>方法的重载来设置前四个变量.  </li>
<li>包可见成员变量flags(及其三个标志状态)/when/data/target/callback/next, 类型分别是<code>int</code>, <code>long</code>, <code>Bundle</code>, <code>Handler</code>, <code>Runnable</code>, <code>Message</code>. 其中除了next以外都有对应的设置方法.  </li>
<li>私有变量sPoolSync/sPool/sPoolSize/MAX_POOL_SIZE/gCheckRecycle, 类型分别是<code>Object</code>, <code>Message</code>, <code>int</code>, <code>final int</code>, <code>boolean</code>. 前四个的作用是在消息池非空时同步地从消息池(单链表, sPool指向表头)中摘出表头节点作为<code>obtain()</code>的返回值(所有重载的<code>obtain</code>方法都通过该无参方法获得Message实例), 或者在<code>recycleUnchecked()</code>时将当前消息插入到表头. 表的最大容量是50. 最后一个是在API 21加入的标记, 标志是否要检查回收状态. 使用中的<code>Message</code>被回收时如果该标志为<code>true</code>则抛出<code>IllegalStateException</code>异常.<br>总结来说, Message实现了一个最大容量为50的单链表结构, 其类静态变量<code>sPool</code>指向表头, 其实现了<code>Parcelable</code>接口, 可以承载包括<code>Bundle</code>在内的复杂数据.  </li>
</ul>
</li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: <code>android.os.Handler</code>是一个专用于继承实现的类, 它的<code>handleMessage</code>是一个空方法. 它内部定义了一个<code>Callback</code>接口, 含有<code>boolean handleMessage(Message msg)</code>方法, 成员变量<code>mCallback</code>就是这个接口类型, 在Handler的<code>dispatchMessage</code>中拥有第二优先权, 仅次于Message本身的Callback. 继承Handler类容易造成内存泄漏, 这一点需要格外注意. <code>obtainMessage</code>代理了<code>Message</code>类的静态多态方法<code>obtain</code>. 由于<code>Message</code>没有显式定义构造函数, 直接<code>new Message</code>显然是可以的, <code>obtain()</code>就是通过这个构造函数初始化消息池. 但这样做无法循环利用消息池, 造成内存浪费, 因此<code>obtainMessage</code>是更好地获取Message实例的方法. <code>sendMessage</code>做了什么见上文的相关段落,  由于这个是系统调用机制, 效率上我没有想到更好的实现方式. <code>sendMessageAtTime</code>等方法允许子类重写. 除了<code>handleMessage</code>和<code>sendMessage</code>, Handler中还定义了一些实用的方法和类, 例如可以获取到Looper, 可以传入Runnable获取Message实例, 可以dump信息, 实现了一个阻塞的<code>final class BlockingRunnable</code>用于内部的<code>runWithScissors</code>. 实现了一个<code>final class MessengerImpl</code>用于在发送Message之前设置Message的Uid为Binder的Uid, 并让包可见成员变量mMessenger持有该类的实例, 但实际上这个成员变量未在别处引用.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 上文已经分析了<code>MessageQueue</code>是什么时候创建的(创建Looper时). 在每个消息进入队列(<code>enqueueMessage</code>)的时候, 会根据该消息的时间when将它插入到消息队列链表(这个链表不同于消息池的链表)中, 因此消息队列中的消息都是按照消息时间排序好的, 在取出Message时, 如果没有到该消息的执行时间, 会<code>nativePollOnce</code>等待到执行时间. <code>MessageQueue</code>从代码看没有容量限制.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 上文已经分析了Looper是什么时候创建的(<code>Looper.prepare()</code>调用时). 它怎么处理Message为空的情况? 答案是退出循环, 因为Message为空只可能出现在MessageQueue已经没有内容时. 它怎么分发到正确的Handler对象, 这可以看前文分析, 答案是在<code>sendMessage</code>调用<code>enqueueMessage</code>时, Handler默认会把每个<code>Message</code>的<code>target</code>都设置为它自己, 循环处理时直接调用<code>msg.target.dispatchMessage(msg)</code>来分发. 循环时Looper会保证始终在同一线程上处理消息队列, 如果线程发生变化, Looper会记录一个<code>Log.wtf()</code>日志(注释说是<code>What a Terrible Failure</code>, 但我怎么看都觉得是<code>What The Fxxk</code>). Looper每处理完一个Message都会调用它的<code>recycleUnchecked()</code>让它进入消息池.  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Handler异步消息机制
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】NDK&amp;JNI入门</title>
    <link href="http://blog.hjhjw1991.net/android/2016/12/21/%5BAndroid%E6%95%99%E7%A8%8B%5Dndk&amp;jni/"/>
    <id>http://blog.hjhjw1991.net/android/2016/12/21/[Android教程]ndk&amp;jni/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2017-02-07T09:48:01.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NDK-amp-JNI"><a href="#NDK-amp-JNI" class="headerlink" title="NDK &amp; JNI"></a>NDK &amp; JNI</h2><p>NDK和JNI的关系是: Java通过JNI的方式调用由NDK编译生成的本地库.<br>JNI是独立于NDK的一个技术, NDK是帮助编译c/cpp文件的一个工具.  </p>
<p>在JNI的c文件中如果用到了<code>#include &lt;utils/Log.h&gt;</code>  </p>
<p>然后用NDK 编译的时候会提示<code>error: utils/Log.h: No such file or directory</code><br>这个是因为这个头文件在Android源码的<code>frameworks/base/include</code>中，不在SDK或NDK中  </p>
<p>如果想要使用NDK的LOG功能的话  </p>
<p>1—–修改Android.mk文件配置,添加如下语句，这是载入liblog库，其中$(SYSROOT)是NDK中platform的路径  </p>
<p><code>LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog</code>  </p>
<p>2—–在.c文件中修改为如下语句。这是引入NDK中的日志头文件，位置在<code>$(SYSROOT)/usr/include</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include&lt;android/log.h&gt;</div></pre></td></tr></table></figure></p>
<p>3—–使用方法。其中这后面的方法在头文件中可以找到定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define LOG_TAG &quot;debug&quot;</div><div class="line">#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, fmt, ##args)</div></pre></td></tr></table></figure>
<p>4—-打印语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOGI(&quot;test log!!!!&quot;);</div><div class="line"></div><div class="line">LOGI(&quot;the string is: %s \n&quot;,buff);</div></pre></td></tr></table></figure></p>
<p>5—-错误输出到日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOGI(strerror(errno))</div></pre></td></tr></table></figure></p>
<p>如果想要开启NDK的Debug功能，需要按照下列步骤操作。  </p>
<h2 id="JNI中的映射关系"><a href="#JNI中的映射关系" class="headerlink" title="JNI中的映射关系"></a>JNI中的映射关系</h2><p>基本类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">Java 类型</th>
<th>jni本地类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td>jboolean</td>
<td style="text-align:left">C/C++ unsigned 8 bits</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td>jbyte</td>
<td style="text-align:left">C/C++ signed 8 bits</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td>jchar</td>
<td style="text-align:left">C/C++ unsigned 16 bits</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>jshort</td>
<td style="text-align:left">C/C++ signed 16 bits</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td>jint</td>
<td style="text-align:left">C/C++ signed 32 bits</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td>jlong</td>
<td style="text-align:left">C/C++ signed 64 bits</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>jfloat</td>
<td style="text-align:left">C/C++  32位浮点型</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>jdouble</td>
<td style="text-align:left">C/C++  64位浮点型</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td>void</td>
<td style="text-align:left">N/A</td>
</tr>
</tbody>
</table>
<p>命名规则就是java基本类型加j前缀.  </p>
<p>引用类型和数组类型也差不多:<br>引用类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>jobject</td>
<td>任何Java对象，或者没有对应java类型的对象</td>
</tr>
<tr>
<td>Class</td>
<td>jclass</td>
<td>class对象</td>
</tr>
<tr>
<td>String</td>
<td>jstring</td>
<td>字符串对象</td>
</tr>
</tbody>
</table>
<p>数组类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>布尔型数组 unsigned</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>比特型数组 signed</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>字符型数组 unsigned</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>短整型数组 signed</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>整型数组 signed</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>长整型数组 signed</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>浮点型数组</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>双浮点型数组</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>任何对象的数组</td>
</tr>
</tbody>
</table>
<p>数组类型多个Array后缀.  </p>
<p>JNI函数签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello(JNIEnv *, jclass, jstring);</div></pre></td></tr></table></figure></p>
<p>第一个参数: <code>JNIEnv*</code> 是定义任意 <code>native</code> 函数的第一个参数(包括调用 JNI 的 <code>RegisterNatives</code> 函数注册的函数), 指向 JVM 函数表的指针, 函数表中的每一个入口指向一个 JNI 函数, 每个函数用于访问 JVM 中特定的数据结构.<br>第二个参数: 调用 Java 中 native 方法的实例或 Class 对象, 如果这个 <code>native</code> 方法是实例方法, 则该参数是 <code>jobject</code>,如果是静态方法，则是 <code>jclass</code>.<br>第三个参数: Java 对应 JNI 中的数据类型, Java 中 String 类型对应 JNI 的 jstring 类型. (前面已介绍 JAVA 与 JNI 数据类型的映射关系)  </p>
<p>函数签名也可以手动动态映射, 通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static JNINativeMethod gMethods[] = &#123;</div><div class="line">// 这里写映射关系数组</div><div class="line">// &#123;&quot;native函数名&quot;, &quot;参数列表&quot;, 对应的JNI方法&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中参数列表有个缩写映射规则,要用缩写表示Java类型.<br>当参数为引用类型的时候，参数类型的标示的格式为”L完整路径名;”,前面L后面分号.如果是数组就是在成员类型前面加[,有多少层加多少个[.例如String对应的就是<code>(Ljava/lang/String;)</code>  </p>
<table>
<thead>
<tr>
<th>类型标志</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>Ljava/lang/String</td>
<td>String</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>[I</td>
<td>Int[]</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>[Ljava/lang/object</td>
<td>Object[]</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
</tbody>
</table>
<p><code>javap</code>可以生成函数签名. <code>javap -s -p xxx</code>. 参数含义参见help.  </p>
<p>JNI层就相当于是在用C写东西了, 所以语法也是C的语法.<br>对于基本类型, 可以直接强制类型转换成对应长度的C/C++类型(事实上, 查看jni基本类型的定义可以发现, 它们都是c基本类型的<code>typedef</code>).<br>对于数组类型, 需要使用JNIEnv提供的方法, 简单类型的数组会把其指针直接暴露给本地代码. 一系列GetXXXArrayElements函数可以把Java数组作为参数, 返回一个指向对应的本地类型的数组指针.  </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>Java 数组类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetBooleanArrayElements</td>
<td>jbooleanArray</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteArrayElements</td>
<td>jbyteArray</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharArrayElements</td>
<td>jcharArray</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortArrayElements</td>
<td>jshortArray</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntArrayElements</td>
<td>jintArray</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongArrayElements</td>
<td>jlongArray</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatArrayElements</td>
<td>jfloatArray</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleArrayElements</td>
<td>jdoubleArray</td>
<td>jdouble</td>
</tr>
</tbody>
</table>
<p>使用完之后要调用对应的ReleaseXXXArrayElements, 参数是对应的数组和前面GetXXXArrayElements返回的指针. 这个函数会把你对本地数组做的变化复制到Java数组中, 然后释放相关资源.<br>JNIEnv还有一些别的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GetArrayLength</div><div class="line"></div><div class="line">NewXXXArray</div><div class="line"></div><div class="line">GetXXXArrayElements</div><div class="line"></div><div class="line">ReleaseXXXArrayElements</div><div class="line"></div><div class="line">GetXXXArrayRegion</div><div class="line"></div><div class="line">SetXXXArrayRegion</div></pre></td></tr></table></figure></p>
<p>这些方法都是Env预定义的方法, 帮助你在C/C++的Array和Java的Array之间转换.  </p>
<h2 id="NDK用到的C-C-运行库"><a href="#NDK用到的C-C-运行库" class="headerlink" title="NDK用到的C/C++运行库"></a>NDK用到的C/C++运行库</h2><p>你在Android.mk文件中可以指定LOCAL_CPP_EXTENSION来告诉编译器, 把什么后缀的文件当做C++源文件来编译. 对于C和C++会采用不同的编译器. 不过，编译过后的C++程序想要执行，还必须要有C++运行环境（C++ Runtime）的支持。默认情况下，Android NDK会使用一个非常迷你的C++运行环境，称做“libstdc++”。这个运行环境几乎什么都没有，不支持异常和RTTI（RunTime Type Information，即运行时类型识别），甚至连C++标准库也没有。  </p>
<p><style><br>img {<br>  width: 600px;<br>  height: 400px;<br>  margin: auto;<br>}<br></style><br><img src="/images/blogs/c++runtimelibrary.jpg" alt="c++ runtime library">  </p>
<p><code>.a</code>是静态库, <code>.so</code>是动态库, 也叫共享库. 通过<code>Application.mk</code>的<code>APP_STL</code>可以配置想要用什么运行库, 需要注意的是Android源码目录的ndk子目录下面, 就有各个目标平台和架构的运行库, Android 8(Android 2.2)之前, 是只有默认的那个库.  </p>
<p>最后，还有一点需要注意，如果你的JNI功能都是包含在一个模块（也就是程序中只有一个.so文件）中的话，可以考虑用静态库C++运行时库的形式。而如果你的程序中包含了多个模块，请尽量使用动态C++运行时库。  </p>
<p>在用动态C++运行时库的时候，相应的动态库.so文件（默认的C++运行时库除外）会随你的程序一起发布出去，位于apk文件中的lib目录下。  </p>
<p>如果你的目标Android系统是4.3之前，那么你必须要在加载所有你自己的模块之前，显式的加载C++动态运行时库。  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲NDK &amp; JNI基础
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu 16.04 64bit上下载、编译和安装Android源码</title>
    <link href="http://blog.hjhjw1991.net/android/2016/08/01/build-android/"/>
    <id>http://blog.hjhjw1991.net/android/2016/08/01/build-android/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:05:29.367Z</updated>
    
    <content type="html"><![CDATA[<p>自诩为Android开发者已经很久了然而却没有自己编译安装过Android源码，怎么也说不过去。今天就编译安装，记录下来过程中需要注意的情况。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>如果在中国大陆建议有一个能访问google的网络环境，官方的指导是最可靠最完善的。</li>
<li>Android编译不能在Windows系统上进行，所以你需要一个基于Linux的系统，Mac OS和Ubuntu都行，虚拟机的话需要16GB的swap空间。官方使用的是Ubuntu 14.04，我建议你也用这个版本（我用的是16.04）。  </li>
<li>Android基于Java，最新的基于Java 8， 所以你需要安装JDK 1.8。</li>
<li>Android源码使用Git进行管理，并在外封装了一层叫Repo，所以你还要安装Git客户端。  </li>
<li>安装依赖包。</li>
</ul>
<pre><code>sudo apt-get install git-core gnupg flex bison gperf build-essential \  
zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \  
lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \  
libgl1-mesa-dev libxml2-utils xsltproc unzip  
</code></pre><h2 id="下载Android源码"><a href="#下载Android源码" class="headerlink" title="下载Android源码"></a>下载Android源码</h2><p>Android源码每个分支可能都要占用约22GB空间，官方建议磁盘空间至少25GB.我建议先选定一个版本的源码，进行下载。  </p>
<ol>
<li><p>下载repo工具。执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://storage.googleapis.com/git-repo-downloads/repo</div><div class="line">chmod a+x repo</div><div class="line">mkdir ~/bin</div><div class="line">cp repo ~/bin/</div><div class="line">PATH=~/bin:$PATH</div></pre></td></tr></table></figure>
</li>
<li><p>下载源码。执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdidr AndroidSource</div><div class="line">cd AndroidSource</div><div class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.1_r1 # -b是选择分支，不加则下载最新master分支。可以在网页上查看有哪些分支标签</div><div class="line">repo sync</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后就开始下载源码了，视网络状况这个过程可能会很长（我下了两天），中间还可能遇到下载错误，这时候重新执行<code>repo sync</code>就行了。</p>
<h2 id="编译Android源码"><a href="#编译Android源码" class="headerlink" title="编译Android源码"></a>编译Android源码</h2><p>Android用到的Makefile系统来编译源码，所以必要的相关知识会非常有帮助。以后涉及到单独模块的编译需要自己写makefile。<br>在源码根目录下执行<code>make</code>就可以编译源码。默认编译目标是<code>droid</code>，默认输出目录在<code>/out</code>，执行<code>source build/envsetup.sh</code>可以获得更多的编译命令，其中<code>lunch</code>和<code>mmm</code>两个命令特别有用。<br>编译目标中，默认是<code>droid</code>前面已经说过，另外还有几个常用的编译目标，<code>clean</code>清理out目录，<code>sdk</code>编译SDK，<code>clean-sdk</code>清理SDK编译产物，<code>all</code>编译所有内容，<code>snod</code>从已经编译出的包快速重建系统镜像，<code>dump-products</code>显示所有产品的编译配置信息，<code>bootimage</code> <code>recoveryiamge</code> <code>userdataimage</code> <code>cacheimage</code>生成对应的<code>.img</code>。关于Build系统可以看<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#icomments" target="_blank" rel="external">这里</a>  </p>
<p>可能会遇到问题：<br>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You are using version x.x of make  </div><div class="line">Android can only be built by versions 3.81 and 3.82</div></pre></td></tr></table></figure></p>
<p>make的版本过低或过高，过低升级即可，过高则需要安装指定版本。我先remove了make 4.1，然后在<a href="http://packages.ubuntu.com/trusty/make" target="_blank" rel="external">http://packages.ubuntu.com/trusty/make</a> 下载安装了make 3.81。<br>2.<br><code>You are attempting to build with an unsupported JDK.</code><br>很明显OpenJDK不被支持，需要Oracle JDK。另外，JDK版本也一定要与你要编译的版本相匹配，不能过高，否则提示<code>You are attempting to build with the incorrect version
of java.</code>。比如我编译4.4源码用的JDK 1.8，就提示java版本错误，非常郁闷。<br>安装好JDK 6 之后终于开始了编译步骤。<br>官网上说AOSP光靠它的源码还不能工作，需要一些跟硬件有关的library，在<a href="http://source.android.com/source/requirements.html#binaries" target="_blank" rel="external">http://source.android.com/source/requirements.html#binaries</a> 最下面。另外提供了官方的Nexus系列的驱动在<a href="https://developers.google.com/android/nexus/blobs-preview" target="_blank" rel="external">https://developers.google.com/android/nexus/blobs-preview</a> 和 <a href="https://developers.google.com/android/nexus/drivers" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers</a> 。安装步骤见<a href="http://source.android.com/source/building.html，" target="_blank" rel="external">http://source.android.com/source/building.html，</a> 每个binary是一个自解压文件，在Android源码根目录运行这个自解压文件，然后相应的binary和makefile就会被安装在vendor目录。<br>编译没有错误的话就会生成Android系统了，根据主机配置不同这个过程可能比较久（我开始编译的时候没有注意，用了4小时…），可以在make的时候指定并发job数量来加速编译过程：<code>make -j8</code>。<br>编译完成的out目录下应该有<code>system.img</code> <code>ramdisk.img</code> <code>userdata.img</code>三个文件。<br>接下来进行安装。  </p>
<h2 id="安装编译好的Android到模拟器"><a href="#安装编译好的Android到模拟器" class="headerlink" title="安装编译好的Android到模拟器"></a>安装编译好的Android到模拟器</h2><p>安装有两种选择：刷到设备里和安装到模拟器。其中刷到设备里需要设备和编译目标相匹配，否则可能无法成功启动，且需要用到<code>fastboot</code>工具，见<a href="http://source.android.com/source/running.html#flashing-a-device" target="_blank" rel="external">flashing a device</a>。这里我们选择安装到模拟器。<br>在build完成后把<code>/out/host/linux-x86/bin/emulator</code>添加到环境变量，这里需要执行的是这个<code>emulator</code>。加选项<code>-kernel &lt;PATH&gt;</code> <code>-sysdir &lt;PATH&gt;</code> <code>-system &lt;PATH&gt;</code> <code>-data &lt;PATH&gt;</code> <code>-ramdisk &lt;PATH&gt;</code>可以指定要用到的image文件。模拟器运行需要四个文件，分别是Linux Kernel镜像kernel-qemu（在<code>$ANDROID_SOURCE/prebuilts/qemu-kernel</code>中）、Android镜像<code>system.img</code>、<code>userdata.img</code>和<code>ramdisk.img</code>。<br>需要注意的是即使是模拟器平台也要跟编译目标相匹配，模拟器要求的内核最低版本必须低于所使用的内核版本。<br>今后就可以自己修改某个模块的代码，然后编译这个模块并重新打包到<code>system.img</code>来查看效果啦！<br>甚至可以自己定义新的模块，添加到系统镜像中。Android自带的App存放在<code>out/target/product/generic/system/app</code>，可执行文件存放在<code>out/target/product/generic/system/bin</code>，动态链接库存放在<code>out/target/product/generic/system/lib</code>，硬件抽象层（HAL）接口文件存放在<code>out/target/product/generic/system/lib/hw</code>。  </p>
<p>可能会遇到的问题：</p>
<ol>
<li><p><code>emulator: ERROR: Missing initial data partition file: (null)</code> or 必须要指定一个虚拟机才能运行<code>emulator</code>。遇到这个可能是因为你使用了不合适的<code>emulator</code>，看一看<code>which emulator</code>，是不是使用了Sdk中的<code>emulator</code>。应该使用<code>/out/host/linux-x86/bin/emulator</code>。  </p>
</li>
<li><p><code>qemu: could not load initrd &#39;ramdisk.img&#39;</code>。遇到这个问题可能是模拟器没有读取到正确的<code>ramdisk.img</code>文件。按网上说法使用绝对路径即可，也可以将<code>ramdisk</code>的父目录<code>out/target/product/generic</code>添加到环境变量。  </p>
</li>
<li><p>启动模拟器后一直黑屏。可能是使用了错误的kernel，换一个kernel试试。我换成<code>arm/kernel-qemu-armv7</code>就可以启动了。  </p>
</li>
<li><p><code>emulator: WARNING: system partition size adjusted to match image file (550 MB &gt; 200 MB)</code>。这个WARNING好像不影响模拟器运行，但强迫症还是想弄懂为什么要WARNING，于是查了查。原来是所需空间不足，添加参数<code>emulator -partition-size 1024 # 大于所需尺寸即可</code>。  </p>
</li>
<li><p><code>make: *** No rule to make target &#39;out/target/product/generic/root/file_contexts&#39;, needed by &#39;snod&#39;.  Stop.</code> 或者启动模拟器后一直停留在开机画面，打开monitor发现logcat一直在循环刷错误(最近几天连续出现这个问题，虽然还没搞清楚原因，不过暂时在<code>emulator</code>之前执行<code>lunch full-eng</code>是有效果的，另外如果不执行<code>lunch full-eng</code>的话启动的模拟器默认连皮肤都没有，完全没有按键)。可能是模块编译目标与system.img目标不匹配。在编译模块前<code>lunch full-eng# lunch的combo要和编译系统时lunch的combo一致</code>，在<code>make snod</code>前<code>lunch full-eng</code>，我是这么做的。  </p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文参考了以下文章，排列不分先后：<br><a href="http://blog.csdn.net/luoshengyang/article/details/18928789" target="_blank" rel="external">Android编译系统环境初始化过程分析</a><br><a href="http://blog.csdn.net/innost/article/details/47660387" target="_blank" rel="external">深入理解Android输入系统</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="external">那两年练就的Android内功修养-老罗</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/6559955" target="_blank" rel="external">在Ubuntu上下载、编译和安装Android最新源代码-老罗</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/6566662" target="_blank" rel="external">如何单独编译Android源代码中的模块-老罗</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#icomments" target="_blank" rel="external">理解Android Build系统</a>  </p>
]]></content>
    
    <summary type="html">
    
      从空系统开始如何下载和编译Android系统源码
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>从源码编译Android SDK</title>
    <link href="http://blog.hjhjw1991.net/android/2016/08/01/build-android-sdk/"/>
    <id>http://blog.hjhjw1991.net/android/2016/08/01/build-android-sdk/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:04:30.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Build-Android-SDK"><a href="#Build-Android-SDK" class="headerlink" title="Build Android SDK"></a>Build Android SDK</h2><p>前面已经编译好了系统源码，解决了一些问题，本以为编译SDK会顺顺利利一气呵成，我还是太天真了。<br>上来就遇到<code>bluetooth-health</code>模块找不到。google之后知道这是官方预计删除但还没有删除bluetooth-health的Android.mk所致。解决方式是在<code>make sdk</code>之前先执行<code>lunch sdk-eng</code>。<br>然后遇到<code>tools/base</code>目录找不到，退出，这时候都编译很久了，这不坑爹吗！解决方法是找到<code>sdk/eclipse/scripts/create_all_symlinks.sh</code>把里面所有有关<code>tools/base</code>的命令都注释掉。哦，这个文件在错误提示中有。顺便看了下这个<code>tools/base</code>是干嘛用的，好像跟Gradle构建有关，反正是Eclipse的东西吧，注释就注释了吧，顺便把<code>tools/swt</code>也注释了。<br>再编译，漫长等待之后又遇到问题，<code>base:testutils</code>资源读不到。看了一下好像是测试相关的东西，好像是<code>easymock</code>依赖的东西，想了想果断也注释了。<br>再编译又遇到<code>sdk/build/tools.atree</code>提示<code>couldn&#39;t locate source file</code>，我连<code>Package SDK</code>都看到了，你给我出个这个错误，我都不知道该不该修，感觉SDK已经打包好了……想想还是修吧。看了下路径下确实没有错误中提到的Template文件夹，更别说文件了。摸进<code>tools.atree</code>把载入的地方看了下，看不出来有什么用，也注释掉了。<br>再编译，总算无错误完成。还不知道用起来有没有什么坑。  </p>
]]></content>
    
    <summary type="html">
    
      从源码开始如何编译SDK
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android源码结构</title>
    <link href="http://blog.hjhjw1991.net/android/2016/08/01/Android%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.hjhjw1991.net/android/2016/08/01/Android源码结构/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:18:02.211Z</updated>
    
    <content type="html"><![CDATA[<p>相信各位对于Android系统架构图的三层或四层结构已经了然于胸，迫不及待想要膜拜一下源码，但是可能好不容易下载好源码打开一看就懵逼了：这目录是啥？这又是啥？其实Android源码目录名字已经很浅显地表明了目录的内容和功能，但对于初学者特别是背景知识不够宽宏的初学者而言还是有点摸不着头脑。本文简单介绍Android系统源码目录结构，好让读者对Android源码有一个整体的概念，这样当深入到某一模块研究的时候能够同时心中有全局。<br>首先要了解一个理念：Android源码以什么样的原则来分包和存放。从目录看，Android很自然地将源码分为Core、External和Package三种，其中Core是核心工程，在根目录的各个文件夹中，External是扩展工程，使用其他开源项目扩展的功能，在external文件夹中，Package是提供应用程序和服务的，在package中，平时用到的各种系统应用就是在这里面写就的。<br>以下按层次结构依次标注目录功能（源码版本：android_4.4.1-r1）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── abi                application binary interface，应用程序二进制接口</div><div class="line">├── art                art虚拟机</div><div class="line">├── bionic             [Build] bionic C运行时支持：libc、libm、libdl、动态linker</div><div class="line">├── bootable           启动引导相关代码</div><div class="line">├── build              [Build]存放系统编译规则及generic等基础开发配置</div><div class="line">├── cts                Android兼容性测试套件标准</div><div class="line">├── dalvik             dalvik虚拟机</div><div class="line">├── developers         开发者相关</div><div class="line">├── development        应用程序开发相关</div><div class="line">├── device             设备相关代码（厂商定制代码就放在这里）</div><div class="line">├── docs               开源相关文档</div><div class="line">├── external           Android使用的开源模块</div><div class="line">├── frameworks         核心框架，包含Java source和C++ source</div><div class="line">├── hardware           主要是硬件适配层HAL</div><div class="line">├── libcore            核心库相关</div><div class="line">├── libnativehelper    动态库，是实现JNI的基础</div><div class="line">├── Makefile           [Build]make的入口点，其内容只有一句话即include build/core/main.mk</div><div class="line">├── ndk                ndk相关代码</div><div class="line">├── out                编译输出文件夹，默认编译完成后的结果输出到此目录</div><div class="line">├── packages           应用程序包</div><div class="line">├── pdk                Plug Development Kit，本地开发套件</div><div class="line">├── prebuilts          预编译的资源（例如Linux-Kernel，分为x86和arm架构）</div><div class="line">├── sdk                sdk及模拟器相关代码</div><div class="line">├── system             文件系统和应用组件，c/c++代码</div><div class="line">├── tools              工具文件夹，如gradle等</div></pre></td></tr></table></figure>
<p>作为开发者根据自己的需要可以对不同部分加以关注，我们主要关注packages和frameworks目录。我们打开frameworks，发现它的目录结构如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div></pre></td><td class="code"><pre><div class="line">./frameworks/</div><div class="line">├── av                      Audio/Video</div><div class="line">│   ├── camera              相机</div><div class="line">│   ├── CleanSpec.mk        本模块的清除步骤，下同</div><div class="line">│   ├── cmds                command目录，包含录屏和stagefright两个子目录</div><div class="line">│   ├── drm                 digital rights management相关</div><div class="line">│   ├── include             头文件</div><div class="line">│   ├── libvideoeditor      视频编辑器库</div><div class="line">│   ├── media               媒体</div><div class="line">│   ├── MODULE_LICENSE_APACHE2    开源协议</div><div class="line">│   ├── NOTICE              声明</div><div class="line">│   ├── services            服务，包含audioflinger，camera和medialog</div><div class="line">│   └── tools               工具</div><div class="line">├── base                    基础定义，我们主要关注这个文件夹下的内容</div><div class="line">│   ├── Android.mk          本模块的编译步骤，下同</div><div class="line">│   ├── api                 当前api定义，如果api有变化这个文件会相应更新</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── cmds</div><div class="line">│   ├── core                framework核心代码，实现了几乎所有底层功能，包含java和c/c++代码，android.xx.xx/com.android.internal.xx/com.android.server的NetworkObserver代码位于这里</div><div class="line">│   ├── data                数据文件夹，包含字体、键盘定义、声音、视频等数据</div><div class="line">│   ├── docs                文档</div><div class="line">│   ├── drm                 版权保护</div><div class="line">│   ├── graphics            图形</div><div class="line">│   ├── include             ...</div><div class="line">│   ├── keystore</div><div class="line">│   ├── libs</div><div class="line">│   ├── location</div><div class="line">│   ├── media</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── native</div><div class="line">│   ├── nfc-extras</div><div class="line">│   ├── NOTICE</div><div class="line">│   ├── obex</div><div class="line">│   ├── opengl</div><div class="line">│   ├── packages</div><div class="line">│   ├── policy</div><div class="line">│   ├── preloaded-classes</div><div class="line">│   ├── samples</div><div class="line">│   ├── sax</div><div class="line">│   ├── services            com.android.server的大部分代码位于这里</div><div class="line">│   ├── telephony</div><div class="line">│   ├── test-runner</div><div class="line">│   ├── tests</div><div class="line">│   ├── tools</div><div class="line">│   └── wifi</div><div class="line">├── compile                 下面的内容不再一一介绍，用到的时候再去详解也不迟</div><div class="line">│   ├── libbcc</div><div class="line">│   ├── mclinker</div><div class="line">│   └── slang</div><div class="line">├── ex</div><div class="line">│   ├── camera2</div><div class="line">│   ├── carousel</div><div class="line">│   ├── chips</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── common</div><div class="line">│   ├── photoviewer</div><div class="line">│   ├── variablespeed</div><div class="line">│   └── widget</div><div class="line">├── mff</div><div class="line">├── ml</div><div class="line">│   ├── Android.mk</div><div class="line">│   └── bordeaux</div><div class="line">├── native</div><div class="line">│   ├── build</div><div class="line">│   ├── cmds</div><div class="line">│   ├── data</div><div class="line">│   ├── include</div><div class="line">│   ├── libs</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── NOTICE</div><div class="line">│   ├── opengl</div><div class="line">│   └── services</div><div class="line">├── opt</div><div class="line">│   ├── calendar</div><div class="line">│   ├── carddav</div><div class="line">│   ├── colorpicker</div><div class="line">│   ├── datetimepicker</div><div class="line">│   ├── emoji</div><div class="line">│   ├── inputmethodcommon</div><div class="line">│   ├── mailcommon</div><div class="line">│   ├── mms</div><div class="line">│   ├── net</div><div class="line">│   ├── photoviewer</div><div class="line">│   ├── telephony</div><div class="line">│   ├── timezonepicker</div><div class="line">│   └── vcard</div><div class="line">├── rs</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── cpp</div><div class="line">│   ├── cpu_ref</div><div class="line">│   ├── driver</div><div class="line">│   ├── java</div><div class="line">│   ├── rsAdapter.cpp</div><div class="line">│   ├── rsAdapter.h</div><div class="line">│   ├── rsAllocation.cpp</div><div class="line">│   ├── rsAllocation.h</div><div class="line">│   ├── rsAnimation.cpp</div><div class="line">│   ├── rsAnimation.h</div><div class="line">│   ├── rsCompatibilityLib.cpp</div><div class="line">│   ├── rsCompatibilityLib.h</div><div class="line">│   ├── rsComponent.cpp</div><div class="line">│   ├── rsComponent.h</div><div class="line">│   ├── rsContext.cpp</div><div class="line">│   ├── rsContext.h</div><div class="line">│   ├── rsCppUtils.cpp</div><div class="line">│   ├── rsCppUtils.h</div><div class="line">│   ├── rsDebugHelper.h</div><div class="line">│   ├── rsDefines.h</div><div class="line">│   ├── rsDevice.cpp</div><div class="line">│   ├── rsDevice.h</div><div class="line">│   ├── rsElement.cpp</div><div class="line">│   ├── rsElement.h</div><div class="line">│   ├── rsEnv.h</div><div class="line">│   ├── rsFBOCache.cpp</div><div class="line">│   ├── rsFBOCache.h</div><div class="line">│   ├── rsFifo.h</div><div class="line">│   ├── rsFifoSocket.cpp</div><div class="line">│   ├── rsFifoSocket.h</div><div class="line">│   ├── rsFileA3D.cpp</div><div class="line">│   ├── rsFileA3D.h</div><div class="line">│   ├── rsFont.cpp</div><div class="line">│   ├── rsFont.h</div><div class="line">│   ├── rsgApi.cpp.rsg</div><div class="line">│   ├── rsgApiFuncDecl.h.rsg</div><div class="line">│   ├── rsgApiReplay.cpp.rsg</div><div class="line">│   ├── rsgApiStructs.h.rsg</div><div class="line">│   ├── rsg_generator.c</div><div class="line">│   ├── rsGrallocConsumer.cpp</div><div class="line">│   ├── rsGrallocConsumer.h</div><div class="line">│   ├── rsg.spec</div><div class="line">│   ├── rs.h</div><div class="line">│   ├── rs_hal.h</div><div class="line">│   ├── rsMatrix2x2.cpp</div><div class="line">│   ├── rsMatrix2x2.h</div><div class="line">│   ├── rsMatrix3x3.cpp</div><div class="line">│   ├── rsMatrix3x3.h</div><div class="line">│   ├── rsMatrix4x4.cpp</div><div class="line">│   ├── rsMatrix4x4.h</div><div class="line">│   ├── rsMesh.cpp</div><div class="line">│   ├── rsMesh.h</div><div class="line">│   ├── rsMutex.cpp</div><div class="line">│   ├── rsMutex.h</div><div class="line">│   ├── rs_native.spec</div><div class="line">│   ├── rsObjectBase.cpp</div><div class="line">│   ├── rsObjectBase.h</div><div class="line">│   ├── rsPath.cpp</div><div class="line">│   ├── rsPath.h</div><div class="line">│   ├── rsProgramBase.h</div><div class="line">│   ├── rsProgram.cpp</div><div class="line">│   ├── rsProgramFragment.cpp</div><div class="line">│   ├── rsProgramFragment.h</div><div class="line">│   ├── rsProgram.h</div><div class="line">│   ├── rsProgramRaster.cpp</div><div class="line">│   ├── rsProgramRaster.h</div><div class="line">│   ├── rsProgramStore.cpp</div><div class="line">│   ├── rsProgramStore.h</div><div class="line">│   ├── rsProgramVertex.cpp</div><div class="line">│   ├── rsProgramVertex.h</div><div class="line">│   ├── rsRuntime.h</div><div class="line">│   ├── rsSampler.cpp</div><div class="line">│   ├── rsSampler.h</div><div class="line">│   ├── rsScriptC.cpp</div><div class="line">│   ├── rsScriptC.h</div><div class="line">│   ├── rsScriptC_Lib.cpp</div><div class="line">│   ├── rsScriptC_LibGL.cpp</div><div class="line">│   ├── rsScript.cpp</div><div class="line">│   ├── rsScriptGroup.cpp</div><div class="line">│   ├── rsScriptGroup.h</div><div class="line">│   ├── rsScript.h</div><div class="line">│   ├── rsScriptIntrinsic.cpp</div><div class="line">│   ├── rsScriptIntrinsic.h</div><div class="line">│   ├── rsSignal.cpp</div><div class="line">│   ├── rsSignal.h</div><div class="line">│   ├── rs.spec</div><div class="line">│   ├── rsStream.cpp</div><div class="line">│   ├── rsStream.h</div><div class="line">│   ├── rsThreadIO.cpp</div><div class="line">│   ├── rsThreadIO.h</div><div class="line">│   ├── rsType.cpp</div><div class="line">│   ├── rsType.h</div><div class="line">│   ├── rsUtils.h</div><div class="line">│   ├── scriptc</div><div class="line">│   ├── server</div><div class="line">│   ├── spec.h</div><div class="line">│   ├── spec.l</div><div class="line">│   └── tests</div><div class="line">├── support</div><div class="line">│   ├── build.gradle</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── local.properties</div><div class="line">│   ├── settings.gradle</div><div class="line">│   ├── tests</div><div class="line">│   ├── v13</div><div class="line">│   ├── v4</div><div class="line">│   ├── v7</div><div class="line">│   └── v8</div><div class="line">├── testing</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── androidtestlib</div><div class="line">│   ├── app-tests</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── uiautomator</div><div class="line">│   └── uiautomator_test_libraries</div><div class="line">├── uiautomator</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── api</div><div class="line">│   ├── apicheck_msg_current.txt</div><div class="line">│   ├── apicheck_msg_last.txt</div><div class="line">│   ├── BuildConstants.java.in</div><div class="line">│   ├── cmds</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── samples</div><div class="line">│   ├── src</div><div class="line">│   ├── tests</div><div class="line">│   └── utils</div><div class="line">├── volley</div><div class="line">│   ├── AndroidManifest.xml</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── build.gradle</div><div class="line">│   ├── build.xml</div><div class="line">│   ├── custom_rules.xml</div><div class="line">│   ├── proguard.cfg</div><div class="line">│   ├── proguard-project.txt</div><div class="line">│   ├── project.properties</div><div class="line">│   ├── src</div><div class="line">│   └── tests</div><div class="line">├── webview</div><div class="line">│   ├── Android.mk</div><div class="line">│   └── chromium</div><div class="line">└── wilhelm</div><div class="line">    ├── doc</div><div class="line">    ├── include</div><div class="line">    ├── src</div><div class="line">    ├── tests</div><div class="line">    └── tools</div></pre></td></tr></table></figure>
<p>以上可以看出android系统的源码是非常庞大而复杂的，源码研究是一项艰苦而持久的任务。世上无难事, 只要肯放弃, 下面我们看点轻松的好理解的内容：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">./packages/</div><div class="line">├── apps                    应用程序库</div><div class="line">├── experimental            实验性的库（打印服务，bug汇报，通知，RPC等）</div><div class="line">├── inputmethods            输入法</div><div class="line">├── providers               四大组建之一Provider的系统自带模块</div><div class="line">├── screensavers            屏保</div><div class="line">├── services                系统服务（电话服务）</div><div class="line">└── wallpapers              壁纸</div></pre></td></tr></table></figure>
<p>有了以上的准备，阅读起源码来就心里有数，想要找什么代码也有了大致的搜索范围。<br>下面特别指出一些库的位置，有兴趣的可自行阅读：  </p>
<ul>
<li>系统C库 bionic</li>
<li>媒体库  frameworks/av/media</li>
<li>图形显示库  frameworks/native/services/surfaceflinger</li>
<li>网络引擎库  external/webp, external/webrtc</li>
<li>3D图形库  frameworks/native/opengl</li>
<li>SQLite  Java layer framworks/base/core/java/android/database, C++ layer external/sqlite</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲述Android源码中目录的含义, 方便各位按图索骥
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】AIDL入门</title>
    <link href="http://blog.hjhjw1991.net/android/2016/04/01/%5BAndroid%E6%95%99%E7%A8%8B%5DAIDL%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.hjhjw1991.net/android/2016/04/01/[Android教程]AIDL入门/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:01:57.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>AIDL,android interface definition language  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>某天，我问谷歌爸爸，在Android中进程之间如何进行通讯？<br>我以为这很简单，我去找到要通讯的对象进程，然后建立连接，直接通讯。<br>然而谷歌爸爸说，不行，你这么做不安全，你崩掉了可能让人家也崩掉，锅不是这么甩的。<br>我问谷歌爸爸，那怎么办？<br>谷歌爸爸说，我给你工具，我给你通道，你给我间接地来，我保证你们互不影响。<br>工具在哪？叫什么名字？<br>工具在SDK里，有AIDL，Binder，Messenger，Service，需要什么用什么<br>怎么用？<br>自己看文档<br>看不懂怎么办？<br>边看边写<br>写了还不懂怎么办？<br>考虑改行吧<br>哦  </p>
</blockquote>
<p><img src="/images/blogs/aidl-basic.png" alt="aidl">  </p>
<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p>在Android中，进程之间是不能直接通讯的，他们也没有公共数据区域，但我们实实在在地需要进程间通讯，怎么办呢？Android为我们提供了四种进程间通讯的方式，正好对应四种基本应用程序组件：Activity, Content Provider, Broadcase, Service.  </p>
<ul>
<li>Activity可以跨进程调用其他的Activity  </li>
<li>Content Provider以形似DBC(database connector)的方式访问其他应用程序的数据  </li>
<li>Broadcast以发送广播的方式唤起对应进程  </li>
<li>Service以AIDL方式访问其他应用程序的数据  </li>
</ul>
<p>AIDL是一种IPC(Inter-Process Communication)方式，是C/S结构，如果接触过Java中RPC框架(例如hessian)，可以很快理解这种方式。  </p>
<p>AIDL可以算是一种DSL(Domain Specific Language)。Android中一个进程不允许直接访问另一个进程的内存数据，他们必须要将数据分解(parcel)成操作系统可以识别的最基本的数据类型之后进行传输。AIDL就负责这一块。  </p>
<p>与所有技术一样，只有在需要的时候才考虑AIDL，因为跨进程通讯是有代价的。那么什么时候用AIDL呢？  </p>
<ul>
<li>如果你<strong>只需要IPC</strong>，不需要多线程，你应该考虑Android提供的<strong>Messenger</strong>机制</li>
<li>如果你还要<strong>多线程</strong>，但是不需要多个应用程序并发进行IPC，你应该考虑Android提供的<strong>Binder</strong>机制(特化的AIDL)</li>
<li>如果你需要<strong>多个应用程序并发IPC</strong>，还需要多线程处理，你应该考虑使用AIDL</li>
</ul>
<p>那么，AIDL怎么写，怎么用？其实一句话懂的人就懂了：AIDL就是RPC中的服务接口。<br>如下图示(绿色虚线框为服务端代码，蓝色虚线框为客户端代码)：<br><img src="/images/blogs/aidl-call.png" alt="aidl-call"></p>
<p>假设我们的应用A需要自己能被别的应用调用和访问，不妨假设调用者为应用B。这样被访问的一方，就是提供服务的一方，即C/S中的S，而访问的一方就是客户端C。<br>我们需要在应用A中和应用B中都定义AIDL，并且在应用A中实现AIDL接口。<br>如果A不实现AIDL，是没法以AIDL的方式被调用的。这很好理解，你想跟别人对话，也要看别人愿不愿意跟你对话，对吧。  </p>
<p>Android SDK中aidl工具会将<code>.aidl</code>文件加入一些东西(比如自动加入抽象静态内部类<strong>Stub</strong>)，转换为同名的<code>.java</code>文件以供使用。<br>Eclipse和Android Studio都可以调用aidl工具将你定义的<code>.aidl</code>文件转换成<code>.java</code>。<br>AIDL文件中可以引用其他AIDL文件定义的接口，但不能直接引用<code>.java</code>中定义的接口。<br>但是！有能力的程序员完全可以自己写<code>.java</code>文件，完全手工完成接口定义。  </p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>继续沿用上一节末尾提到的应用A和应用B，这里为了简化场景，假设A是某个Application中负责远程计算的Service，运行在独立的进程中，B是这同一个Application中负责业务逻辑的模块，需要调用A来进行远程计算。  </p>
<p>在具体使用的时候，需要结合具体情境给出回调方式以获取服务实例，这里以使用Service为例，它自带onBind回调，我们只需要实现这个回调返回给客户端一个实例。  </p>
<p>当获得了服务端的实例之后就可以直接使用这个对象了。  </p>
<p>如下图所示：</p>
<p><img src="/images/blogs/aidl-instance.png" alt="aidl-instance"></p>
<p>由于画图技能没点，该图讲得不好，最好结合自己写的aidl和对应生成的<code>.java</code>文件来看。  </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>aidl自动生成的文件中，使用抽象类Stub帮助你从外部定义服务端的实现，系统通过Stub和asInterface等存在于该生成文件中的预定义的方法来实现调用。  </p>
<p>打开<code>.java</code>文件，看看它的所有新增的方法和成员，可以帮助深入理解aidl的设计思想和运行原理。它里面有非常神奇的一些用法，例如抽象内部类Stub实现了存在于其外部的接口（它自身！），然后利用Proxy代理使用服务端实现。  </p>
<p>客户端获取到的实际上是远程服务的代理。而实际工作，是在服务端的代理中调用方法，以及代理前后调用onTransact进行序列化和反序列化。  </p>
<p>以下是示意图，写下去涉及的东西就多了，而且我也没有仔细阅读，这里就不误人子弟了，强烈建议大家自己去阅读感兴趣的部分。  </p>
<p><img src="/images/blogs/aidl-axiom.png" alt="aidl-axiom"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先上最重要的结论：<strong>在自带的<code>Binder</code>机制和<code>Messenger</code>机制无法解决你的多线程、多应用间通讯的场景时，使用aidl</strong>  </p>
<p>aidl提供了由系统支持的类RPC的进程间通讯方式。与直接通信的区别在于，系统可以借助aidl的定义来找到实现该aidl的组件，而且看起来好像并没有切换出当前进程环境(事实上是系统帮你把远程服务端运行起来了，aidl的执行都是在服务端，这就是为什么你在使用完毕的时候需要解绑服务端进程以避免内存泄漏)，使得客户端使用较为流畅无痕。隔离客户端和服务端，两者只需要面向接口编程，客户端可以完全不关心服务端的行为。  </p>
<p>aidl的缺点是传输的数据只支持Java内建基本数据类型(而且<code>short</code>除外)、<code>String</code>、<code>CharSequence</code>、只包含以上支持类型的List和Map，以及实现了<code>Parcelable</code>(一个类似于<code>Serializable</code>的接口，但强制要求实现类必须实现反序列化生成器<code>public static final Parcelable.Creator&lt;T&gt; CREATOR</code>和序列化生成器<code>writeToParcel</code>，其中<code>CREATOR</code>虽然是自己写的成员变量，但是名称和修饰词都不能更改)接口的类型。  </p>
<p>在<code>List</code>和<code>Map</code>这种用到泛型的情况下，需要指明List和Map是作为<code>in/out/inout</code>哪种方式使用的。网上某视频说在传输数据的时候会有一个打包和解包的过程，而这个过程代价非常大，说是出于节约资源的考虑才要求指明是作为输入还是作为输出。这或许也是考虑之一，但我更倾向于认为是出于保持里氏代换原则的考虑，毕竟这里如果你没声明的话会报编译错误，而一般来说影响性能的行为只会报警告，而不是错误。而且看到<code>in/out</code>这种词语，我很容易就联想到我的另一篇blog<a href="http://blog.hjhjw1991.net/blog/2016/02/25/Java%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">Java中的协变和逆变</a>  </p>
<p>另外，如果使用<code>Parcelable</code>接口传递自定义的数据对象，由于传递对象的时候序列化之后本质上是二进制流，那实现相应的序列化和反序列化的方法时，成员顺序必须完全一致，而且客户端和服务端都需要有完全一致的该自定义类文件。也是由于底层序列化会把<code>short</code>类型强行提升为<code>int</code>型，所以就直接不支持<code>short</code>类型的序列化 。  </p>
<p>对于aidl来说，它不直接识别java的源文件，所以需要给出自定义类的相应的aidl描述。当然aidl中对于实体的描述比接口描述要简单得多，只需要直接声明实体就行了。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android开发艺术探索》<br><a href="http://blog.csdn.net/luoshengyang/article/details/6642463" target="_blank" rel="external">Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析</a><br><a href="http://blog.csdn.net/coding_glacier/article/details/7520199" target="_blank" rel="external">Android Binder机制</a><br><a href="http://blog.csdn.net/toyuexinshangwan/article/details/8640709" target="_blank" rel="external">Android跨进程通信的四种方式</a><br><a href="http://blog.csdn.net/thegameisfives/article/details/14000941" target="_blank" rel="external">Android ： 基本空间划分 ＆ IPC框架分析</a><br><a href="http://www.cnblogs.com/a284628487/p/3187320.html" target="_blank" rel="external">Android 内核–Binder架构分析</a><br><a href="http://blog.csdn.net/stonecao/article/details/6425019" target="_blank" rel="external">Android AIDL使用详解</a><br><a href="http://www.cnblogs.com/feike/archive/2013/01/08/2851833.html" target="_blank" rel="external">Binder与AIDL服务</a>  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲AIDL进程间通讯
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="教程" scheme="http://blog.hjhjw1991.net/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
      <category term="面试" scheme="http://blog.hjhjw1991.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】3-Longest Substring Without Repeating Characters</title>
    <link href="http://blog.hjhjw1991.net/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D3-Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>http://blog.hjhjw1991.net/leetcode/2016/03/21/[Leetcode题解]3-Longest Substring Without Repeating Characters/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Hash Table,Two Pointers]  </p>
<p>在字符串中找到最长的无重复字符的子串，返回它的长度。<br>这个题的题设要求非常简单，只要出现重复的字符就不行，所以很容易可以想到Hash Table。<br>HashTable的做法是，从左到右扫描并存储见过的字符，如果遇到该字符已经见过了，则记录当前table容量并与当前最大长度求max，并从左到右删除到该字符为止的已经见过的字符。根据题意可以假设最大长度至少为1，且不会大于26.当原字符串为空时最大长度为0.  </p>
<p>从上面HashTable的解法描述中可以提取Two Pointers解法，即设置同向指针left和right，并初始化boolean数组用以表示是否参与当前最长子串计算，boolean数组下标是字符，其作用可以用HashMap代替。<br>初始left和right指向字符串起点，如果boolean数组right所指向的字符没有参与，则设置为参与并右移，否则计算right-left获得当前长度，并与当前最大长度求max，这之后left左移恢复状态，直到left所指向的字符与right所指向的字符一致。  </p>
<p>Two Pointers解法比HashTable解法好的一点是，用boolean数组代替了HashMap，这在运行性能上会好一些，但理论时间复杂度没变，都是O(N)。考虑到隐性假设字符为ASCII字符，范围可控，使用boolean数组做更合适。如果是任意字符，则应该使用HashTable。  </p>
]]></content>
    
    <summary type="html">
    
      最长无重复字符的子串
    
    </summary>
    
      <category term="leetcode" scheme="http://blog.hjhjw1991.net/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】2-Add Two Sum</title>
    <link href="http://blog.hjhjw1991.net/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D2-Add-Two-Numbers/"/>
    <id>http://blog.hjhjw1991.net/leetcode/2016/03/21/[Leetcode题解]2-Add-Two-Numbers/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Math,Linked List]  </p>
<p>两个以链表形式存储的非负整数，每个节点是一个数字，并且按倒序表示，低位在前高位在后，要求返回同样形式表示的和。  </p>
<p>这是一个非常典型的数学基本操作和链表基本操作题，别看它难度不大，多做这样的题可以让你在以后做基本操作的时候得心应手，而且几乎不会出错。  </p>
<p>解题方式和注意点也非常典型。<br>加法器的基本实现思路是从低位到高位按位相加并保持进位。<br>正确性上需要注意对最高位进位的处理，链表上需要对空输入和剩余位处理。  </p>
<p>正文已经结束，我最后啰嗦几句，这个题简单在题设，我们自己可以试着把限制条件一一去掉以接近更真实的情况，例如正序表示，考虑负数，考虑小数。事实上Leetcode上就有变形题。<br>处理链表的时候，除了基本的指针操作以外，特别要注意头节点和尾节点处理，以及空链表和单节点链表这两种特殊情况。<br>指针操作也是一系列涉及指针的问题的基本操作，所以需要熟练掌握，除了单链表以外，还有双向链表，循环链表，十字链表，Dancing链表，数组模拟链表。在树结构处理的时候，经常就会用到多指针链表，例如Btree，Trie。  </p>
]]></content>
    
    <summary type="html">
    
      填坑, 两数求和
    
    </summary>
    
      <category term="leetcode" scheme="http://blog.hjhjw1991.net/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】1-Two Sum</title>
    <link href="http://blog.hjhjw1991.net/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D1-Two-Sum/"/>
    <id>http://blog.hjhjw1991.net/leetcode/2016/03/21/[Leetcode题解]1-Two-Sum/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Array,Hash Table]</p>
<p>填坑第一作，坑在<a href="http://blog.hjhjw1991.net/opinion/2015/10/15/开坑-Leetcode题解/">这里</a><br>以后都假设大家都看过题目了，我会大略说一下题意，注意点，解法，但是就不搬运题目了。  </p>
<p>Two Sum是一个经典的数列问题，它可以直指高斯消元法。本题是一个最简单的情况，给定一个数列和一个目标，在数列中找到两个数，使得他们的和等于目标，返回这两个数的序号（从0开始计）。  </p>
<p>虽然是简单的题，但我说话比较啰嗦，就说一下我的想法。此题乃至一般题，首先想到判空，如果数列中不存在目标数怎么处理。因为是在Leetcode上可以无限试，特别是现在开了模拟coding run之后，所以完全可以构造一个用例看看Leetcode对于这种情况他是怎么处理的。然后考虑多个解的情况，怎么处理。我做的时候，他题目中有很强的假设，说有且仅有一个解。如果在面试的过程中遇到这种题，需要向面试官明确以上条件，不但可以简化实现，同时也可以反映出你的思路，一般来说面试时很少遇到这么简单的题，如果遇到那么你在别的方面的表现可能就是你取胜之处。  </p>
<p>考虑了不存在的情况后，考虑正常情况。可以有几种解法：  </p>
<h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>最容易想到暴力解法，固定一个元素，遍历其余元素，找到满足条件的就返回。这种解法最坏情况是N^2时间复杂度。但是这是帮助自己理清思路的好方法，特别是当问题较为复杂的时候，如果有暴力解法能写出来，再在这个基础上优化也是好的。在面试的时候，面试官对于这种优化行为也是较为欣赏。怎么说呢，暴力解法就像是及格线，需要熟练掌握，但是未必需要亮出来。  </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap总体上跟暴力解法相似，但是进行了优化。我们在暴力解法中，事实上有过很多重复计算，如果能把这些计算保存下来必然可以减少复杂度，HashMap就是在这种情况下想到的。  </p>
<p>解法是先预处理，将数组每个元素相对于目标的差值及其对应的下标存入Map，时间O(N)。<br>然后从头开始看每个元素是否都已经存在于Map中，这一步是N*O(1)。如果存在则说明找到解，可以返回序号。<br>需要注意的是判断两个下标是否指向同一个元素，如果是则跳过。<br>总体复杂度是O(2N)  </p>
<h2 id="Two-Pointer"><a href="#Two-Pointer" class="headerlink" title="Two Pointer"></a>Two Pointer</h2><p>有没有更巧妙的方式呢？有，就是Two Pointer。但是Two Pointer的解法依赖于有序数组，而题目中没有这个信息，所以这种算法在这个题不一定是最好的，但是这是一种非常巧妙的思想，可以在一遍扫描就完成求解。  </p>
<p>Two Pointer的基本思路，就是在有序数组上，左右设置指针，对向移动，当指针相遇则算法结束。无比经典的快速排序就是基于Two Pointer和Recursive的方式。  </p>
<p>对于求和，不妨先假设数组升序，那么设置left和right指针，对向移动，看left和right指向的数之和是否等于目标，如果是则返回，如果大了则right指针移动，小了则left指针移动，指针相遇说明无解。这个算法的正确性可以很简单地证明：假设相遇时存在解，那么可以假设至少其中一个指针曾停留在其中一个解上，不妨假设是left指针在较小的解上，此时如果right指针在另一个解左边，则和小于目标，不可能移动right，而right在另一个解的右边时则和大于目标，应当移动right，必然到达另一个解，与假设矛盾。  </p>
<p>至此思路清晰，将数组排序，然后使用双指针跑一遍即可得到解，总体时间复杂度是O(logN+N)，如果原本就有序则可更优。<br>需要注意的是排序前保留序号和数值对应关系，同时注意可能有重复元素，所以需要以链表方式存储。  </p>
<p>Two Pointer算法可以扩展到含有重复元素的数组，可以扩展到双向链表，可以修改为同向指针应用于链表有无环判断，可以扩展到Three Pointers，可以扩展到适用于N Sum问题，可以结合回溯法解最优化问题。可以说是非常简洁有用的算法。  </p>
]]></content>
    
    <summary type="html">
    
      填坑第一作，从简单的开始
    
    </summary>
    
      <category term="leetcode" scheme="http://blog.hjhjw1991.net/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava初探</title>
    <link href="http://blog.hjhjw1991.net/android/2016/03/18/RxJava%E5%88%9D%E6%8E%A2/"/>
    <id>http://blog.hjhjw1991.net/android/2016/03/18/RxJava初探/</id>
    <published>2016-03-17T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>技术世界真是日新月异，学会的技术还没有机会使用，就已经过时了。学而时习之，温故而知新。  </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      RxJava是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，它使用观察者模式使程序代码的逻辑更清晰--施工中
    
    </summary>
    
      <category term="android" scheme="http://blog.hjhjw1991.net/categories/android/"/>
    
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目</title>
    <link href="http://blog.hjhjw1991.net/tips/2016/03/08/%E6%9C%AA%E8%83%BD%E5%90%8C%E6%AD%A5%E8%8B%B9%E6%9E%9C%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8D%E5%86%8D%E8%A2%AB%E6%8E%88%E6%9D%83%E4%BD%BF%E7%94%A8%E5%9C%A8%E6%AD%A4%E8%8B%B9%E6%9E%9C%E4%B8%8A%E8%B4%AD%E4%B9%B0%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.hjhjw1991.net/tips/2016/03/08/未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以前用pp助手的时候遇到过这个问题，它破解下载app的方法是用某个别的AppleID购买和下载应用，这样子只能通过它这个软件来更新，无法通过官方App Store更新，而且很大几率出现安装失败、白图标等问题。  </p>
<p>最近手机迁移从旧手机的备份恢复到新手机（别人用过）上，结果又出现部分重叠的app购买ID没有恢复，AppleID不一致的情况，导致无法同步。  </p>
<p>解决方法是卸载这些应用，用一致的AppleID重新购买和下载，但是一直纠结于卸载应用会删除所有数据，搜索是否有保存数据更换ID的方法未果。  </p>
<p>下载itools查看手机应用可以看到每个应用的购买ID，把不一致的卸载再下载重装即可。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://zhidao.baidu.com/link?url=hapvL1G--ej8gwHRI_e6Zh18d7urfv83UzZapeWqT34VEEkQN8vREF6cVPHjf2jBGG4NPTmBp5O9fxJMSrYBRSjzU-qjj8-SNE641ZxAheC" target="_blank" rel="external">未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目</a>  </p>
]]></content>
    
    <summary type="html">
    
      itunes同步的时候提示未能同步，点击商店-&gt;授权也没用，原因是手机上存在不同的AppleID所购买内容，需要都授权才行
    
    </summary>
    
      <category term="tips" scheme="http://blog.hjhjw1991.net/categories/tips/"/>
    
    
      <category term="ios" scheme="http://blog.hjhjw1991.net/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Git中使用cherry-pick跨分支应用commit</title>
    <link href="http://blog.hjhjw1991.net/blog/2016/03/08/Git%E4%B8%AD%E4%BD%BF%E7%94%A8cherry-pick%E8%B7%A8%E5%88%86%E6%94%AF%E5%BA%94%E7%94%A8commit/"/>
    <id>http://blog.hjhjw1991.net/blog/2016/03/08/Git中使用cherry-pick跨分支应用commit/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>git-cherry-pick - Apply the changes introduced by some existing commits    –from git-scm.com</p>
</blockquote>
<p>我们知道在git中对分支操作的命令有<code>merge</code>，<code>rebase</code>和<code>cherry-pick</code>，<code>merge</code>是两条分支直接合并，<code>rebase</code>是追溯到共同祖先之后逐个应用当前分支的commit到所选择的基分支上，可以通过<code>-i</code>选项进行对当前分支的交互式变基，用以修改提交历史，git中建议以<code>rebase</code>方式代替普通的<code>merge</code>。  </p>
<p><code>cherry-pick</code>在英语中是精挑细选的意思，功能也正如名字一样，是<strong>选择一些commit，将其应用到当前分支上</strong>。可以想见，其应用的主要场景是将已经提交的commit进行搬动</p>
<h2 id="场景1-引入某个commit新加入的功能但不改变分支历史"><a href="#场景1-引入某个commit新加入的功能但不改变分支历史" class="headerlink" title="场景1 引入某个commit新加入的功能但不改变分支历史"></a>场景1 引入某个commit新加入的功能但不改变分支历史</h2><p>直接使用<code>cherry-pick</code>即可，这样不会更改被引入分支的历史<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git cherry-pick &lt;commit hash&gt;</div></pre></td></tr></table></figure></p>
<p>默认情况下会创建一个新的提交，类似于<code>merge</code>。可通过选项关闭。  </p>
<h2 id="场景2-保持history清晰的情况下将某些提交完全移动到别的分支上"><a href="#场景2-保持history清晰的情况下将某些提交完全移动到别的分支上" class="headerlink" title="场景2 保持history清晰的情况下将某些提交完全移动到别的分支上"></a>场景2 保持history清晰的情况下将某些提交完全移动到别的分支上</h2><p>例如，我想把以下分支  </p>
<p><table width="200" border="1" cellspacing="1" cellpadding="1"></table></p>
<p><tbody><tr><td></td></tr></tbody></p>
<p><pre style=""><strong><br>A-B  master<br>   \<br>    C-D-E-F-G topic<br></strong></pre><br>中的D，F commit移动到master分支，而保持其他commit不变，就像这样  </p>
<p><table width="200" border="1" cellspacing="1" cellpadding="1"><tbody></tbody></table></p>
<p><tr><td></td></tr></p>
<p><pre style=""><strong><br>A-B-D-F  master<br>       \<br>        C-E-G topic</strong></pre></p>
<p><br>那么，思路是将D，F 用<code>cherry-pick</code>应用到<code>master</code>分支上，然后将<code>topic</code>分支对<code>master</code>分支变基。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout master  </div><div class="line">$ git cherry-pick D  </div><div class="line">$ git cherry-pick F  </div><div class="line">$ git checkout topic  </div><div class="line">$ git rebase master</div></pre></td></tr></table></figure>
<h2 id="EXAMPLES-from-official-guide"><a href="#EXAMPLES-from-official-guide" class="headerlink" title="EXAMPLES from official guide"></a>EXAMPLES from official guide</h2><p><code>git cherry-pick master</code><br>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.  </p>
<p><code>git cherry-pick ..master</code><br><code>git cherry-pick ^HEAD master</code><br>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.  </p>
<p><code>git cherry-pick maint next ^master</code><br><code>git cherry-pick maint master..next</code><br>Apply the changes introduced by all commits that are ancestors of <code>maint</code> or next, but not <code>master</code> or any of its ancestors. Note that the latter does not mean <code>maint</code> and everything between <code>master</code> and <code>next</code>; specifically, <code>maint</code> will not be used if it is included in <code>master</code>.  </p>
<p><code>git cherry-pick master~4 master~2</code><br>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.  </p>
<p><code>git cherry-pick -n master~1 next</code><br>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.  </p>
<p><code>git cherry-pick --ff ..next</code><br>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.  </p>
<p><code>git rev-list --reverse master -- README | git cherry-pick -n --stdin</code><br>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.  </p>
<p>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git cherry-pick topic^             (1)</div><div class="line">$ git diff                           (2)</div><div class="line">$ git reset --merge ORIG_HEAD        (3)</div><div class="line">$ git cherry-pick -Xpatience topic^  (4)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>apply the change that would be shown by <code>git show topic^</code>. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</p>
</li>
<li><p>summarize changes to be reconciled</p>
</li>
<li><p>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</p>
</li>
<li><p>try to apply the change introduced by <code>topic^</code> again, spending extra time to avoid mistakes based on incorrectly matching context lines.</p>
</li>
</ul>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="http://blog.csdn.net/duola_rain/article/details/43408733" target="_blank" rel="external">(转)Git cherry-pick 和 rebase 的混合用法</a><br><a href="http://git-scm.com/docs/git-cherry-pick/" target="_blank" rel="external">官方文档 - git-cherry-pick</a></p>
]]></content>
    
    <summary type="html">
    
      假设我有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们想增加v3.0中某几个commit的功能到v2.0中，这时候cherry-pick就派上用场了
    
    </summary>
    
      <category term="blog" scheme="http://blog.hjhjw1991.net/categories/blog/"/>
    
    
      <category term="git" scheme="http://blog.hjhjw1991.net/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>记一次uwsgi故障排除</title>
    <link href="http://blog.hjhjw1991.net/blog/2016/03/02/%E8%AE%B0%E4%B8%80%E6%AC%A1uwsgi%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4/"/>
    <id>http://blog.hjhjw1991.net/blog/2016/03/02/记一次uwsgi故障排除/</id>
    <published>2016-03-01T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我在本地调试了一个flask应用，本地跑得好好的，部署到远程centos6 32位vps上就出了问题。<br>问题非常隐蔽，因此也走了不少弯路，甚至最后都不知道是哪一步起了关键作用。因此记一下。</p>
</blockquote>
<h2 id="应用升级使用sqlite3数据库，引起访问出错"><a href="#应用升级使用sqlite3数据库，引起访问出错" class="headerlink" title="应用升级使用sqlite3数据库，引起访问出错"></a>应用升级使用sqlite3数据库，引起访问出错</h2><p>应用采用nginx+uwsgi+flask的结构  </p>
<p>应用最新版本中引入了sqlite3数据库，就这一步出了问题。在要访问数据库的时候返回<code>502  bad gateway</code>，查uwsgi日志，记录提示pysqlite中出了错，找不到symbol<code>sqlite3_stmt_readonly</code>什么的(对了这个信息需要在flask开启debug模式才会被记录下来)。查了vps的sqlite3，是3.6版本，我开发机是3.8版本，在以<code>undefined symbol sqlite3_stmt_readonly</code>为关键词反复搜索信息的过程中知道了这个标志是3.7以后的版本才有的，猜想是不是sqlite版本问题。找到了pysqlite的github仓库中一个<a href="https://github.com/ghaering/pysqlite/issues/85" target="_blank" rel="external">issue</a>，也是同样的错误。根据下面开发者的回答进行了操作，然而并没有什么用。  </p>
<p>又有说没有安装uwsgi的python插件，我用pip和yum都装了一下，也没有用。(<code>pip install uwsgi</code>, <code>yum install uwsgi-plugin-python</code>)  </p>
<p>最后还弄出新的问题: 包_sqlite找不到。显然是包管理出问题了。中间各种麻烦，一气之下将python2.7.11源码下载编译安装，然后编译安装了easy_setup和pip，幸好自己以前写过教程。然后重新安装了应用的requirements，幸好之前有更新requirements。  </p>
<p>这下出现了新问题，所有的python位置和版本都是2.7.11了，但重启uwsgi后竟然直接找不到flask包，一看发现日志记录的python版本还是之前的2.7.8，这个锅看来uwsgi非背不可了。又是一阵折腾python更新和uwsgi配置未果(包括设置虚拟python环境)。  </p>
<h2 id="解决问题的关键步骤-编译安装最新版uwsgi"><a href="#解决问题的关键步骤-编译安装最新版uwsgi" class="headerlink" title="解决问题的关键步骤:编译安装最新版uwsgi"></a>解决问题的关键步骤:编译安装最新版uwsgi</h2><p>后来想起来，特么这个uwsgi不是我装的啊，我当初下载的是2.0.10版本，这个运行的是2.0.12版本，这货好像是vps自带的！被vps坑过的我表示，这锅你就背了吧！而且当初还是在root下搞的uwsgi，正好一并改过来。  </p>
<p>下载了uwsgi2.0.12版本的源码，进入源码目录，什么配置都不改<br><code>python uwsgiconfig.py --build</code><br>安装成功。(如果失败或者提示权限问题，就把涉及到的文件权限改成自己的)<br><code>python setup.py install</code><br>这一步是手动安装python uwsgi 包<br>然后设置bin，将<code>/usr/local/bin/uwsgi</code>软连接到python包里面那个uwsgi，别忘了把<code>/usr/local/bin</code>放在环境变量<code>$PATH</code>的最前面以优先载入  </p>
<p>好了，试运行一下uwsgi，检查正常运行，版本号无误。  </p>
<p>查看应用的config文件，没有变动，运行uwsgi，访问应用，可以访问，访问数据库，可以访问，查看uwsgi日志，没有错误。完美。感动哭。  </p>
<p>一声不吭正常运行的nginx目睹了整个过程。谢天谢地幸好你一直正常运行。  </p>
<h2 id="意外收获"><a href="#意外收获" class="headerlink" title="意外收获"></a>意外收获</h2><p>中间有些意外收获。  </p>
<ol>
<li><p>先是编译的uwsgi-2.0.10的源码，安装好之后，运行提示我找不到应用，找不到python，逗我呢？后来一想原先的版本好像是2.0.12，不管是不是vps自带的，我自己下载编译总可以吧？于是这么做之后就好了  </p>
</li>
<li><p>后来觉得<code>sudo nginx</code>有点危险，查看nginx发现普通用户有运行权限，切换普通用户运行结果提示我<code>bind() 0.0.0.0:80 permission denied</code>，确信没有应用在用那个端口，一查才知道linux要求1024以下的端口都必须以sudo级别才可以绑定。老老实实改回sudo。按理说conf里配置8080端口应该也可以，但还是以后再说吧，如果有多个应用了再来配置别的访问端口。  </p>
</li>
<li><p>nginx的conf里面可以直接配置uwsgi_param传给uwsgi，因此如果要配置多个应用，那么就要在<code>conf/nginx.conf</code>而不是单独的配置文件(对uwsgi来说,单独的配置文件就是用参数指定的xml或者ini格式的配置文件)中指定pythonpath和callable之类的参数。  </p>
</li>
<li><p>nginx和uwsgi都是服务端程序，不同的是nginx主要负责前端显示，uwsgi主要负责后端数据处理。  </p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      更新flask应用版本后，uwsgi运行出错提示sqlite3_stmt_readonly未知标志位
    
    </summary>
    
      <category term="blog" scheme="http://blog.hjhjw1991.net/categories/blog/"/>
    
    
      <category term="vps" scheme="http://blog.hjhjw1991.net/tags/vps/"/>
    
      <category term="uwsgi" scheme="http://blog.hjhjw1991.net/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>Java中的协变和逆变</title>
    <link href="http://blog.hjhjw1991.net/blog/2016/02/25/Java%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
    <id>http://blog.hjhjw1991.net/blog/2016/02/25/Java中的协变和逆变/</id>
    <published>2016-02-24T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>WARNING: 以下内容涉及强烈的个人理解和偏见，限于作者所知和笔力，不保证词可达意和正确性，请读者注意</p>
</blockquote>
<p>————————————————-手工分割机———————————————–  </p>
<blockquote>
<p>马者，所以名形也；白者，所以名色也。名形者非名色也。故曰：白马非马。求马，黄黑马皆可致。求白马，黄黑马不可致。……故黄黑马一也，而可以应有马，而不可以应有白马，是白马之非马审矣。马者，无去取于色，故黄黑皆所以应。白马者有去取于色，黄黑马皆所以色去，故惟白马独可以应耳。无去者，非有去也。故曰：白马非马.马故有色，故有白马。使马无色，由马如己耳。安取白马？故白者，非马也。白马者，马与白也，白与马也。故曰：白马非马也。  –公孙龙</p>
</blockquote>
<p>开宗先明义. 简介中提到里氏代换原则，先温习一下什么是里氏代换：  </p>
<p><em>里氏代换原则(Liskov Substitution Principle LSP): 任何基类可以出现的地方，子类一定可以出现.</em>  </p>
<p>里氏代换原则放在返回值上，就是返回基类的地方，也可以返回子类。放在参数值上，就是接受基类的函数，也可以接受子类。对于持有返回值的变量来说，就是声明为子类的变量可以被声明为父类的变量代替。对于函数本身来说，就是接受子类的函数可以被接受基类的函数代替。这里可以看出，里氏代换原则描述的事实上是对象。  </p>
<p>再看看所谓<strong>“协变(Covariance)”</strong>和<strong>“逆变(Contravariance)”</strong>这两个拗口的中文术语，其英文定义是什么：  </p>
<blockquote>
<p>Within the type system of a programming language, a typing rule or a type constructor is:</p>
<ul>
<li><strong>covariant</strong> if it preserves the ordering of types (≤), which orders types from more specific to more generic;  </li>
<li><strong>contravariant</strong> if it reverses this ordering;  </li>
<li><strong>bivariant</strong> if both of these apply (i.e., both <code>I&lt;A&gt;</code> ≤ <code>I&lt;B&gt;</code> and <code>I&lt;B&gt;</code> ≤ <code>I&lt;A&gt;</code> at the same time);  </li>
<li><strong>invariant</strong> or <strong>nonvariant</strong> if neither of these applies.<br>–  <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science" target="_blank" rel="external">wikipedia</a>#Formal_definition)  </li>
</ul>
</blockquote>
<p>英文定义不好理解没关系，这里还有更不好理解的中文定义：  </p>
<blockquote>
<p><strong>协变(covariant)</strong>:当委托方法的返回类型具有的派生程度比委托签名更大时，就称为协变委托方法。因为方法的返回类型比委托签名的返回类型更具体 ，所以可以对其进行隐式转换。这样该方法就可以用作委托。协变使得创建可被类和派生类同时使用的委托方法成为可能。  </p>
<p><strong>逆变(contravariant)</strong>:当委托方法签名具有一个或多个参数，并且这些参数的类型派生自方法参数的类型时，就称为逆变委托方法。因为委托方法签名参数比方法参数更具体，因此可以在传递给处理程序方法时对它们进行隐式转换。这样，当创建可由大量类使用的更加通用的委托方法时，使用逆变就更为简单了。  </p>
<p>– 以上出自百度百科<a href="http://baike.baidu.com/link?url=W0J1-WTM1SjfSlVwsfkeESzHcT1NyRIS5GKtnUxB57WmF89Qv74QyDdFqx5vbx9rdc4e69xDO_ugFE54Fx9Zv_" target="_blank" rel="external">协变</a> <a href="http://baike.baidu.com/subview/302541/5594455.htm#viewPageContent" target="_blank" rel="external">逆变</a></p>
</blockquote>
<p>中文定义不好的地方在于，它高度概括，但对于想要从定义来理解的人可能毫无帮助。让我想起我那些线性代数教材。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在刚知道这两个概念的时候想必也对它们的含义和作用有过猜测，可能也像我一样相当糊涂，看过定义和网上各种中文的解释说明之后可能更加糊涂了。  </p>
<p>要理解这两个概念，还是从根源说起。<em>这一段为了方便自己回忆，会非常啰嗦，如果想快速理解的话直接看<a href="#lizi">例子</a>。</em>   </p>
<p>covariance也可被译作<code>协方差</code>，没错就是统计分析了里面那个。covariance根源于数学和物理领域，在wiki上的词条说它是用来描述两个变量变化时，它们之间的<strong>联系</strong>，统分就是采纳这个含义来描述统计量之间样本差异的联系。<br>协变和逆变放在一起，那应该可以猜测是一对”逆运算”或者说”反义词”，事实上确实是，只是根据需要，在编程语言中的使用位置不同。  </p>
<p>接下来会用我擅长的”只有我自己可以理解的列举”来解释我对这两个概念的理解，基于wiki的形式化定义。  </p>
<ul>
<li>首先有两个东西<code>A</code>和<code>B</code>，然后有某种过程<code>process</code>，不失一般性，假设存在偏序关系<code>A&lt;=B</code>，且具有传递性、自反性、非对称性.  <ul>
<li>如果有<code>process(A)&lt;=process(B)</code>，就说<code>这种偏序关系</code>在<code>这个process</code>上是协变的。  </li>
<li>如果有<code>process(B)&lt;=process(A)</code>，就说<code>这种偏序关系</code>在<code>这个process</code>上是逆变的。  </li>
</ul>
</li>
</ul>
<p>细心的我发现了我只是把wiki的解释翻译成了中文，而且还缺斤少两。  </p>
<p>事实上看到这里，联系自己熟悉的编程语言(很多编程语言都实现了这种特性)，那么相信你会隐约觉得——“这玩意我好像遇到过?”。你应该遇到过，如果你在声明的时候参数是类型B，但是赋值的时候参数是类型A，或者将A对象赋予给了B类型的变量，前者你遇到了逆变，后者你遇到了协变。  </p>
<p>事实上参考中列出的某篇文章用更通俗的语言解释过这两个概念:  </p>
<blockquote>
<p>“协变”-&gt;”和谐的变”-&gt;”很自然的变化”-&gt;<code>string-&gt;object</code> 协变。<br>“逆变”-&gt;”逆常的变”-&gt;”不正常的变化”-&gt;<code>object-&gt;string</code> 逆变。</p>
</blockquote>
<p>最初让我疑惑之处在于，在所有参考资料中都有举例在函数中协变和逆变的表现，但看起来好像差不多:同样都是声明的父类，传递的子类。这TM有什么区别？  </p>
<p>还是自己姿势不够，应该多学习。另外这个栗子也不好，注意，我要开始举例了。<br><strong>——前方高能——</strong><br>许多地方涉及到协变和逆变，但归根结底它只是一种类型变换规则，所以咱们从类型声明和赋值着手。  </p>
<pre><code>class Parent{}
class Child extends Parent{}

Parent parent;// 也许你想成为一个父(母)亲
parent = new Child();// 但最初，你还只是个孩子。明明是个孩子，却要以家长的形式存在下去，这是协变。里氏代换说，任何孩子都可以成为家长。

Child child;// 但当你是个家长的时候
child = new Parent();// 你无法回复身份，让自己成为一个孩子。至少在Java中不行。这就是说，Java中你没法把更抽象的父类对象直接丢给一个更具体的子类变量。
// C#中把要丢给别人的协变变量用 out来修饰，也就是说，协变的变量可以用它的子类来代替(实际以子类形式存在的对象可以扔给父类形式声明的变量来管理)

IEat&lt;T&gt;{}  //吃
IEat&lt;Parent&gt; iep = new IEat&lt;Parent&gt;();// 作为家长可以吃
IEat&lt;Child&gt; iec = iep;// 作为家长，可以吃得跟孩子一样，这是逆变。里氏代换说，任何子类都可以代替作为参数的父类。
// C#中把这种只能被使用的逆变变量用 in来修饰，也即是说，逆变的变量可以用它的父类来代替(实际以父类形式存在的行为可以让子类形式声明的变量做出)
</code></pre><p>那么，简单一句话，孩子协变成家长，家长逆变成孩子。  </p>
<p>好像这么一说更令人疑惑了，那么还是借助c#的定义再说一遍。可以看到c#用out修饰协变变量，用in修饰逆变变量。对于函数来说，就是in可以逆变，out可以协变。如果把函数C的调用看作<code>A-&gt;C-&gt;B</code>这样的数据流过程，那么可以看到，两个箭头的位置涉及到变型，而里氏代换原则告诉我们，子类对象可以代替父类对象，那么自然可以导出结论：<code>在A和B不变的情况下，如果函数D将C的输入口放大到父类，而输出口缩小到子类，则D可以安全代替C。</code>注意到，以上的描述中已经暗含了逆变和协变的定义。直接看好像是相反的意思，实则不然。<br>我们更具体一点定义D和C，如下:  </p>
<pre><code>CReturn C (CParameter)
DReturn extends CReturn D(DParameter super CParameter)
</code></pre><p>那么我们可以发现，当<code>D&lt;C</code>的时候，<code>DReturn&lt;=CReturn</code>，而且<code>DParameter&gt;=CParameter</code>，即有：  </p>
<ul>
<li><code>D&lt;C</code>-&gt;<code>DReturn&lt;=CReturn</code> 协变  </li>
<li><code>D&lt;C</code>-&gt;<code>DParameter&gt;=CParameter</code> 逆变  </li>
</ul>
<p>协变和逆变可以解释程序语言实现中的许多现象。<br>例如，按以上的理解，<code>List&lt;Object&gt; l = new List&lt;String&gt;()</code>是允许的，因为<code>String</code>是<code>Object</code>的子类，赋值时子类可以协变成父类。<br>事实上，在c#中确实可以(未验证)。<br>然而这句话在Java中无法编译。原因是Java中<code>List</code>接口被定义为泛型类型<code>List&lt;T&gt;</code>，而Java中的泛型类型都是<code>invariant</code>，因此你既不能协变定义泛型变量，也不能逆变使用泛型对象。<br>有人说那不对啊，我可以用<code>List&lt;? extends Object&gt; l = new List&lt;String&gt;()</code>，这不就是协变了吗？事实上，这叫做<code>使用点变型(use-site variance)</code>，即在声明变量的时候告知编译器接受子类型或父类型的参数。<code>extends</code>和<code>super</code>分别对应协变和逆变方式使用。<br>有些语言支持<code>声明点变型(declaration-site variance)</code>，即在该类型的定义中就表明是协变还是逆变，例如C#和Scala，Java不支持。但是Java支持在类型定义中声明 <code>使用点变型</code>的泛型参数，我认为这可以替代<code>声明点变型</code>。<br>有趣的是，以上的例子中，Java是支持<code>class</code>协变的。例如你可以这样写<code>List&lt;String&gt; l = new ArrayList&lt;String&gt;()</code>或者这样写<code>AbstractList&lt;String&gt; l = new ArrayList&lt;String&gt;()</code>。BTW，数组协变也支持，你可以这样做<code>Object[] obj = new String[]</code>.<br>以下是一些验证代码。  </p>
<pre><code>List&lt;Object&gt; list1 = new List&lt;String&gt;();
List&lt;? extends Object&gt; list2 = new List&lt;String&gt;();
List&lt;? super String&gt; list3 = new List&lt;Object&gt;();
List&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();
</code></pre><p>好了，这时候已经涉及到了函数和类型的定义，正如上文所说，函数和类型的定义中是否支持协变和逆变，这个跟具体语言有关，可以从<a href="http://www.cnblogs.com/1-2-3/archive/2010/09/27/covariance-contravariance-csharp4.html" target="_blank" rel="external">协变(Covariance)和逆变(Contravariance)的十万个为什么</a>这篇文章了解到该作者对是否需要、以及什么时候需要协变和逆变的理解。文中提到，当函数返回值是普通类型时，通常以参数逆变、返回值协变为宜。<br>另一种情况，自然是当返回值为涉及泛型的类型时，这时候参数是协变还是逆变，返回值是协变还是逆变，都取决于其使用方式是否类型安全，例子可以看<a href="http://arron-li.iteye.com/blog/673783" target="_blank" rel="external">java泛型通配符-协变与逆变</a>。  </p>
<p>在类型定义的时候，如果一个子类的函数可以比父类的函数接受更抽象的参数，并返回更具体的值，那么这个函数就可以安全替换父类中的同名函数，这就是里氏代换原则的体现，也是<code>参数值逆变，返回值协变</code>的体现。换句话说，通过支持协变和逆变，编译器保证了里氏代换原则不被打破。  </p>
<p>总之，协变和逆变的理解可以总结如下：  </p>
<ul>
<li>是一种<strong>类型变换规则</strong>，在Java中部分支持</li>
<li>存在是为了<strong>“保证里氏代换原则不被打破”</strong>  </li>
<li>协变是子类作为父类做功，逆变是父类作为子类做功，或者可以这么说，<strong>协变是期待一个父类，实际得到子类，逆变是期待一个子类，实际得到父类。哪一个行为被支持，就说哪种变型被支持</strong>。Java中内置部分类型的协变，并用<code>extends</code>和<code>super</code>支持泛型变量的协变和逆变  </li>
<li><strong>函数定义中通常使返回值具有协变性，而使参数具有逆变性</strong>  </li>
<li>函数定义为支持协变和逆变时，将参数值和返回值的类型范围都放大了，但放大方向相反，可以接受比定义更抽象的参数类型，并返回比定义更具体的返回类型  </li>
<li>Java中所有地方都支持内置的协变，但逆变只有在显式声明时才支持  </li>
</ul>
<p><span id="lizi"></span></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>c# 协变</p>
<pre><code>class Mammals{}
class Dogs : Mammals{}

class Program
{
    // Define the delegate.
    public delegate Mammals HandlerMethod();

    public static Mammals MammalsHandler()
    {
        return null;
    }

    public static Dogs DogsHandler()
    {
        return null;
    }

    static void Test()
    {
        HandlerMethod handlerMammals = MammalsHandler;

        // Covariance enables this assignment.
        HandlerMethod handlerDogs = DogsHandler;
    }
}
</code></pre><p>c# 逆变</p>
<pre><code>// Event hander that accepts a parameter of the EventArgs type.
private void MultiHandler(object sender, System.EventArgs e)
{
    label1.Text = System.DateTime.Now.ToString();
}

public Form1()
{
    InitializeComponent();

    // You can use a method that has an EventArgs parameter,
    // although the event expects the KeyEventArgs parameter.
    this.button1.KeyDown += this.MultiHandler;

    // You can use the same method 
    // for an event that expects the MouseEventArgs parameter.
    this.button1.MouseClick += this.MultiHandler;

}
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.2cto.com/kf/201304/205042.html" target="_blank" rel="external">Java 协变性 逆变性 学习笔记 - 2014</a><br><a href="http://www.cnblogs.com/Ninputer/archive/2008/11/22/generic_covariant.html" target="_blank" rel="external">.NET 4.0中的泛型协变和反变 - 2008</a><br><a href="https://www.zybuluo.com/zhanjindong/note/34147" target="_blank" rel="external">再谈对协变和逆变的理解 - 2014</a><br><a href="http://blog.csdn.net/beliefer/article/details/50894265" target="_blank" rel="external">Java泛型的协变</a><br><a href="http://www.cnblogs.com/LoveJenny/archive/2012/03/13/2392747.html" target="_blank" rel="external">深入理解 C# 协变和逆变</a><br><a href="https://msdn.microsoft.com/zh-cn/library/dd233060.aspx" target="_blank" rel="external">委托中的变体（C# 和 Visual Basic）</a><br><a href="https://msdn.microsoft.com/zh-cn/library/ms173174(v=vs.140" target="_blank" rel="external">在委托中使用变体（C# 和 Visual Basic）</a>.aspx)<br><a href="https://msdn.microsoft.com/zh-cn/library/dd465122.aspx" target="_blank" rel="external">对 Func 和 Action 泛型委托使用变体（C# 和 Visual Basic）</a><br><a href="http://www.cnblogs.com/1-2-3/archive/2010/09/27/covariance-contravariance-csharp4.html" target="_blank" rel="external">协变(Covariance)和逆变(Contravariance)的十万个为什么</a><br><a href="http://hongjiang.info/scala-covariance-and-contravariance/" target="_blank" rel="external">scala类型系统：15) 协变与逆变</a>  </p>
]]></content>
    
    <summary type="html">
    
      协变和逆变，里氏代换原则，父类和子类
    
    </summary>
    
      <category term="blog" scheme="http://blog.hjhjw1991.net/categories/blog/"/>
    
    
      <category term="Java" scheme="http://blog.hjhjw1991.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>utf-8项目生成javadoc编码GBK的不可映射字符</title>
    <link href="http://blog.hjhjw1991.net/tips/2016/02/23/utf-8%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90javadoc%E7%BC%96%E7%A0%81GBK%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%98%A0%E5%B0%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://blog.hjhjw1991.net/tips/2016/02/23/utf-8项目生成javadoc编码GBK的不可映射字符/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<p>原因是javadoc生成的时候没有指定编码格式，windows默认编码gbk识别不了utf-8的中文<br>解决方法<br>Eclipse中Generate javadoc最后一步中VM参数设置加入以下代码  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-encoding utf-<span class="number">8</span> -charset utf-<span class="number">8</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      jvm arguments -encoding utf-8 -charset utf-8
    
    </summary>
    
      <category term="tips" scheme="http://blog.hjhjw1991.net/categories/tips/"/>
    
    
      <category term="windows" scheme="http://blog.hjhjw1991.net/tags/windows/"/>
    
      <category term="Java" scheme="http://blog.hjhjw1991.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用adb工具调试android程序(一)</title>
    <link href="http://blog.hjhjw1991.net/blog/2016/02/22/%E4%BD%BF%E7%94%A8adb%E5%B7%A5%E5%85%B7%E8%B0%83%E8%AF%95android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.hjhjw1991.net/blog/2016/02/22/使用adb工具调试android程序（一）/</id>
    <published>2016-02-21T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>尽管现在完善的IDE提供给我们一些android debugger工具，但有时打开IDE和使用这些工具可能无法满足我们的某些要求，或者手边暂时没有趁手的IDE可用，这时候使用adb直接进行开发和调试就成了权宜之计。另外如果我们清楚android sdk提供给我们的常用工具工作原理，那么就可以自行编写功能脚本完成一些较为复杂的调试流程，例如trace或者dump之后自动标记重点区域，或者连接外部dex进行编译等。  </p>
</blockquote>
<p>工欲善其事，必先利其器。以前在Eclipse的时候就觉得DDMS是应用开发调试的神器，现在的Android Studio也集成了Android Debugger，同样强大。而他们背后，都是android sdk所带的调试工具，adb。 </p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>adb启动的时候会默认监听两个端口，5553是daemon端口，5554是设备端口。<br>借助adb，我们可以管理设备或手机模拟器的状态。还可以进行以下的操作:  </p>
<ol>
<li>快速更新设备或手机模拟器中的代码，如应用或Android 系统升级  </li>
<li>在设备上运行shell命令  </li>
<li>管理设备或手机模拟器上的预定端口  </li>
<li>在设备或手机模拟器上复制或粘贴文件  </li>
</ol>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>我们想要将编译得来的或者下载得来的apk安装到目标设备上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb devices # 获取在线设备</div><div class="line">adb install -r xxx.apk # 安装apk，有多个选项，-r表示replace已有的app</div></pre></td></tr></table></figure></p>
<p>我们想上传一些文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push local remote</div></pre></td></tr></table></figure></p>
<p>我们想查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat [ &lt;filter-spec&gt; ]</div></pre></td></tr></table></figure></p>
<p>我们想进入设备的shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell</div></pre></td></tr></table></figure></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>显示系统中全部Android平台  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android list targets</div></pre></td></tr></table></figure>
</li>
<li><p>显示系统中全部AVD（模拟器）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android list avd</div></pre></td></tr></table></figure>
</li>
<li><p>创建AVD（模拟器）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android create avd --name 名称 --target 平台编号</div></pre></td></tr></table></figure>
</li>
<li><p>启动模拟器  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">emulator -avd 名称 -sdcard ~/名称.img (-skin 1280x800)</div></pre></td></tr></table></figure>
</li>
<li><p>删除AVD（模拟器）  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android delete avd --name 名称</div></pre></td></tr></table></figure>
</li>
<li><p>创建SDCard  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mksdcard 1024M ~/名称.img</div></pre></td></tr></table></figure>
</li>
<li><p>AVD(模拟器)所在位置  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Linux(~/.android/avd)</div><div class="line">Windows(C:\Documents and Settings\Administrator\.android\avd)</div></pre></td></tr></table></figure>
</li>
<li><p>启动DDMS  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ddms</div></pre></td></tr></table></figure>
</li>
<li><p>显示当前运行的全部模拟器  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb devices</div></pre></td></tr></table></figure>
</li>
<li><p>对某一模拟器执行命令  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb -s 模拟器编号 命令</div></pre></td></tr></table></figure>
</li>
<li><p>安装应用程序  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb install -r 应用程序.apk</div></pre></td></tr></table></figure>
</li>
<li><p>获取模拟器中的文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull &lt;remote&gt; &lt;local&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>向模拟器中写文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb push &lt;local&gt; &lt;remote&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>进入模拟器的shell模式  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell</div></pre></td></tr></table></figure>
</li>
<li><p>启动SDK，文档，实例下载管理器  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android</div></pre></td></tr></table></figure>
</li>
<li><p>卸载apk包  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb shell</div><div class="line">cd data/app</div><div class="line">rm apk包</div><div class="line">exit</div><div class="line">adb uninstall apk包的主包名</div><div class="line">adb install -r apk包</div></pre></td></tr></table></figure>
</li>
<li><p>查看adb命令帮助信息  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb help</div></pre></td></tr></table></figure>
</li>
<li><p>在命令行中查看LOG信息  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb logcat -s 标签名</div></pre></td></tr></table></figure>
</li>
<li><p>adb shell后面跟的命令主要来自<code>源码\system\core\toolbox目录和源码\frameworks\base\cmds</code>目录。</p>
</li>
<li><p>删除系统应用  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">adb remount （重新挂载系统分区，使系统分区重新可写）。</div><div class="line">adb shell</div><div class="line">cd system/app</div><div class="line">rm *.apk</div></pre></td></tr></table></figure>
</li>
<li><p>获取管理员权限  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb root</div></pre></td></tr></table></figure>
</li>
<li><p>启动Activity  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）</div></pre></td></tr></table></figure>
</li>
<li><p>发布端口  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 你可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如  </div><div class="line">adb forward tcp:5555 tcp:8000</div></pre></td></tr></table></figure>
</li>
<li><p>复制文件  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 你可向一个设备或从一个设备中复制文件  </div><div class="line"></div><div class="line"># 复制一个文件或目录到设备或模拟器上  </div><div class="line">adb push &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; </div><div class="line"># 如：adb push test.txt /tmp/test.txt </div><div class="line"></div><div class="line"># 从设备或模拟器上复制一个文件或目录  </div><div class="line">adb pull &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; </div><div class="line"># 如：adb pull /addroid/lib/libwebcore.so .</div></pre></td></tr></table></figure>
</li>
<li><p>搜索模拟器/设备的实例  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 取得当前运行的模拟器/设备的实例的列表及每个实例的状态： </div><div class="line">adb devices</div></pre></td></tr></table></figure>
</li>
<li><p>查看bug报告  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb bugreport</div></pre></td></tr></table></figure>
</li>
<li><p>记录无线通讯日志  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录  </div><div class="line">adb shell  </div><div class="line">logcat -b radio</div></pre></td></tr></table></figure>
</li>
</ol>
<p>28、获取设备的ID和序列号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb get-product </div><div class="line">adb get-serialno</div></pre></td></tr></table></figure></p>
<p>29、访问数据库SQLite3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">adb shell </div><div class="line">sqlite3</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      作为adb调试android程序的第一步，需要学习如何用adb工具连接设备，安装卸载程序和getshell
    
    </summary>
    
      <category term="blog" scheme="http://blog.hjhjw1991.net/categories/blog/"/>
    
    
      <category term="android" scheme="http://blog.hjhjw1991.net/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Windows 7下查看dns缓存和网络连接状态</title>
    <link href="http://blog.hjhjw1991.net/tips/2015/12/14/Windows%E4%B8%8B%E6%9F%A5%E7%9C%8Bdns%E7%BC%93%E5%AD%98%E5%92%8C%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.hjhjw1991.net/tips/2015/12/14/Windows下查看dns缓存和网络连接状态/</id>
    <published>2015-12-13T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>所有命令通过help查看选项含义，这里不写</p>
</blockquote>
<h2 id="dns缓存"><a href="#dns缓存" class="headerlink" title="dns缓存"></a>dns缓存</h2><p>查看dns缓存</p>
<pre><code>ipconfig /displaydns
</code></pre><p>清空dns缓存</p>
<pre><code>ipconfig /flushdns
</code></pre><h2 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h2><p>查看网络连接进程</p>
<pre><code>netstat /aop tcp
</code></pre>]]></content>
    
    <summary type="html">
    
      ipconfig和netstat命令，做个备忘
    
    </summary>
    
      <category term="tips" scheme="http://blog.hjhjw1991.net/categories/tips/"/>
    
    
      <category term="windows" scheme="http://blog.hjhjw1991.net/tags/windows/"/>
    
  </entry>
  
</feed>
