<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hjhjw1991&#39;s blog</title>
  <subtitle>Coder, Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hjhjw1991.github.io/"/>
  <updated>2017-05-02T02:20:44.491Z</updated>
  <id>https://hjhjw1991.github.io/</id>
  
  <author>
    <name>hjhjw1991</name>
    <email>hjhjw1991@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity中launchMode的理解</title>
    <link href="https://hjhjw1991.github.io/android/2017/04/28/Activity%E4%B8%ADlaunchMode%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/04/28/Activity中launchMode的理解/</id>
    <published>2017-04-27T16:00:00.000Z</published>
    <updated>2017-05-02T02:20:44.491Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道, <code>Activity</code>需要配置在<code>AndroidManifest.xml</code>中才能正常启动, 其原因是launcher需要它来判断应当从哪个Apk中启动哪个Class. 在配置<code>Activity</code>的时候, 有一个属性叫做<code>launchMode</code>, 它对<code>Activity</code>的启动和退出影响颇大, 今天我们就来深入了解一下这个属性以及其背后的逻辑.  </p>
<h2 id="launchMode属性"><a href="#launchMode属性" class="headerlink" title="launchMode属性"></a>launchMode属性</h2><blockquote>
<p>本节内容可自行写demo验证理解</p>
</blockquote>
<p>翻阅各种参考, 我们知道(截至本文成文之日)<code>launchMode</code>一共可以指定四种属性值, 分别是<code>standard singleTop singleTask singleInstance</code>, 其中<code>standard</code>也是默认的属性值. 那么他们分别具有怎样的作用呢?<br>总的来说, <code>launchMode</code>属性影响的是<code>Activity</code>的回退栈, 因此我们有必要先理解回退栈这一概念.<br>在<code>Activity</code>启动的时候, 我们需要考虑当它退出的时候, 下一个要展示的<code>Activity</code>是什么, 为此, <code>android</code>中维护一个<code>Task</code>, 称为任务栈, 以栈的数据结构存储启动的<code>Activity</code>. 当我们退出一个<code>Activity</code>的时候, 展示上一个启动的<code>Activity</code>, 于是在<code>Task</code>中, 只要让当前展示的<code>Activity</code>位于栈顶, 在退出时让它出栈, 就可以自然完成这样的回退逻辑. 例如从A启动B, 当我们退出B的时候, 就展示A. 以上就是最简单朴素的回退栈. 但是这里有一个问题, 就是当我们从桌面启动A时, 回退栈中似乎只有一个A, 这时候退出A, 栈就空了, 怎么办呢? 当然我们大家都知道, 这时候其实是回到了桌面的. 原因就在于, <code>Task</code>有两层概念, 第一层是, 任一应用(作为一个process)拥有自身的回退栈, 第二层是, 系统维护跨应用的全部回退栈. 于是在退出A的时候, 我们实际上是退出了当前应用的回退栈, 交由系统决定下一个要展示的回退栈, 这里就是<code>launcher</code>这个系统应用的回退栈了. 而在<code>launcher</code>中, 由于重写了<code>Back</code> <code>Home</code>按键的响应, 所以不会再退出这个应用.<br>可以用图表示如下:  </p>
<p><img src="/images/blogs/back_stack.png" alt="回退栈示意图">  </p>
<p>有了回退栈我们就知道了如何处理”退出一个Activity”这件事情. 与此相对的, “启动一个Activity”这件事情就意味着需要将<code>Activity</code>放到某个回退栈中. 如果我们完全按照以上的基本逻辑, 即每个应用拥有自身的回退栈, 并且每启动一个<code>Activity</code>就将它放到栈顶, 这就是<code>launchMode</code>的默认属性<code>standard</code>的行为. 对于<code>standard</code>的<code>Activity</code>来说, 它的实例会被放到启动它的<code>Activity</code>所在的<code>Task</code>中.  </p>
<p>很可惜现实世界不是这么简单而美好的, “标准行为”总是会引起”标准错误”. 于是就有了后面三种启动模式.<br>考虑一种情况, 我们需要在应用App1中启动应用App2的某个<code>Activity B</code>. 假设这个B以标准模式启动会有什么问题呢? 每次调用都会创建B并添加到任务栈中, 导致任务栈上茫茫多的B, 退都退不完. 更糟糕的是, 默认情况下B没有指定任务栈, 它会被放在调用它的应用的任务栈上, 这就导致你回到原来的应用界面需要穿过千山万水. 这种情形很常见, 例如点击通知栏通知, 就会跳转到指定应用的指定<code>Activity</code>, 点一百次通知就创建一百个实例这是不可接受的. 通常情况下其实只需要更新数据, 根本没必要新建一个实例. 于是我们有了<code>singleTop</code>模式. 它的作用在于, 该模式下的<code>Activity</code>实例, 如果本身已经在栈顶, 那么再次调用<code>startActivity</code>的时候, 不会创建新的实例, 而是调用已存在实例的<code>onNewIntent()</code>生命周期, 处理新传入的<code>Intent</code>. 如果实例不存在或不在栈顶, 那就跟标准模式一样创建新的实例并放在栈顶.<br>考虑另一种情况, 我们需要在A-B两个<code>Activity</code>中反复互相启动(秘技:反复横跳!), 那么就会引起问题. 由于标准模式下只是无脑启动并添加<code>Activity</code>, 就会导致回退栈中存有大量的<code>A-B-A-B-A-B</code>这样的序列, 而实际上存在多个A还是一个A对用户来说没有分别, 反而多个A导致退出的时候需要按很多次<code>Back</code>, 不胜其烦, 而<code>singleTop</code>模式也不能解决这种问题. 于是我们有了<code>singleTask</code>模式. 它的作用在于, 处于<code>singleTask</code>模式的<code>Activity</code>, 在整个<code>Task</code>之中只能有一个实例. 在启动该<code>Activity</code>的时候, 如果<code>Task</code>中没有该实例, 则新建实例并添加到任务栈, 走全新创建的生命周期, 否则将任务栈中处于该实例以上的所有<code>Activity</code>出栈, 令它处于栈顶(唯我独尊有木有!), 然后调用<code>onNewIntent()</code>周期. 它也是可以快速清空栈内<code>Activity</code>的黑科技.(思考: <code>singleTask</code>模式一定会新建一个<code>Task</code>吗?)<br>再考虑另一种情况, 某个<code>Activity</code>的功能非常单一, 我们全局只需要一个这样的实例来完成他的功能就可以了, 相当于要一个单例<code>Activity</code>. 这样的话, 以上三种模式都无法满足需要, 他们都是强调在某一个Task栈中的状态, 但处于不同的Task栈的话就没有限制了(特别说明一下<code>singleTask</code>模式, 它令Task中只有一个实例, 按理说如果我们只有一个Task的话也可以满足单例的要求, 但它的”副作用”是会清空实例以上的全部<code>Activity</code>, 这却不是我们希望的效果), 所以我们需要一个新的模式来代表这种跨Task栈的单例, 由此诞生了<code>singleInstance</code>模式. 处于该模式的<code>Activity</code>, 在被启动的时候会新建一个<code>Task</code>, 整个生命周期都在这个<code>Task</code>中, 并且这个<code>Task</code><strong>有且只有</strong>它一个实例, 无论从哪里启动它, 只要在某个<code>Task</code>中存在实例, 就会调用这个实例的<code>onNewIntent()</code>周期, 而不是新建一个实例. 这样的例子还是挺多的, 例如桌面日历, 桌面时钟.(思考: 如果指定另一个<code>Activity</code>跟这个<code>singleInstance</code>的<code>Activity</code>拥有同样的<code>Task</code>, 会怎样? 如果从这个<code>singleInstance</code>实例中启动新的<code>Activity</code>, 新的<code>Activity</code>会放在哪里?)  </p>
<p>以上就是四种启动模式的特点. 在官网中对启动模式的描述, 隐含条件是非标准启动模式都指定了<code>taskAffinity</code>属性, 故可能会引起误解.  </p>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><p>启动模式可以配合<code>taskAffinity</code>属性使用.这里来解释一下<code>taskAffinity</code>这个属性.<br>它是<code>Application</code>和<code>Activity</code>标签都有的属性, 用于指定一个<code>Task</code>的名字, 直译的话可以译作”任务归属性”或者”任务亲和性”吧. 不填写该属性的情况下, 所有<code>Activity</code>在一个以包名为名字的<code>Task</code>中, <code>Activity</code>指定了该属性时, 会被放在以该属性值为名字的<code>Task</code>中, <code>Application</code>指定了该属性时, 整个<code>Application</code>的默认<code>Task</code>以该属性值为名.<br>前文曾提出疑问, <code>singleTask</code>是否一定会新建一个<code>Task</code>, 答案是”不一定”. 以<code>singleTask</code>模式启动的<code>Activity</code>, 总是在”将要放置该Activity的Task”中检查实例, 而不指定<code>taskAffinity</code>的情况下将要放置该<code>Activity</code>的就是默认<code>Task</code>了. 实际上只有在指定了<code>taskAffinity</code>并且该<code>Task</code>还不存在的情况下, 才会新建以<code>taskAffinity</code>值命名的<code>Task</code>.<br>需要注意的是, <code>taskAffinity</code>属性是<strong>跨应用的</strong>, 你完全可以为不同的应用指定同一个<code>Task</code>. 要使该属性生效, 必须允许在启动拥有该属性的<code>Activity</code>时新建<code>Task</code>, 即需要传入下文将要介绍的<code>FLAG_ACTIVITY_NEW_TASK</code>标志或为<code>Activity</code>指定<code>allowTaskReparenting</code>为<code>True</code>.  </p>
<h2 id="intent-flags"><a href="#intent-flags" class="headerlink" title="intent flags"></a>intent flags</h2><p>如果说, 我们想要在代码中动态地改变<code>Activity</code>启动模式, 比如想让本来以<code>standard</code>模式启动的<code>Activity</code>在某种情况下以<code>singleTop</code>模式启动, 这可以办到吗? <code>Android</code>工程师们显然想到了这种情形, 设计了<code>intent flags</code>来达成该目的.<br>在启动<code>Activity</code>的时候需要一个<code>Intent</code>, 通过<code>Intent.setFlags()</code>可以设置启动标志, 其中启动模式和FLAG的对应关系如下:  </p>
<table>
<thead>
<tr>
<th style="text-align:left">启动模式</th>
<th style="text-align:left">启动标志</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">standard</td>
<td style="text-align:left">不设置</td>
</tr>
<tr>
<td style="text-align:left">singleTop</td>
<td style="text-align:left">FLAG_ACTIVITY_SINGLE_TOP</td>
</tr>
<tr>
<td style="text-align:left">singleTask</td>
<td style="text-align:left">FLAG_ACTIVITY_NEW_TASK &#124; FLAG_ACTIVITY_CLEAR_TOP</td>
</tr>
</tbody>
</table>
<p>另外还有更多的FLAG可以达成其他效果, 查看<code>Intent</code>类源码可以了解更多.<br>细心的同学可能发现了, 上述表格跟官网的介绍有出入. 官网说仅<code>FLAG_ACTIVITY_NEW_TASK</code>就会产生与<code>singleTask</code>模式相同的行为, 事实上经我实验只有在指定了<code>taskAffinity</code>时这句话才成立. 官网说<code>FLAG_ACTIVITY_CLEAR_TOP</code>属性没有对应的启动模式, 事实上确实如此, 因为它是<code>singleTask</code>模式的其中一个行为.  </p>
<p>细心的同学可能还发现, 表格中没有<code>singleInstance</code>模式对应的FLAG. 那是因为这种模式要达成的效果需要在处理<code>Intent</code>之前更早的时期来控制, 在<code>Intent</code>中设置没用.  </p>
<h2 id="任务栈和回退栈"><a href="#任务栈和回退栈" class="headerlink" title="任务栈和回退栈"></a>任务栈和回退栈</h2><p>由前文所述我们接触到两个概念: 任务栈和回退栈. 我姑且在此拙劣地理解一下: 任务栈是为了完成某种任务而形成的<code>Activity</code>的栈; 回退栈是显示回退顺序的<code>Activity</code>栈. 如此理解的话, 那么两者是从不同的侧面来描述<code>Activity</code>的组织方式, 其中任务栈就是我们上文一直在说的<code>Task</code>, 而回退栈只是一个逻辑上的概念. 事实上我们在新建或者唤起一个<code>Activity</code>的时候, 它所在的整个<code>Task</code>会被提到最上层, 也就是”回退栈”的顶端, 就算<code>launcher</code>应用也是以这种方式回到栈顶的, 只不过它对<code>Back</code>和<code>Home</code>做了处理, 我们无法通过返回键令它出栈而回到位于它下面的<code>Activity</code>. 这就是为什么我们能够在不同的应用间切换, 还能保持应用所打开的<code>Activity</code>的原因(事实上通过设置<code>clearTaskOnLaunch</code>等属性, 切入后台后再切回来可以清空已打开的<code>Activity</code>). 一个栈的名字由在这个栈的底端的那个<code>Activity</code>来定义, 默认就是那个<code>Activity</code>所在的应用的包名.<br>最后一个思考题, 这些任务栈是被谁在什么时候进行管理的呢?<br>祭出我们的大杀器: 源码. 全目录搜索关键词<code>launchMode</code>, 然后就会发现一个东西<code>./frameworks/base/services/java/com/android/server/am/ActivityStack.java</code>以及另一个东西<code>./frameworks/base/core/java/android/content/pm/ActivityInfo.java</code>, 其中前者我们在AMS中已经见到过了, 至此得解.  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html#ManagingTasks" target="_blank" rel="external">官网 任务和返回栈</a>  </li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0520/2897.html" target="_blank" rel="external">Activity启动模式图文详解</a>  </li>
<li><a href="http://blog.csdn.net/qilamaxiu/article/details/51604957" target="_blank" rel="external">Activity启动模式解析</a>  </li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6754323" target="_blank" rel="external">基础总结篇之二：Activity的四种launchMode</a>  </li>
<li><a href="http://blog.csdn.net/thewalker3000/article/details/62035836" target="_blank" rel="external">如何正确理解和使用 Activity的4种启动模式</a>  </li>
<li><a href="http://wangkuiwu.github.io/2014/06/26/IntentFlag/" target="_blank" rel="external">Android 之Activity启动模式(二)之 Intent的Flag属性</a>  </li>
<li><a href="http://www.cloudchou.com/android/post-760.html" target="_blank" rel="external">深入理解Activity启动模式(二)–Activity,回退栈,Task之间的关系</a>  </li>
<li><a href="http://blog.csdn.net/wanghao200906/article/details/49766309" target="_blank" rel="external">android的启动模式 到底在什么时候用呢</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      我们知道, `Activity`需要配置在`AndroidManifest.xml`中才能正常启动, 其原因是launc...
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】ActivityManagerService全解(1/5)</title>
    <link href="https://hjhjw1991.github.io/android/2017/03/05/%5BAndroid%E6%95%99%E7%A8%8B%5DActivityManagerService%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/03/05/[Android教程]ActivityManagerService全解/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2017-04-07T03:12:54.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在<code>Android</code>操作系统中, 有许多个默默维护<code>Android</code>系统稳定正常流畅运行的幕后工作者, 对于上层App开发者来说这些工作者的名字可能是不太熟悉甚至完全陌生的, 就像电影散场时的演职人员表, 人人都知道没有他们电影完不成, 也都知道他们各有分工, 各有名谓, 但少有人清楚他们具体做了什么. 其中为人所熟知的几大系统服务之一就是<code>ActivityManagerService</code>, 今天我们来访谈一下这位幕后工作者.  </p>
</blockquote>
<p>采访者: <a href="https://hjhjw1991.github.io">hjhjw1991</a><br>被采访者: <code>ActivityManagerService</code>家族<br>地点: <code>Android 4.0</code>源码目录<br>时间: 2017-03-01  </p>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><ul>
<li><p>你好, 请简要介绍一下你自己.<br><a href="https://hjhjw1991.github.io">hjhjw1991</a>你好, 大家好, 我是<code>ActivityManagerService</code>, 位于<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>. 我的父亲是<code>ActivityManagerNative</code>, 我的祖父是<code>Binder</code>. 我左手这个接口是<code>Watchdog.Monitor</code>, 右手的接口是<code>BatteryStatsImpl.BatteryCallback</code>, 我们家的关系就像下面这幅图所示:<br><img src="/images/blogs/activity_manager_service_stack.png" alt="ActivityManagerService类关系图"><br>感谢我家的健康咨询师<a href="http://blog.csdn.net/innost" target="_blank" rel="external">邓凡平老师</a>为我绘制的族谱, 他将族谱放在了<a href="http://wiki.jikexueyuan.com/project/deep-android-v2/activity.html" target="_blank" rel="external">这里</a>, 有兴趣的同学欢迎买他的书以表支持.  </p>
</li>
<li><p>好的, 我就叫你<code>AMS</code>可以吗?<br>没问题, 大家都这么叫我.  </p>
</li>
<li><p><code>AMS</code>, 你现在的职业是什么呢?<br>我现在在家族企业<code>Android Framework</code>上班, 日常工作也就是管理管理企业四大金刚<code>Activity</code> <code>Service</code> <code>ContentProvider</code> <code>BroadcastReceiver</code>.  </p>
</li>
<li><p>听起来位置很重要呢, 平时主要忙些什么呢?<br>确实非常重要, 我常常忙不过来呢. 我主要负责调度和管理刚刚提到的四大金刚, 他们是我们企业的业务骨干, 几乎所有业务都交给他们去做的, 所以为了他们能安心做好分内工作, 我作为中间协调人就需要负责在业务到来的时候找到合适的执行人并通知他们去执行. 不过说是这么说, 我其实也不是直接通知他们, 像<code>Activity</code>, 我就是在接到相关业务的时候, 选择合适的时机让我父亲<code>ActivityManagerNative</code>判断一下是什么业务, 然后告诉我应该做什么, 我就根据这个具体业务, 找到具体能做这个业务的对象. 我们有一个专门的对外接口人, 他叫<code>ActivityManagerProxy</code>, 负责跑业务.<br>比如接口人接到一个<code>startActivity</code>的任务, 他就拿着资料先给我父亲看一下(<code>ActivityManagerProxy.transact-&gt;ActivityManagerNative.onTransact</code>), 他没有权限见我父亲, 好在他手上有支可以直接接通我父亲的专属电话<code>mRemote</code>, 平时什么业务都是通过这支电话传递的. 据说这支电话是我祖父<code>Binder</code>和他的兄弟们发明的, 他们可以监听电话里所有的通信内容, 我祖父真厉害.<br>我父亲一看, 原来是<code>START_ACTIVITY_TRANSACTION</code>这种事务, 他帮我整理整理事务资料(因为据说事务资料都是包装在一种叫做<code>Parcel</code>的密封材料中的, 需要特别的解封技巧, 我不太会), 然后把整理好的资料交给我. <code>START_ACTIVITY_TRANSACTION</code>是我父亲和接口人<code>Proxy</code>约定好的暗语, 我们有一整套暗语, 写在<code>IActivityManager</code>这个文件里面, 这文件藏在<code>frameworks/base/core/java/android/app/IActivityManager.java</code>, 我也有一份拷贝, 是我父亲给我的, 但我基本上没看过, 都让我父亲看(<code>ActivityManagerService.onTransact</code>里面就是<code>super.onTransact</code>), 没办法我太忙了. 据说这套暗语也是祖父发明的, 我祖父真厉害.<br>父亲将资料交给我的时候也会告诉我, 要用<code>startActivity</code>这个方法去完成这个事务. 这个方法我知道, 我给你手写一下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div></pre></td><td class="code"><pre><div class="line">  public final int startActivity(IApplicationThread caller,</div><div class="line">          Intent intent, String resolvedType, Uri[] grantedUriPermissions,</div><div class="line">          int grantedMode, IBinder resultTo,</div><div class="line">          String resultWho, int requestCode, boolean onlyIfNeeded, boolean debug,</div><div class="line">          String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; // 方法签名</div><div class="line">      return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType,</div><div class="line">              grantedUriPermissions, grantedMode, resultTo, resultWho,</div><div class="line">              requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler,</div><div class="line">              null, null); // 执行者</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  你看, 很简单吧, 我其实只是把资料全都交给对的家伙去处理罢了. 说得我都有点不好意思了, 我平时真的很忙的, 真的. 这个`mMainStack`是我一个得力秘书, 他专精`Activity`相关管理事务, 据说他们家族是`ActivityStack`. 我看他能力不错, 就在`main`的时候把他招进来了.  </div><div class="line">  我做的工作差不多都是这种模式, 像`startService`这种事务我可能做的事要多些, `startService -&gt; startServiceLocked -&gt; bringUpServiceLocked -&gt; realStartServiceLocked -&gt; app.thread.scheduleCreateService`, 基本上就是检查权限, 检查是不是已经在做了, 检查做的人还在不在, 如果做的人在但是还没开始做并且做的人能做, 我就交给他去做. 这个做事的人, 就是`app.thread`. `app`是`ProcessRecord`家的, 他小弟`thread`是`IApplicationThread`家的. 我虽然是`ServerThread`一手提拔起来让我做到现在位置的, 但是我们的运营完全独立于他, 行话说就是我们在**独立线程**上.  </div><div class="line">  </div><div class="line">- 你刚刚提到了`main`, 你所说的`main`是个什么过程呢?  </div><div class="line">  `main`是我的上司`SystemServer::ServerThread`(位于`frameworks/base/services/java/com/android/server/SystemServer.java`)交给我的任务. 他一旦告诉我要做`main`了, 我就要开始工作了. 具体来说, 我做的工作是这样的:</div><div class="line">  </div><div class="line">  ```  </div><div class="line">    public static final Context main(int factoryTest) &#123;</div><div class="line">        AThread thr = new AThread(); // #1 创建一个AThread线程对象</div><div class="line">        thr.start();</div><div class="line"></div><div class="line">        synchronized (thr) &#123;</div><div class="line">            ... // #2 等待线程的thr.mService创建完成</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ActivityManagerService m = thr.mService;</div><div class="line">        mSelf = m;</div><div class="line">        ActivityThread at = ActivityThread.systemMain(); // #3 调用ActivityThread.systemMain函数</div><div class="line">        mSystemThread = at;</div><div class="line">        Context context = at.getSystemContext(); // #4 获得SystemContext</div><div class="line">        context.setTheme(android.R.style.Theme_Holo);</div><div class="line">        m.mContext = context;</div><div class="line">        m.mFactoryTest = factoryTest;</div><div class="line">        m.mMainStack = new ActivityStack(m, context, true); // #5 使用m和context新建ActivityStack对象</div><div class="line">        </div><div class="line">        m.mBatteryStatsService.publish(context); // 调用BSS和USS的publish方法</div><div class="line">        m.mUsageStatsService.publish(context);</div><div class="line">        </div><div class="line">        synchronized (thr) &#123;</div><div class="line">            thr.mReady = true; // #6 设置thr为已准备, 并通知thr可以开始他的表演</div><div class="line">            thr.notifyAll();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m.startRunning(null, null, null, null); // 全null参数调用startRunning, 主要作用是设置`mStartRunning`标志, 因为此时`mSystemReady`还是默认值`false`, 走不到后面的`systemReady`逻辑</div><div class="line">        </div><div class="line">        return context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static class AThread extends Thread &#123;</div><div class="line">        ActivityManagerService mService;</div><div class="line">        boolean mReady = false;</div><div class="line"></div><div class="line">        public AThread() &#123;</div><div class="line">            super(&quot;ActivityManager&quot;); // 设置线程名字</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            Looper.prepare(); // 准备Looper, 估计是要用消息队列来处理消息</div><div class="line"></div><div class="line">            android.os.Process.setThreadPriority(</div><div class="line">                    android.os.Process.THREAD_PRIORITY_FOREGROUND); // 设置线程优先级</div><div class="line">            android.os.Process.setCanSelfBackground(false);</div><div class="line"></div><div class="line">            ActivityManagerService m = new ActivityManagerService(); // 创建AMS对象</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                mService = m; // AMS对象赋值给成员mService</div><div class="line">                notifyAll(); // #7 通知其他以本线程为锁的线程, 可以获取本线程来做锁了</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                ...// #8 等待mReady被外部(也就是main所在线程)设置为true</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line"></div><div class="line">            Looper.loop(); // 开始消息循环</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  ```  </div><div class="line">  老大让我开始`main`之后, 我就分配一个小弟`AThread thr`, 等他向我汇报(#2), 小弟汇报完(#7)就等我把老大这边交代的工作做完(#3~#6), 然后他再继续剩下的工作(#8), 并处于待命状态, 随时准备处理后面的消息.  </div><div class="line">  </div><div class="line">- 好像越来越复杂了, 又是`ActivityThread`又是`SystemServer`的, 看来我又多了几个采访对象. 想问一下`AMS`, 我注意到刚刚在你`AThread`中有一步是`new ActivityManagerService()`, 这里面做了什么能让我看一下吗?  </div><div class="line">  不能╭(╯^╰)╮. `Java`类的构造函数就像女孩子的闺房, 允许你看才能看. 我可以大概跟你说里面做了什么. 大概就是下面这样:  </div><div class="line">  </div><div class="line">  ```  </div><div class="line">  private ActivityManagerService() &#123;</div><div class="line">      Slog.i(TAG, &quot;Memory class: &quot; + ActivityManager.staticGetMemoryClass()); // 日志</div><div class="line">      </div><div class="line">      File dataDir = Environment.getDataDirectory(); // /data/目录</div><div class="line">      File systemDir = new File(dataDir, &quot;system&quot;); // /data/system</div><div class="line">      systemDir.mkdirs();</div><div class="line">      // 创建BatteryStatsService, BSS</div><div class="line">      mBatteryStatsService = new BatteryStatsService(new File(</div><div class="line">              systemDir, &quot;batterystats.bin&quot;).toString());</div><div class="line">      mBatteryStatsService.getActiveStatistics().readLocked();</div><div class="line">      mBatteryStatsService.getActiveStatistics().writeAsyncLocked();</div><div class="line">      mOnBattery = DEBUG_POWER ? true</div><div class="line">              : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</div><div class="line">      mBatteryStatsService.getActiveStatistics().setCallback(this);</div><div class="line">      </div><div class="line">      // 创建UsageStatsService, USS</div><div class="line">      mUsageStatsService = new UsageStatsService(new File(</div><div class="line">              systemDir, &quot;usagestats&quot;).toString());</div><div class="line"></div><div class="line">      GL_ES_VERSION = SystemProperties.getInt(&quot;ro.opengles.version&quot;,</div><div class="line">          ConfigurationInfo.GL_ES_VERSION_UNDEFINED); // OpenGL_ES版本</div><div class="line"></div><div class="line">      mConfiguration.setToDefaults();</div><div class="line">      mConfiguration.locale = Locale.getDefault();</div><div class="line">      mProcessStats.init(); // ProcessStats, 用于统计CPU/内存信息, 解析/proc/stat文件的内容</div><div class="line">      </div><div class="line">      // 解析/data/system/packages-compat.xml文件, 获得APK的屏幕尺寸要求.  </div><div class="line">      mCompatModePackages = new CompatModePackages(this, systemDir);</div><div class="line"></div><div class="line">      // Add ourself to the Watchdog monitors.</div><div class="line">      Watchdog.getInstance().addMonitor(this);</div><div class="line"></div><div class="line">      // 新线程用于定时更新系统信息</div><div class="line">      mProcessStatsThread = new Thread(&quot;ProcessStats&quot;) &#123;</div><div class="line">          public void run() &#123;</div><div class="line">              while (true) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      try &#123;</div><div class="line">                          synchronized(this) &#123;</div><div class="line">                              final long now = SystemClock.uptimeMillis();</div><div class="line">                              long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</div><div class="line">                              long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</div><div class="line">                              //Slog.i(TAG, &quot;Cpu delay=&quot; + nextCpuDelay</div><div class="line">                              //        + &quot;, write delay=&quot; + nextWriteDelay);</div><div class="line">                              if (nextWriteDelay &lt; nextCpuDelay) &#123;</div><div class="line">                                  nextCpuDelay = nextWriteDelay;</div><div class="line">                              &#125;</div><div class="line">                              if (nextCpuDelay &gt; 0) &#123;</div><div class="line">                                  mProcessStatsMutexFree.set(true);</div><div class="line">                                  this.wait(nextCpuDelay);</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125; catch (InterruptedException e) &#123;</div><div class="line">                      &#125;</div><div class="line">                      updateCpuStatsNow();</div><div class="line">                  &#125; catch (Exception e) &#123;</div><div class="line">                      Slog.e(TAG, &quot;Unexpected exception collecting process stats&quot;, e);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      mProcessStatsThread.start();</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  总的来说就是创建了`/data/system`目录, 实例化了BSS和USS两个服务, 创建了`ProcessStats`的实例及其运行线程, 这些都是用来监控系统状况的. 另外初始化了`mCompatModePackages`和`mConfiguration`.  </div><div class="line">  </div><div class="line">- 那`ActivityThread.systemMain()`和`ActivityManagerService.startRunning()`又做了什么呢?  </div><div class="line">  `ActivityThread.systemMain()`先禁用硬件渲染, 然后实例化了一个`ActivityThread`对象并调用了它的`attach(true)`方法, 然后把这个对象丢回来. `attach(true)`传入的参数表示调用者是否系统进程. 在系统进程下它做了以下工作:  </div><div class="line"></div><div class="line">  ```  </div><div class="line">  </div><div class="line">      private void attach(boolean system) &#123;</div><div class="line">          sThreadLocal.set(this);</div><div class="line">          mSystemThread = system;</div><div class="line">          if (!system) &#123;// 非系统进程时的处理</div><div class="line">          &#125; else &#123;</div><div class="line">              // Don&apos;t set application object here -- if the system crashes,</div><div class="line">              // we can&apos;t display an alert, we just want to die die die.</div><div class="line">              // 以上是源码中的注释, 绝不是我在卖萌</div><div class="line">              // 设置显示的进程名称为system_process</div><div class="line">              android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;);</div><div class="line">              try &#123;</div><div class="line">                  // 构造Instrumentation, Context, Application, 并调用Applicaiton.onCreate()</div><div class="line">                  mInstrumentation = new Instrumentation();</div><div class="line">                  ContextImpl context = new ContextImpl();</div><div class="line">                  // 调用init时第一个参数是getSystemContext().mPackageInfo</div><div class="line">                  context.init(getSystemContext().mPackageInfo, null, this);</div><div class="line">                  Application app = Instrumentation.newApplication(Application.class, context);</div><div class="line">                  mAllApplications.add(app);</div><div class="line">                  mInitialApplication = app;</div><div class="line">                  app.onCreate();</div><div class="line">              &#125; catch (Exception e) &#123;</div><div class="line">                  ...</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          // 添加Configuration回调</div><div class="line">          ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123;</div><div class="line">              public void onConfigurationChanged(Configuration newConfig) &#123;</div><div class="line">                  synchronized (mPackages) &#123;</div><div class="line">                      // We need to apply this change to the resources</div><div class="line">                      // immediately, because upon returning the view</div><div class="line">                      // hierarchy will be informed about it.</div><div class="line">                      if (applyConfigurationToResourcesLocked(newConfig, null)) &#123;</div><div class="line">                          // This actually changed the resources!  Tell</div><div class="line">                          // everyone about it.</div><div class="line">                          ...</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              public void onLowMemory() &#123;</div><div class="line">              &#125;</div><div class="line">              public void onTrimMemory(int level) &#123;</div><div class="line">              &#125;</div><div class="line">          &#125;);</div><div class="line">      &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  可见, 在系统初始化的时候以系统的身份借助了`ActivityThread`的功能, 去获取系统资源`framework-res.apk`(应用名`android`). 从这个角度来说, `SystemServer`进程实际上也是一个特殊的应用进程, 在其上运行的应用都是仅供给系统使用的. 在`systemMain`调用结束后, 就可以通过返回的`ActivityThread`实例像操作普通应用一样操作系统应用以及和`Android`环境交互了. 相当于`SystemServer`也运行在跟应用进程相似的`Android`运行环境中.  </div><div class="line">  然后`startRunning()`做的事:  </div><div class="line">  </div><div class="line">  ```  </div><div class="line">  // 以全null参数调用</div><div class="line">  public final void startRunning(String pkg, String cls, String action,</div><div class="line">          String data) &#123;</div><div class="line">      synchronized(this) &#123;</div><div class="line">          if (mStartRunning) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          mStartRunning = true; // 设置标记, 如果已经设置过了直接返回</div><div class="line">          mTopComponent = pkg != null &amp;&amp; cls != null</div><div class="line">                  ? new ComponentName(pkg, cls) : null;</div><div class="line">          mTopAction = action != null ? action : Intent.ACTION_MAIN;</div><div class="line">          mTopData = data; // 由于传入的参数全null, 所以这里几个成员变量也是null, action则是Intent.ACTION_MAIN</div><div class="line">          if (!mSystemReady) &#123; // 此时mSystemReady仍为默认值false, 直接返回</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      systemReady(null); // 重要函数, 执行完后意味着系统已经启动完毕. 代码非常长, 而且在本次调用startRunning时并不会走到这里.</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">- 好的, 我大概更糊涂了. 我总结一下, AMS的`main()`总共做了三点主要的工作:</div><div class="line">    1. 新启`AThread`线程创建`AMS`实例, 在`AMS`构造函数里面, 创建BSS/USS/mProcessStats: ProcessStats/mProcessStatsThread, 用于统计系统运行状况,</div><div class="line">还创建了`/data/system`目录,</div><div class="line">并为mCompatModePackages: CompatModePackages 和 mConfiguration: Configuration 等成员变量赋值;</div><div class="line">    2. 通过`ActivityThread.systemMain()`函数得到了一个`ActivityThread`实例, 代表了`framework-res.apk`应用所在的应用进程,</div><div class="line">为`SystemServer`创建了与Android环境交互的条件. 普通的应用则是应用的主线程调用`ActivityThread.main()`来获得`ActivityThread`实例;</div><div class="line">    3. 调用`startRunning()`, 并返回第2步创建好的`Context`实例, 完成`AMS.main()`的最后一步.</div><div class="line"></div><div class="line">    到这里为止都是`Activity`和`Application`啥的, 你前面说过跟四大金刚打交道, 那么其他几位你又是怎么跟他们打交道的呢?</div><div class="line"></div><div class="line">    嗯, 下次有空再说吧.</div><div class="line"></div><div class="line">- 好的, 距离上次(2017-03-05)已经过去了一个月, 咱们继续采访吧.</div><div class="line"></div><div class="line">    上次说到, `SystemServer::ServerThread`调用了`AMS.main()`从而为`SystemServer`创建了`Android`环境, 为`AMS`的工作做了准备.</div><div class="line">    然而上次在`startRunning()`时留了一个悬念, 即`SystemReady()`这个函数并没有在此时被调用. `main()`执行完之后返回了`Context`实例. 那么后面发生了什么呢?</div><div class="line">其实, 在`SystemServer::ServerThread::run()`中可以看到, 在`main()`方法调用之后, 经过了其他一些必要的初始化(例如调用`PackageManagerService.main()`),</div><div class="line">然后该线程调用了`ActivityManagerService.setSystemProcess()`, 该函数定义如下:</div></pre></td></tr></table></figure>
<p>  public static void setSystemProcess() {</p>
<pre><code>try {
    ActivityManagerService m = mSelf;
    // 向ServiceManager注册服务
    ServiceManager.addService(&quot;activity&quot;, m);// 注册本服务, 服务名activity
    ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(m));// 监控内存信息
    ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(m));// 监控硬件加速信息, 可通过adb shell dumpsys gfxinfo查看,
    4.0新增
    if (MONITOR_CPU_USAGE) {
        ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(m));// 监控CPU使用, MONITOR_CPU_USAGE默认为true
    }
    ServiceManager.addService(&quot;permission&quot;, new PermissionController(m));// 权限管理服务

    //#1 通过AMS的Context获取到PackageManagerService, 查询名为&quot;android&quot;的ApplicationInfo
    ApplicationInfo info =
        mSelf.mContext.getPackageManager().getApplicationInfo(
                &quot;android&quot;, STOCK_PM_FLAGS);
    //#2 调用ActivityThread.installSystemApplicationInfo()函数
    mSystemThread.installSystemApplicationInfo(info);

    synchronized (mSelf) {
        //#3 使用info新建并保存ProcessRecord对象
        ProcessRecord app = mSelf.newProcessRecordLocked(
                mSystemThread.getApplicationThread(), info,
                info.processName);// info.processName == &quot;system&quot;
        app.persistent = true;
        app.pid = MY_PID;
        app.maxAdj = ProcessList.SYSTEM_ADJ;
        mSelf.mProcessNames.put(app.processName, app.info.uid, app);
        synchronized (mSelf.mPidsSelfLocked) {
            mSelf.mPidsSelfLocked.put(app.pid, app);
        }
        //#4 更新LruProcess中存储的进程的顺序
        mSelf.updateLruProcessLocked(app, true, true);
    }
} catch (PackageManager.NameNotFoundException e) {
    throw new RuntimeException(
            &quot;Unable to find android system package&quot;, e);
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从以上代码可以看到, AMS通过PMS(PackageManagerService)查询名为&quot;android&quot;的ApplicationInfo, 尽管他们实质上都是在`ServerThread`同一个进程上运行,</div><div class="line">完全可以以本地调用的方式互相调用, 但统一通过Context来进行交互的话, 保持了与其他服务相同的交互接口, 未来对交互方式的扩展也可以直接作用到这里, 使得代码更加灵活.</div><div class="line">现在来看看#2. 该函数以`ApplicationInfo`为参数, 根据前面的内容, 我们知道&quot;android&quot;这个名字对应的package就是&quot;framework-res.apk&quot;,</div><div class="line">猜测`ApplicationInfo`是其代码模型. 我们来看看这个方法的代码:</div></pre></td></tr></table></figure>
<p>  // frameworks/core/java/android/app/ActivityThread.java<br>  public void installSystemApplicationInfo(ApplicationInfo info) {</p>
<pre><code>synchronized (this) {
    // 返回的ContextImpl对象就是前面在AMS的main中创建的对象
    ContextImpl context = getSystemContext();
    //#1 oops!又一次调用了init, 是不是重复了?
    context.init(new LoadedApk(this, &quot;android&quot;, context, info,
            CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO), null, this);

    // give ourselves a default profiler
    // 用于性能统计
    mProfiler = new Profiler();
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">看#1再次调用了`ContextImpl.init`, 似乎跟`AMS.main`中`ActivityThread.getSystemContext()`时调用的`ContextImpl.init`重复了? 仔细看看,</div><div class="line">原来后者虽然给`LoadedApk`的名字也是&quot;android&quot;, 但是传入的第四个参数是`null`, 而前者#1中传入的第四个参数是指向&quot;framework-res.apk&quot;的`ApplicationInfo`实例.</div><div class="line">这就相当于`LoadedApk`指向了实际的apk包. 那么, 为什么要这样做呢? 实际上, 前面创建`ContextImpl`的时候, 并不需要用到&quot;framework-res.apk&quot;的东西,</div><div class="line">而只是希望创建一个android运行环境, 所以不需要绑定实际的包, 而此时往后需要用到&quot;framework-res.apk&quot;的东西了, 它的正确运行需要一个正确初始化的android运行环境,</div><div class="line">所以需要将代表它的`ApplicationInfo`绑定到`ContextImpl`上, 这也就是这个方法名字的含义. 由此看来接下来要做的事情就比较清晰了: 为&quot;framework-res.apk&quot;的运行创建或分配一个进程,</div><div class="line">并管理这个进程. 这些工作也是AMS完成的.</div><div class="line">于是我们可以看到 #3 #4 这两步就是在做进程管理. `ProcessRecord`是用于进程管理的数据结构. 通过`AMS.newProcessRecordLocked()`来创建`ProcessRecord`实例.</div><div class="line">到这里我们可以思考一个问题: 进程创建之后, AMS怎么跟进程进行交互? 我们想一下, AMS自己有一个进程, 这里又新建了一个进程, 那么AMS要跟新建的进程交互, 就需要进行跨进程交互. 这是不是意味着要借助Binder?</div><div class="line">原因可以看我以前写的Binder解析. 事实是确实如此, AMS通过Binder对其他进程进行管理, 充当桥梁的是`ActivityThread.ApplicationThread`这个类及其相关类和接口,</div><div class="line">这些都是Binder的标准套路, 其中`IApplicationThread`提供了操作接口, 用于启动/暂停/停止Activity.</div><div class="line">`ApplicationThread`的服务端实现就位于AMS要控制的那个进程的`ActivityThread`中, 具体来说就是客户端调用接口后,</div><div class="line">服务端`ActivityThread`会对应往自己线程的handler中发送一个消息, 而服务端`ActivityThread`自身运行在主线程中, 所以最终就是将消息发送到了服务端的主线程中处理.</div><div class="line">思考完这个问题, 我们来看`newProcessRecordLocked()`的代码:</div></pre></td></tr></table></figure>
<p>  final ProcessRecord newProcessRecordLocked(IApplicationThread thread,</p>
<pre><code>    ApplicationInfo info, String customProcess) {
String proc = customProcess != null ? customProcess : info.processName;
BatteryStatsImpl.Uid.Proc ps = null;
BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
    ps = stats.getProcessStatsLocked(info.uid, proc);// 为本进程创建一个耗电量统计项
}
// 创建一个ProcessRecord对象, 第二个参数就是用来和其他进程进行通信的thread
return new ProcessRecord(ps, thread, info, proc);
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">看到没有, 第一个参数就是`IApplicationThread`. 除此之外, AMS还需要更多的进程信息来管理进程, 这些信息就放在`ProcessRecord`这个数据结构中. 我们有空可以看一看这个类的实现, 它位于`frameworks/base/services/java/com/android/server/am/ProcessRecord.java`, 有一丢丢大. 我们这里只要知道,</div><div class="line">在构造函数中不经保存了和应用进程进行通信的`IApplicationThread`对象, 还保存了进程名, 不同状态对应的OOM_Adj值, 以及一个`ApplicationInfo`.</div><div class="line">一个进程虽然可以运行多个Application, 但`ProcessRecord`一般只保存该进程中最先运行的那个`Application`的`ApplicationInfo`.</div><div class="line">到此为止, 已经创建了一个`ProcessRecord`对象. 创建应用进程时的过程也与此类似. 和其他应用进程不同的是, 现在创建的这个对象所对应的进程是`SystemServer`. 它既然这么特殊,</div><div class="line">自然有一些与众不同的地方, 从上面的代码也可以看到, AMS为这个特殊的进程记录的一部分成员变量设定了特殊的值:</div></pre></td></tr></table></figure>
<p>  // 前一步已以ApplicationInfo.processName初始化ProcessRecord, 该值为”system”<br>  app.persistent = true; // 该值为true表示本进程常驻内存, 即使被杀掉也会被系统重启<br>  app.pid = MY_PID; // 设置pid为SystemServer的pid<br>  app.maxAdj = ProcessList.SYSTEM_ADJ; // 设置最大OOM_Adj为系统进程默认值, -16</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    至此, 一个`SystemServer`对应的`ProcessRecord`就创建完毕, 紧接着AMS将它纳入自己的管理之中. AMS通过以下几个数据结构来管理包括这个进程记录在内的进程记录:</div><div class="line">    ![process_names](/images/blogs/process_names.png)</div><div class="line"></div><div class="line">    总结一下, `setSystemProcess()`这个方法正如其名, 它主要完成了代表`SystemServer`进程的`ProcessRecord`对象的创建, 从此将系统进程也纳入AMS管理范围. 除此之外,</div><div class="line">    它还将AMS/meminfo/gfxinfo等服务注册到了`ServiceManager`中.</div><div class="line"></div><div class="line">- 好的, 你高兴就好, 你请继续.</div><div class="line"></div><div class="line">    好, 我们再回到`SystemServer::ServerThread::run`看接下来的内容.</div></pre></td></tr></table></figure>
<p>  try {<br>  // 其他内容都省略</p>
<pre><code>Slog.i(TAG, &quot;Entropy Service&quot;);
Slog.i(TAG, &quot;Power Manager&quot;);
Slog.i(TAG, &quot;Activity Manager&quot;);
Slog.i(TAG, &quot;Telephony Registry&quot;);
Slog.i(TAG, &quot;Package Manager&quot;);

ActivityManagerService.setSystemProcess();

// The AccountManager must come before the ContentService
try {
    Slog.i(TAG, &quot;Account Manager&quot;);
} catch (Throwable e) {
    Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e);
}
Slog.i(TAG, &quot;Content Manager&quot;);

Slog.i(TAG, &quot;System Content Providers&quot;);
ActivityManagerService.installSystemProviders();// #1

Slog.i(TAG, &quot;Vibrator Service&quot;);
Slog.i(TAG, &quot;Alarm Manager&quot;);
Slog.i(TAG, &quot;Init Watchdog&quot;);
Slog.i(TAG, &quot;Window Manager&quot;);

ActivityManagerService.self().setWindowManager(wm);// #2

// Skip Bluetooth if we have an emulator kernel
if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) {
    Slog.i(TAG, &quot;No Bluetooh Service (emulator)&quot;);
} else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
    Slog.i(TAG, &quot;No Bluetooth Service (factory test)&quot;);
} else {
    Slog.i(TAG, &quot;Bluetooth Service&quot;);
}
</code></pre><p>  } catch (RuntimeException e) {<br>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">接下来跟AMS有关的就#1 #2两步了. #2比较好理解, 我们重点来看#1, 即`AMS.installSystemProviders()`. 代码如下:</div></pre></td></tr></table></figure>
<p>  public static final void installSystemProviders() {</p>
<pre><code>List&lt;ProviderInfo&gt; providers;
synchronized (mSelf) {
    ProcessRecord app = mSelf.mProcessNames.get(&quot;system&quot;, Process.SYSTEM_UID); // 通过名字和PID获取system对应的进程记录
    providers = mSelf.generateApplicationProvidersLocked(app); // #1
    if (providers != null) {
        for (int i=providers.size()-1; i&gt;=0; i--) {
            ProviderInfo pi = (ProviderInfo)providers.get(i);
            if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) { // 移除非系统Provider
                Slog.w(TAG, &quot;Not installing system proc provider &quot; + pi.name
                        + &quot;: not system .apk&quot;);
                providers.remove(i);
            }
        }
    }
}
if (providers != null) {
    mSystemThread.installSystemProviders(providers); // #2
}

mSelf.mCoreSettingsObserver = new CoreSettingsObserver(mSelf); // #3

mSelf.mUsageStatsService.monitorPackages(); // #4
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">在分析代码前, 我们先说明一下为什么会有这么个方法. 在Android中SystemServer上很多Service都需要通过Settings数据库查询配置信息,</div><div class="line">而这个Settings数据库是Android通过agiel特殊的Provider `SettingsProvider`提供给开发者的. 该Provider位于`SettingsProvider.apk`中,</div><div class="line">这个apk跟`framework-re.apk`类似, 也是在`SystemServer`进程上运行. 以上代码就是加载这个Provider. 加载完毕后`SystemServer`上就同时存在两个`apk`了.</div><div class="line">以上步骤#3和#4我们暂且不分析, 前者是监视Settings数据库的观察者, 后者是`UsageStatsService`的工作. #1可以看出是生成Provider列表的, 而#2则是调用`ActivityThread</div><div class="line">.installSystemProvider()`将系统Provider装载在进程上.</div><div class="line"></div><div class="line">#1 里面, 首先通过`AppGlobals.getPackageManager().queryContentProviders(app.processName, app.info.uid,</div><div class="line">STOCK_PM_FLAGS|PackageManager.GET_URI_PERMISSION_PATTERNS)`获取到满足进程名和进程id条件的`ProviderInfo`列表.</div><div class="line">遍历该列表并获取或构造`ContentProviderRecord`对象(这些对象都会保存在`AMS.mProvidersByClass`中, 一看这个名字我们差不多能猜到它就是代表ContentProvider的信息了),</div><div class="line">然后将这个对象以名字为键放到`app.pubProviders`中,并将它对应的包名放到`app.addPackage()`中, 最后看看能否对这个Provider包进行Dex优化. 别忘记这里的`app`就是上文中的`ProcessRecord`对象.</div><div class="line">至此, 查询到的Provider就纳入了当前进程`SystemServer`中了. 至于怎么通过进程名和pid查找的Provider, 这里我们就暂且不说了, 会放在`PackageManager`文章中来说.</div><div class="line">思考题: 为什么AMS和ProcessRecord都需要保存ContentProviderRecord?</div><div class="line"></div><div class="line">#2 里面做剩下的工作. #1之后实际上只是保存了`ContentProvider`的信息, 并没有产生`ContentProvider`对象, #2就能产生`ContentProvider`对象.</div><div class="line">实际上跟标准的`ContentProvider`产生过程并无两样. 代码如下:</div></pre></td></tr></table></figure>
<p>  public final void installSystemProviders(List<providerinfo> providers) {</providerinfo></p>
<pre><code>if (providers != null) {
    installContentProviders(mInitialApplication, providers);// 第一个参数实际类型是Application
}
</code></pre><p>  }</p>
<p>  private void installContentProviders( // 产生ContentProvider的必经之路, 标准的产生ContentProvider的方法</p>
<pre><code>    Context context, List&lt;ProviderInfo&gt; providers) {
final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =
    new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();

Iterator&lt;ProviderInfo&gt; i = providers.iterator();
while (i.hasNext()) {
    ProviderInfo cpi = i.next();
    ...
    // 调用installProvider获得一个IContentProvider对象
    IContentProvider cp = installProvider(context, null, cpi, false);
    if (cp != null) {
        IActivityManager.ContentProviderHolder cph =
            new IActivityManager.ContentProviderHolder(cpi);
        cph.provider = cp;// IContentProvider对象与ProviderInfo对象绑定
        results.add(cph);
        // Don&apos;t ever unload this provider from the process.
        synchronized(mProviderMap) {
            mProviderRefCountMap.put(cp.asBinder(), new ProviderRefCount(10000));//引用计数
        }
    }
}

try {
// 向AMS注册所有的ContentProvider, 第一个参数是ApplicationThread
    ActivityManagerNative.getDefault().publishContentProviders(
        getApplicationThread(), results);
} catch (RemoteException ex) {
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">总结一下, 以上代码做了两件事: 1. 通过`ActivityThread.installProvider`获得`ContentProvider`实例; 2. 向AMS发布所有`ContentProvider`实例.</div><div class="line">其实这跟`Binder Service`类似: 创建`Binder Service`实例, 向`ServiceManager`注册实例.</div><div class="line">`ActivityThread`和`ContentProvider`的关系如图:</div><div class="line">![contentProvider](/images/blogs/activity_manager_service_content_provider.png)</div><div class="line"></div><div class="line">我们这里不去深入分析`ActivityThread.installProvider()`, 这个内容放到分析`ActivityThread`的时候来讲. 我们来看`AMS.publishContentProviders()`. 代码如下:</div></pre></td></tr></table></figure>
<p>  // 此时传入的参数是caller=getApplicationThread(),即<code>framework-res.apk</code>所在的<code>SystemServer</code>进程中, 用于进程间通信的<code>ApplicationThread</code>客户端实例<br>  public final void publishContentProviders(IApplicationThread caller,</p>
<pre><code>    List&lt;ContentProviderHolder&gt; providers) {
if (providers == null) {
    return;
}

synchronized(this) {
    final ProcessRecord r = getRecordForAppLocked(caller);//根据调用者Binder对象找到调用者所在的进程信息
    ...
    final long origId = Binder.clearCallingIdentity();

    final int N = providers.size();
    for (int i=0; i&lt;N; i++) {
        ContentProviderHolder src = providers.get(i);
        if (src == null || src.info == null || src.provider == null) {
            continue;
        }
        ContentProviderRecord dst = r.pubProviders.get(src.info.name);// 从调用者进程信息中找到对应的ContentProviderRecord
        if (dst != null) {
            ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);
            mProvidersByClass.put(comp, dst);//以ComponentName为键, 保存ContentProviderRecord. 这是寻找ContentProvider的方式之一
            String names[] = dst.info.authority.split(&quot;;&quot;);
            for (int j = 0; j &lt; names.length; j++) {
                mProvidersByName.put(names[j], dst);// 以authority为键, 保存ContentProviderRecord. 这是寻找ContentProvider的方式之一
            }

            int NL = mLaunchingProviders.size();// 处于启动状态的ContentProvider
            int j;
            for (j=0; j&lt;NL; j++) {
                if (mLaunchingProviders.get(j) == dst) {
                    mLaunchingProviders.remove(j);
                    j--;
                    NL--;
                }
            }
            synchronized (dst) {
                dst.provider = src.provider;
                dst.proc = r;
                dst.notifyAll();//通知所有等待中的进程, 本ContentProvider已经发布, 可供使用
            }
            updateOomAdjLocked(r);// 每发布一个ContentProvider, 调整一次调用者进程的oom_adj
        }
    }

    Binder.restoreCallingIdentity(origId);
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总结一下, `SettingsProvider.apk`作为一个系统级的`ContentProvider`,</div><div class="line">通过`installSystemProvider`由`SystemServer`进程走普通的`ContentProvider`创建和发布流程完成发布.</div><div class="line">接着我们再回到`SystemServer::ServerThread::run`, 走余下的流程:</div></pre></td></tr></table></figure>
<p>  // in file SystemServer.java<br>  …<br>  // We now tell the activity manager it is okay to run third party<br>  // code.  It will call back into us once it has gotten to the state<br>  // where third party code can really run (but before it has actually<br>  // started launching the initial applications), for us to complete our<br>  // initialization.<br>  ActivityManagerService.self().systemReady(new Runnable() {</p>
<pre><code>public void run() {
    Slog.i(TAG, &quot;Making services ready&quot;);

    startSystemUi(contextF);
    try {
        if (batteryF != null) batteryF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Battery Service ready&quot;, e);
    }
    try {
        if (networkManagementF != null) networkManagementF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Managment Service ready&quot;, e);
    }
    try {
        if (networkStatsF != null) networkStatsF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Stats Service ready&quot;, e);
    }
    try {
        if (networkPolicyF != null) networkPolicyF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Policy Service ready&quot;, e);
    }
    try {
        if (connectivityF != null) connectivityF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Connectivity Service ready&quot;, e);
    }
    try {
        if (dockF != null) dockF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Dock Service ready&quot;, e);
    }
    try {
        if (usbF != null) usbF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making USB Service ready&quot;, e);
    }
    try {
        if (uiModeF != null) uiModeF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making UI Mode Service ready&quot;, e);
    }
    try {
        if (recognitionF != null) recognitionF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Recognition Service ready&quot;, e);
    }
    Watchdog.getInstance().start();

    // It is now okay to let the various system services start their
    // third party code...

    try {
        if (appWidgetF != null) appWidgetF.systemReady(safeMode);
    } catch (Throwable e) {
        reportWtf(&quot;making App Widget Service ready&quot;, e);
    }
    try {
        if (wallpaperF != null) wallpaperF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Wallpaper Service ready&quot;, e);
    }
    try {
        if (immF != null) immF.systemReady(statusBarF);
    } catch (Throwable e) {
        reportWtf(&quot;making Input Method Service ready&quot;, e);
    }
    try {
        if (locationF != null) locationF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Location Service ready&quot;, e);
    }
    try {
        if (countryDetectorF != null) countryDetectorF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Country Detector Service ready&quot;, e);
    }
    try {
        if (throttleF != null) throttleF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Throttle Service ready&quot;, e);
    }
    try {
        if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Time Service ready&quot;, e);
    }
    try {
        if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Text Services Manager Service ready&quot;, e);
    }
}
</code></pre><p>  });</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以看到传给了`AMS.systemReady()`一个`Runnable`的回调. 是时候打开`ActivityManagerService.systemReady()`看一看了. 源码如下:</div></pre></td></tr></table></figure>
<p>  // todo 添加源码<br>  ```</p>
</li>
</ul>
<h2 id="ActivityManagerNative-ActivityManagerProxy与ActivityManager"><a href="#ActivityManagerNative-ActivityManagerProxy与ActivityManager" class="headerlink" title="ActivityManagerNative, ActivityManagerProxy与ActivityManager"></a>ActivityManagerNative, ActivityManagerProxy与ActivityManager</h2>]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲ActivityManagerService系统服务-由于这个东西涉及的面实在广, 前面我又没有写过其他的相关内容, 所以这个话题我分5个部分来介绍.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android源码伴读】Retrofit源码探秘</title>
    <link href="https://hjhjw1991.github.io/android/2017/03/01/%5BAndroid%E6%BA%90%E7%A0%81%E4%BC%B4%E8%AF%BB%5DRetrofit%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A7%98/"/>
    <id>https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2017-03-05T11:15:49.483Z</updated>
    
    <content type="html"><![CDATA[<p>截至我写文章为止, <code>Retrofit</code>更新到了<code>2.2.0</code>版本. 据说<code>1.x</code>与<code>2.0+</code>差异巨大, 这里我们就直接拥抱变化来看最新代码了.  </p>
<h2 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h2><p>添加依赖和添加网络权限我就不说了. 假设我们要访问网络获取一个<code>Json</code>格式的响应, 来看代码怎么写:  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
                    .baseUrl(&quot;http://url.of.yourserver/&quot;)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build(); // 创建全局管理
HttpService httpService = retrofit.create(YourHttpService.class); // 创建访问接口实例
Call&lt;Json&gt; call = httpService.getJson(); // 为要访问的接口创建Call
call.enqueue(new YourCallbackForThisCall(){...}); // Call入队列并添加回调
</code></pre><p>非常简单对不对, 而且<code>YourHttpService.class</code>甚至可能根据某种规范直接从服务端导出, 需要自己手写的代码几乎可以忽略不计, 出bug的几率就更小了.<br>这里的<code>Callback</code>经我验证是在UI线程执行的, 所以可以直接在<code>onResponse</code>里更新UI. 如果想要换到其他线程处理, 需要设置<code>callbackExecutor</code>, 默认是主线程.  </p>
<h2 id="Retrofit源码探秘"><a href="#Retrofit源码探秘" class="headerlink" title="Retrofit源码探秘"></a>Retrofit源码探秘</h2><p>根据我们前面分析过的<code>OkHttp</code>源码可以知道, <code>Retrofit</code>背后的请求发送和接收都是通过它来完成的, 自己几乎没做什么. <code>Retrofit</code>能实现这么简单的调用方式, 其魔法就在它的抽象架构上. <code>Retrofit</code>通过定义和解析注解的方式生成<code>Request</code>, 又在原本<code>OkHttpCall</code>(<code>Retrofit</code>定义的<code>OkHttp</code>的代理)的回调之中加了一层, 用于处理响应出错情况和把响应结果包装成<code>ExceptionCatchingRequestBody</code>, 最后用<code>ServiceMethod.toResponse</code>使用<code>Converter</code>完成响应解析, 使用解析结果通过<code>CallAdapter</code>构造一个自定义的<code>Response&lt;T&gt;</code>并返回. 再在外层回调我们设置的<code>Callback&lt;T&gt;</code>.<br>真正的网络请求的事情包括连接和缓存的维护都交给<code>OkHttpClient</code>完成了, 因此关键就在于<code>Retrofit</code>从注解到<code>Call</code>的过程和从<code>Response</code>到<code>Response&lt;T&gt;</code>的过程.  </p>
<h3 id="Retrofit注解定义和解析"><a href="#Retrofit注解定义和解析" class="headerlink" title="Retrofit注解定义和解析"></a>Retrofit注解定义和解析</h3><p>在我之前的某篇文章中曾经解析过<code>Java</code>的<code>Annotation</code>机制, 这里就不再解释了, 我们已经知道, <code>Java</code>的注解是通过注解处理器<code>Processor</code>进行处理的, <code>Retrofit</code>应该也是实现了类似的机制去处理它自己的注解. 注解都是编译器完成处理的, 其处理后的代码的生命周期根据它的<code>Retention</code>不同而不同, <code>Retention</code>为<code>RUNTIME</code>的注解在编译器处理之后存在于<code>.class</code>文件中并且还被虚拟机载入, 所以可供后续处理. 接下来我们就来看看<code>Retrofit</code>中的注解定义和解析器的定义, 我们将会发现它所有的注解都是<code>RUNTIME</code>的.<br>注解都在<code>http</code>包下, 从名字也看得出来基本上对应了<code>http</code>协议中的各个实体. 我们只看其中<code>GET</code> <code>Headers</code> <code>Streaming</code>三个.<br>选这三个的原因是三个在<code>http</code>协议中分别代表三种类型: 请求方法, 结构参数, 传输标记. 如果不记得<code>http</code>协议的同学可以看我另一篇博客<a href="/images/blogs/network.md">Android源码解析-网络架构</a>.<br>三个注解的完整代码如下:  </p>
<pre><code>@Target(METHOD)
@Retention(RUNTIME)
public @interface GET {
  /**
   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
   * parameter of the method is annotated with {@link Url @Url}.
   * &lt;p&gt;
   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
   * this is resolved against a base URL to create the full endpoint URL.
   */
  String value() default &quot;&quot;;
}

/**
 * Adds headers literally supplied in the {@code value}.
 * &lt;pre&gt;&lt;code&gt;
 * &amp;#64;Headers(&quot;Cache-Control: max-age=640000&quot;)
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 *
 * &amp;#64;Headers({
 *   &quot;X-Foo: Bar&quot;,
 *   &quot;X-Ping: Pong&quot;
 * })
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; Headers do not overwrite each other. All headers with the same name will
 * be included in the request.
 *
 * @see Header
 * @see HeaderMap
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Headers {
  String[] value();
}

/**
 * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
 * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Streaming {
}
</code></pre><p>为避免各位说我凑篇幅, 请各位仔细看上文代码的注释部分和注解部分, 我们可以看到这几个注解的设计思路, 基本上是按照<code>http</code>协议的基本部分来分解的, 并且都有明确的作用对象和作用范围.<br>对这三种类型的注解的处理自然也是不太一样, 接下来我们就看看<code>Retrofit</code>为它的这些注解编写了怎样的处理器. 注解的转存在<code>ServiceMethod.Builder()</code>中, 处理则在<code>ServiceMethod.Builder.build()</code>中, 如下:  </p>
<pre><code>public ServiceMethod build() {
  ...
  // Method级别的Annotation, 主要是GET/POST等方法
  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }
  ...
  // Parameter级别的Annotation, 主要是Path等
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }
 ...
}

// 处理Method级别Annotation
private void parseMethodAnnotation(Annotation annotation) {
  if (annotation instanceof DELETE) {
    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
  } else if (annotation instanceof GET) {
    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
  } else if (annotation instanceof HEAD) {
    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);
    if (!Void.class.equals(responseType)) {
      throw methodError(&quot;HEAD method must use Void as response type.&quot;);
    }
  } else if (annotation instanceof PATCH) {
    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);
  } else if (annotation instanceof POST) {
    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
  } else if (annotation instanceof PUT) {
    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);
  } else if (annotation instanceof OPTIONS) {
    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);
  } else if (annotation instanceof HTTP) {
    HTTP http = (HTTP) annotation;
    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
  } else if (annotation instanceof retrofit2.http.Headers) {
    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    if (headersToParse.length == 0) {
      throw methodError(&quot;@Headers annotation is empty.&quot;);
    }
    headers = parseHeaders(headersToParse);
  } else if (annotation instanceof Multipart) {
    if (isFormEncoded) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isMultipart = true;
  } else if (annotation instanceof FormUrlEncoded) {
    if (isMultipart) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isFormEncoded = true;
  }
}

// 处理Parameter级别Annotation
private ParameterHandler&lt;?&gt; parseParameter(
    int p, Type parameterType, Annotation[] annotations) {
  ParameterHandler&lt;?&gt; result = null;
  for (Annotation annotation : annotations) {
    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(
        p, parameterType, annotations, annotation);

    ...// handleException

    result = annotationAction;
  }
  ...// handleException

  return result;
}

// 具体的处理Annotation的实现, 方法颇长就不贴详情了
private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type type, Annotation[] annotations, Annotation annotation) {
  if (annotation instanceof Url) { // handle @Url
    ...// throw Exception if necessary

    gotUrl = true;

    if (type == HttpUrl.class
        || type == String.class
        || type == URI.class
        || (type instanceof Class &amp;&amp; &quot;android.net.Uri&quot;.equals(((Class&lt;?&gt;) type).getName()))) {
      return new ParameterHandler.RelativeUrl();
    } else {
      ...// throw Exception
    }

  } else if (annotation instanceof Path) { // handle @Path
    ...// throw Exception if necessary

    gotPath = true;

    Path path = (Path) annotation;
    String name = path.value();
    validatePathName(p, name);

    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations); // 见Retrofit.stringConverter()
    return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded()); // 见ParameterHandler.Path&lt;&gt;

  } else if (annotation instanceof Query) { // handle @Query
  } else if (annotation instanceof QueryName) { // handle @QueryName
  } else if (annotation instanceof Header) { // handle @Header
  } else if (annotation instanceof FieldMap) { // handle @FieldMap
  } else if (annotation instanceof Part) { // handle @Part
  } else if (annotation instanceof PartMap) { // handle @PartMap
  } else if (annotation instanceof Body) { // handle @Body
  }
  return null; // Not a Retrofit annotation.
}
</code></pre><p>可见<code>Retrofit</code>对注解的处理分为两个部分: 一个是<code>Method</code>级别的<code>Annotation</code>, 所有<code>http</code>协议方法都被定义为该级别的<code>Annotation</code>, 在<code>ServiceMethod.parseHttpMethodAndPath</code>中处理(注意到, 基本方法<code>DELETE</code> <code>GET</code> <code>HEAD</code> <code>POST</code>等应该是互斥的, 但代码中没有进行判断, 而<code>Multipard</code>和<code>FormUrlEncoded</code>之间却进行了判断, 至于代码中没有对<code>Streaming</code>的处理, 是因为逻辑上它不在这一层, 而是在响应结果的解析, 所以其实是在<code>retrofit2/BuiltInConverters.java</code>中进行了处理); 另一个是<code>Parameter</code>级别的, 大多数是在进行基本预处理之后就委托给<code>ParameterHandler</code>接口的实现类进行处理.  </p>
<p>通过对某个方法的注解的处理, 在<code>ServiceMethod.Builder.build()</code>完成后<code>ServiceMethod</code>就获取到了调用该方法发起网络请求所需要的信息, 可以开始构造<code>Call</code>了.  </p>
<h3 id="Retrofit的Call与Response"><a href="#Retrofit的Call与Response" class="headerlink" title="Retrofit的Call与Response"></a>Retrofit的Call与Response</h3><p><code>Retrofit</code>的<code>Call</code>和<code>Response</code>是对<code>OkHttp</code>的<code>Call</code>和<code>Response</code>的封装, 为什么要进行这么一层封装呢? 接下来我们就看看它的源码.<br>我们选择从核心方法<code>Retrofit.create(Class)</code>开始.  </p>
<pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service); // #1
  if (validateEagerly) {
    eagerlyValidateMethods(service); // #2
  }

  // #3 below
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
        private final Platform platform = Platform.get();

        @Override public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
          // If the method is a method from Object then defer to normal invocation.
          if (method.getDeclaringClass() == Object.class) {
            return method.invoke(this, args);
          }
          if (platform.isDefaultMethod(method)) {
            return platform.invokeDefaultMethod(method, service, proxy, args);
          }
          ServiceMethod&lt;Object, Object&gt; serviceMethod =
              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); // #4
          OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // #5
          return serviceMethod.callAdapter.adapt(okHttpCall); // #6
        }
      });
}
</code></pre><p>这里面一共有三个步骤, 其中前两步是用来检查接口和提前载入方法的, 第三步是关键, 生成并返回了一个代理. 实例化代理时传入了三个参数, 第三个是<code>InvocationHandler</code>的实现, 我们可以看到里面最关键的步骤是<code>#4 #5 #6</code>, 分别完成方法载入(<code>Method-&gt;ServiceMethod</code>), <code>Call</code>构造和返回<code>Call</code>代理. 这里<code>Proxy</code>及<code>InvocationHandler</code>都是<code>Java</code>中就已经存在并引入了<code>Android</code>中的机制, 即动态代理机制. 关于动态代理机制, 思想成熟战法犀利, 是相当有意思的一个东西, 可以参见<a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">这篇文章</a><br>总之要使用动态代理呢, 委托类必须要实现某个接口, 而<code>Proxy</code>创建的代理类通过实现<code>InvocationHandler</code>来调用委托类的方法, 完成代理. 所有这一切都跟反射密不可分, 所以理所当然<code>Proxy</code>是在反射包下的.<br>从上面代码可以看出, <code>Platform.isDefaultMethod()</code>和<code>Object</code>的方法将被<code>InvocationHandler</code>直接代理执行, 而其他方法则被包装成<code>OkHttpCall</code>交给<code>ServiceMethod</code>的<code>CallAdapter</code>去执行. 这里也可以看出对<code>Call</code>和<code>Response</code>进行封装代理的作用: 屏蔽底层实现, 统一处理非核心逻辑, 统一接口, 令底层替换成其他网络访问库成为可能.  </p>
<p>下面我们来看<code>ServiceMethod</code>的构造过程, <code>OkHttpCall</code>的构造过程以及默认的<code>CallAdapter</code>的代码.<br>还记得在<code>create</code>里传入<code>loadServiceMethod</code>的是<code>Method method</code>, 它是代理方法, 通过它去访问委托(被代理)方法, 代码如下:  </p>
<pre><code>ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {
  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);
  if (result != null) return result;

  synchronized (serviceMethodCache) {
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); // 传入Retrofit, Method实例, 构造代理包装类ServiceMethod实例
      serviceMethodCache.put(method, result); // 缓存代理方法-代理包装实例映射
    }
  }
  return result;
}
</code></pre><p>然后根据传入的方法及其参数, 构造一个合适的<code>Call</code>, 这个<code>Call</code>是<code>OkHttp</code>中<code>Call</code>的代理, 所以<code>Retrofit</code>中它的类是<code>OkHttpCall</code>. 下面我们看它是怎么构造和代理的, 代码如下:  </p>
<pre><code>final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; {
    OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) {
      this.serviceMethod = serviceMethod;
      this.args = args;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      // 检查参数

      okhttp3.Call call;
      Throwable failure;

      synchronized (this) {
        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);
        executed = true;

        call = rawCall;
        failure = creationFailure;
        if (call == null &amp;&amp; failure == null) {
          try {
            call = rawCall = createRawCall();
          } catch (Throwable t) {
            failure = creationFailure = t;
          }
        }
      }

      if (failure != null) {
        callback.onFailure(this, failure);
        return;
      }

      if (canceled) {
        call.cancel();
      }

      call.enqueue(new okhttp3.Callback() { // okhttp3.Callback反向代理retrofit2.Callback
        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
            throws IOException {
          Response&lt;T&gt; response;
          try {
            response = parseResponse(rawResponse); // 解析响应
          } catch (Throwable e) {
            callFailure(e); // 回调自身callFailure
            return;
          }
          callSuccess(response); // 回调自身callSuccess
        }

        @Override public void onFailure(okhttp3.Call call, IOException e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callFailure(Throwable e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callSuccess(Response&lt;T&gt; response) {
          try {
            callback.onResponse(OkHttpCall.this, response);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }
      });
    }
}
</code></pre><p>结构清晰, 基本可以当做<code>OkHttpCall</code>来对待.  </p>
<p>接下来通过<code>ServiceMethod.callAdapter.adapt(OkHttpCall)</code>将<code>OkHttpCall</code>转换为<code>Call&lt;T&gt;</code>. <code>ServiceMethod</code>的建造模式如下:  </p>
<pre><code>Builder(Retrofit retrofit, Method method) {
  this.retrofit = retrofit;
  this.method = method;
  this.methodAnnotations = method.getAnnotations(); # 获取代理方法的方法注解
  this.parameterTypes = method.getGenericParameterTypes(); # 获取泛型参数类型
  this.parameterAnnotationsArray = method.getParameterAnnotations(); # 获取参数注解
}

public ServiceMethod build() {
  callAdapter = createCallAdapter(); # 根据泛型返回类型和方法注解, 通过retrofit.callAdapter(returnType, annotations)寻找适配器实例. Retrofit实例化时默认添加`DefaultCallAdapterFactory`工厂
  responseType = callAdapter.responseType(); # 获取返回类型
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;&apos;&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;); # 不允许以`Response`作为返回类型
  }
  responseConverter = createResponseConverter();

  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation); # 解析方法注解
  }

  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }

  ...// 判断方法注解合法性

  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    // 解析参数注解
    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    ...
    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  ...// 判断参数合法性

  return new ServiceMethod&lt;&gt;(this);
}

ServiceMethod(Builder&lt;R, T&gt; builder) {
  this.callFactory = builder.retrofit.callFactory();
  this.callAdapter = builder.callAdapter;
  this.baseUrl = builder.retrofit.baseUrl();
  this.responseConverter = builder.responseConverter;
  this.httpMethod = builder.httpMethod;
  this.relativeUrl = builder.relativeUrl;
  this.headers = builder.headers;
  this.contentType = builder.contentType;
  this.hasBody = builder.hasBody;
  this.isFormEncoded = builder.isFormEncoded;
  this.isMultipart = builder.isMultipart;
  this.parameterHandlers = builder.parameterHandlers;
}
</code></pre><p>始终别忘了以上内容都是通过<code>Java</code>自带的<code>Proxy</code>机制调用<code>InvocationHandler</code>来代理的, 所以<code>create</code>传入的是什么类, 返回的就是什么类的代理, 访问这个代理的方法时, 实际调用的是<code>InvocationHandler</code>. 通过<code>ServiceMethod.callAdapter.adapt()</code>可以将传入的方法适配为你自己定义的返回类型<code>Call&lt;T&gt;</code>的实例. 我们来看看默认情况下添加的<code>DefaultCallAdapterFactory</code>会生成什么<code>CallAdapter</code>:  </p>
<pre><code>public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { // 工厂方法, 传入返回类型, 注解数组, retrofit实例
  if (getRawType(returnType) != Call.class) { // 返回类型如果不是Call则直接返回null
    return null;
  }

  final Type responseType = Utils.getCallResponseType(returnType); // 获取ReturnType&lt;T&gt;中泛型参数T的上限类型
  return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
    @Override public Type responseType() {
      return responseType;
    }

    @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
      return call; // 默认返回传入参数
    }
  };
}
</code></pre><p>显然默认情况下这个适配器什么也不做, 直接把传入的<code>OkHttpCall</code>返回给你.  </p>
<h3 id="Retrofit的Converter与CallAdapter-开始使用RxJava"><a href="#Retrofit的Converter与CallAdapter-开始使用RxJava" class="headerlink" title="Retrofit的Converter与CallAdapter: 开始使用RxJava"></a>Retrofit的Converter与CallAdapter: 开始使用RxJava</h3><p>上文已经暗示了, 对结果的解析器<code>Converter</code>可以替换, 其实发送请求的代理<code>Call</code>也可以被替换, 只要换掉<code>CallAdapter</code>就可以了, 网上都说<code>RxJava+Retrofit</code>可以打出成吨输出, 原因就在于<code>CallAdapter</code>可以换成一个返回<code>Observable</code>类型的适配器, 这使得在<code>Retrofit.create()</code>之后可以直接以<code>RxJava</code>的风格做链式调用.<br>实现起来也非常简单, 只要<code>.addConverterFactory()</code> <code>.addCallAdapterFactory()</code>即可, 因为<code>Retrofit</code>对外提供了抽象类<code>Converter.Factory</code> <code>CallAdapter.Factory</code>, 并且实例全部使用泛型来表示, 通过对外提供统一接口, 只要外部可以继承抽象工厂类并返回实现了统一接口的实例类, 就可以在不改变<code>Retrofit</code>一行代码的情况下接入其他库, 或者原有逻辑代码变动不大的情况下接入<code>Retrofit</code>.  </p>
<p>是时候上一波图了:<br><img src="/images/blogs/retrofit_okhttp.png" alt="Retrofit, RxJava 和 OkHttp之间的关系"><br>上面这张图是我基于<a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Stay的这篇文章</a>改的, 荣耀归他, 另外由于图滞后于<code>Retrofit</code>版本, 所以如果有不一致的地方锅也归他(目前没看见不一致).  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这篇文章分析了<code>Retrofit</code>的实现, 其优缺点即使不是一目了然, 也是足够清晰了, 希望能够帮助到正在选择网络请求框架的各位.<br>本文参考如下:  </p>
<ul>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">Retrofit 源码解析</a>  </li>
<li><a href="http://www.jianshu.com/p/097947afddaf" target="_blank" rel="external">Retrofit源码分析（超详细）</a>  </li>
<li><a href="http://www.jianshu.com/p/07dac989272c" target="_blank" rel="external">Android网络框架源码分析二—Retrofit</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit源码</a>  </li>
<li><a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a>  </li>
<li><a href="https://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">Retrofit文档</a>  </li>
<li><a href="https://inthecheesefactory.com/blog/retrofit-2.0/en" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲Retrofit. 总的来说它是一个面向业务流程的网络请求库, 内部默认使用面向网络协议的库OkHttp来打出成吨伤害.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Android网络架构</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/28/%5BAndroid%E6%95%99%E7%A8%8B%5DAndroid%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/28/[Android教程]Android网络架构/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-03-05T11:15:17.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便初学者, 也为知识体系能够脉络清晰, 本文分为两个部分:  </p>
<ul>
<li>第一部分讲述网络基础知识, 这是一切的基本功  </li>
<li>第二部分讲述几种常用的Android网络框架的使用方法和设计思想(不涉及源码解析)  </li>
</ul>
<p>由于Android官方提供的网络请求工具就是<code>HttpURLConnection</code>, 内容比较少就不再单独写了, 放在了第二部分. 各位可各取所需.  </p>
<h2 id="http基础知识"><a href="#http基础知识" class="headerlink" title="http基础知识"></a>http基础知识</h2><h3 id="http的历史"><a href="#http的历史" class="headerlink" title="http的历史"></a>http的历史</h3><p>我觉得了解一点技术的历史, 有助于理解该技术产生的思想内核, 以及时代局限, 但是网络这个话题实在太广泛, 因此不得不择其一二来讲述, 我选择了http及其相关技术, 不感兴趣的同学可以跳过.  </p>
<p>http协议可以说是目前互联网使用最广泛的协议, 它在RFC中的定义历经二十年至今版本迭代才至2.0, 此前主要使用的是http1.0/1.1, 版本之间差异很大, 但不像别的技术, http由于影响面及其广, 所以在整个互联网中更新换代是非常缓慢的过程.  </p>
<p>http是现在事实标准TCP/IP协议簇中的一员, 但它不为TCP/IP而生, 也不依赖于TCP/IP, 事实上只要保证传输稳定性, 它的下层用什么协议它并不关心(它自身位于协议栈的栈顶, 即应用层). 在上个世纪90年代, http诞生了, 它的主要设计人是Tim Berners Lee 博士, 这位牛人同时也是HTML, WWW和URL的主要贡献者, 是一个真正值得敬仰的前辈. http规定的是服务器和客户端之间, 或者说虚拟机和虚拟机之间, 数据传输的约定, 它从作用到内容其实并不神秘, 它的发展历程几乎可以等同于国际互联网的发展历程.  </p>
<p>http全称是<code>HyperText Transfer Protocol</code>, 超文本传输协议. 名字好像挺玄乎, 其实也不神秘, 首先它把一段包含很多额外信息的文本称为超文本, 比如这段文本里面有URL链接, 代表另一段文本, 或者代表一个多媒体文件. 然后这个传输协议就是约定发送和接收双方如何来对待这段超文本, 发送方如何封包, 接收方如何解包, 这很像快递过程, 超文本被包裹在内, 其外放上一些防止内容被破坏的数据, 以及一些写着出发地和到达地的数据, 到了到达地, 再由收件人拆包, 获得超文本内容.  </p>
<p>虽然说起来简单, 但这个协议实际上有长达60页的协议细节, 有兴趣的同学可以查看<a href="http://www.rfc-editor.org/rfc/rfc1945.txt" target="_blank" rel="external">RFC-http</a>和<a href="http://www.rfc-editor.org/rfc/rfc2068.txt" target="_blank" rel="external">RFC-http1.1</a>两个文档, 你如果熟知这两个文档的内容, 那下面有关http1.0/1.1的部分就完全不用看了.  </p>
<h3 id="http基础-协议格式-https"><a href="#http基础-协议格式-https" class="headerlink" title="http基础: 协议格式, https"></a>http基础: 协议格式, https</h3><p>以下内容主要参考维基百科<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" title="Hypertext_Transfer_Protocol_Wikipedia" target="_blank" rel="external">Http-Wiki</a>, RFC定义<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="external">w3http1.1</a>, 在线博客和一些计算机书籍  </p>
<p>前面说了, http协议规定了怎么在客户端和服务端之间传输文件, 而规定的方式就是在传输数据包的时候, 在头尾加东西. 本节就来看看具体加了什么东西, 也就是http协议格式. 注意, 本节<strong>不讲tcp协议</strong>  </p>
<p>教科书上都是由上到下, 先讲协议设计再讲具体数据, 但我想随着门槛的降低, 真正从事计算机相关工作且有坚实计算机网络基础的同学可能不多, 所以我从实践到理论地来讲http协议格式, 可能同学们更好理解些. 为方便说明, 我们可以任意生成一个http数据包, 比如, 我用Chrome自带的抓包工具<code>chrome://net-internals/</code>随便抓取了几个访问某https页面时生成的包(不带任何参数). 经过格式化解析之后的内容如下(#是我给的注释):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">t=695 [st=  0] +REQUEST_ALIVE  [dt=149]</div><div class="line">t=695 [st=  0]    DELEGATE_INFO  [dt=6] # 请求代理信息</div><div class="line">                  --&gt; delegate_info = &quot;NavigationResourceThrottle&quot;</div><div class="line">t=701 [st=  6]   +URL_REQUEST_DELEGATE  [dt=2]</div><div class="line">t=701 [st=  6]      DELEGATE_INFO  [dt=2]</div><div class="line">                    --&gt; delegate_info = &quot;扩展程序“AdBlock”&quot;</div><div class="line">t=703 [st=  8]   -URL_REQUEST_DELEGATE</div><div class="line">t=703 [st=  8]    URL_REQUEST_START_JOB  [dt=1] # URL请求类型</div><div class="line">                  --&gt; load_flags = 37121 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VALIDATE_CACHE | VERIFY_EV_CERT) # 标志位</div><div class="line">                  --&gt; method = &quot;GET&quot; # 请求方法</div><div class="line">                  --&gt; priority = &quot;HIGHEST&quot; # 优先级</div><div class="line">                  --&gt; url = &quot;https://www.baidu.com/&quot; #请求的URL</div><div class="line">t=704 [st=  9]   +URL_REQUEST_START_JOB  [dt=135]</div><div class="line">                  --&gt; load_flags = 37121 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VALIDATE_CACHE | VERIFY_EV_CERT)</div><div class="line">                  --&gt; method = &quot;GET&quot;</div><div class="line">                  --&gt; priority = &quot;HIGHEST&quot;</div><div class="line">                  --&gt; url = &quot;https://www.baidu.com/&quot;</div><div class="line">t=704 [st=  9]      URL_REQUEST_DELEGATE  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_GET_BACKEND  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_OPEN_ENTRY  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_READ_INFO  [dt=0]</div><div class="line">t=708 [st= 13]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0] # 请求事务类型</div><div class="line">t=708 [st= 13]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS # 头部</div><div class="line">                      --&gt; GET / HTTP/1.1 # 方法, 协议, 版本</div><div class="line">                          Host: www.baidu.com # 主机</div><div class="line">                          Connection: keep-alive # 连接类型</div><div class="line">                          Cache-Control: max-age=0 # 缓存</div><div class="line">                          Upgrade-Insecure-Requests: 1</div><div class="line">                          User-Agent: Mozilla/5.0 (X11; Linux x86_64)  AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 # 用户代理</div><div class="line">                          Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 # 接受的数据类型</div><div class="line">                          DNT: 1</div><div class="line">                          Accept-Encoding: gzip, deflate, sdch, br # 接受的数据类型</div><div class="line">                          Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4 # 接受的语种</div><div class="line">                          Cookie: [1203 bytes were stripped] # 附带的Cookie, 被解包工具跳过了</div><div class="line">t=708 [st= 13]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=708 [st= 13]     +HTTP_TRANSACTION_READ_HEADERS  [dt=130] # 读取事务类型</div><div class="line">t=708 [st= 13]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=130] # 解析头部</div><div class="line">t=838 [st=143]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS# 读取响应头部</div><div class="line">                      --&gt; HTTP/1.1 200 OK # 协议, 版本, 状态</div><div class="line">                          Server: bfe/1.0.8.18</div><div class="line">                          Date: Tue, 24 Jan 2017 02:26:34 GMT # 时间</div><div class="line">                          Content-Type: text/html;charset=utf-8 # 内容类型, 字符集</div><div class="line">                          Transfer-Encoding: chunked # 传输编码类型</div><div class="line">                          Connection: keep-alive # 连接类型</div><div class="line">                          Cache-Control: private # 缓存控制</div><div class="line">                          Expires: Tue, 24 Jan 2017 02:26:34 GMT # 过期时间</div><div class="line">                          Content-Encoding: gzip # 内容编码</div><div class="line">                          X-UA-Compatible: IE=Edge,chrome=1 # UserAgent兼容</div><div class="line">                          Strict-Transport-Security: max-age=172800</div><div class="line">                          BDPAGETYPE: 2</div><div class="line">                          BDQID: 0xa98302dc00005b89</div><div class="line">                          BDUSERID: 27620551</div><div class="line">                          Set-Cookie: [19 bytes were stripped] # 设置Cookie</div><div class="line">                          Set-Cookie: [17 bytes were stripped]</div><div class="line">                          Set-Cookie: [54 bytes were stripped]</div><div class="line">                          Set-Cookie: [124 bytes were stripped]</div><div class="line">t=838 [st=143]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_INFO  [dt=0]</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_DATA  [dt=0]</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_INFO  [dt=0]</div><div class="line">t=838 [st=143]      URL_REQUEST_DELEGATE  [dt=1]</div><div class="line">t=839 [st=144]      URL_REQUEST_FILTERS_SET</div><div class="line">                    --&gt; filters = &quot;FILTER_TYPE_GZIP&quot;</div><div class="line">t=839 [st=144]   -URL_REQUEST_START_JOB</div><div class="line">t=839 [st=144]    HTTP_TRANSACTION_READ_BODY  [dt=0] # 读取Body</div><div class="line">t=839 [st=144]    HTTP_CACHE_WRITE_DATA  [dt=0] # 写缓存, 下面还有几次读取Body和写缓存</div><div class="line">t=840 [st=145]    URL_REQUEST_JOB_FILTERED_BYTES_READ</div><div class="line">                  --&gt; byte_count = 11343</div><div class="line">t=840 [st=145]    HTTP_TRANSACTION_READ_BODY  [dt=0]</div><div class="line">t=840 [st=145]    HTTP_CACHE_WRITE_DATA  [dt=0]</div><div class="line">t=844 [st=149] -REQUEST_ALIVE</div></pre></td></tr></table></figure></p>
<p>所以可以看到我们客户端的请求是一个比较简单的结构Header, 而主机返回的报文分成Header和Body两个部分. 先看我们发送的Header.  </p>
<p>发送Header这个行为类型是<code>URL_REQUEST_START_JOB</code> <code>HTTP_TRANSACTION_SEND_REQUEST</code>, 我们发送的Header中method是GET, 表明我们想从服务器获取数据, http协议中允许的方法有以下几种:  </p>
<ul>
<li>GET: 用来请求访问已被URL识别的资源  </li>
<li>POST: 用来传输实体的主体  </li>
<li>PUT: 用来传输文件  </li>
<li>HEAD: 和GET方法一样，只不过不返回实体报文  </li>
<li>DELETE: 用来指定删除文件，与PUT方法相反  </li>
<li>OPTION: 用来查询针对请求URL指定的资源支持的方法  </li>
<li>TRACE: 让web服务器端将之前的请求通信还回给客户端的方法  </li>
<li>CONNECT: 要求的与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信  </li>
</ul>
<p>发送的包是否有消息体(Body)取决于方法, GET方法没有消息体, POST方法就有消息体. host是请求的主机, DNS域名解析, Socket连接建立等过程我们不去探究, 我们只要知道它代表了谁来处理这次请求. 接着看到了Connection, 这个字段表示连接选项, 可以告诉服务器怎么对待这次连接, 有<code>close</code>和<code>keep-alive</code>两种模式, 在0.9/1.0版本时, http连接默认是完成之后立即关闭, 需要设置为<code>keep-alive</code>模式才能保持连接, 在1.1以后, http连接默认就是<code>keep-alive</code>模式, 需要设置<code>close</code>模式才能断开连接. <code>keep-alive</code>的连接数过多的话就会引起服务器性能问题, 同一个页面如果交互次数多而不设置<code>keep-alive</code>的话, 会造成响应过慢的问题, 因为每次请求数据都要重新经历一次建立连接的过程. 注意, 即使设置了<code>keep-alive</code>也不能一定保证连接被保持. 用户代理(<code>User-Agent</code>)代表使用的软件(例如浏览器)是什么类型, 通过UA服务器可以区别对待响应内容, 比如Android系统/Chrome浏览器, 或者Mac系统/Safari浏览器等. Accept段表示可接受的媒介数据类型, 例如网页, 图片, 应用, 音频等. Accept-Encoding与之类似, 不过限制的对象是响应中的消息体编码, 例如允许gzip压缩文件等. Accept-Language表示页面语言, 没什么好说的, 注意它不同于页面编码.<br>至此Header内容就没有了, 如果是POST请求那么在此之后还有一个消息体代表要传输的内容.  </p>
<p>接下来我们看服务器给回来的响应<code>Response</code>的格式(这里就不贴内容了, 依旧用chrome查看响应包), 其实可以看出它的格式与http请求的格式非常类似, 只不过多了一些响应状态的数据. 仍然先看Header, 第一行是响应协议, 响应状态代码, 以及响应状态. http的响应状态是一个三位数的数字编码, 大致意思是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1xx：指示信息--表示请求已接收, 继续处理.</div><div class="line">2xx：成功--表示请求已被成功接收、理解、接受. # 正常状态就是200</div><div class="line">3xx：重定向--要完成请求必须进行更进一步的操作. # 例如重定向301 302</div><div class="line">4xx：客户端错误--请求有语法错误或请求无法实现. # 403 404就在这里</div><div class="line">5xx：服务器端错误--服务器未能实现合法的请求. # 500 Internal Server Error在这里</div></pre></td></tr></table></figure></p>
<p>然后给了响应时间, 返回内容的类型(<code>text/html</code>)和编码(<code>utf-8</code>). 接着是Transfer-Encoding, 值为<code>chunked</code>. 这是一个比较重要的字段, 它代表这个响应本身以什么方式进行”传输编码”, 以保证能够正确传输. 例如, 这里的<code>chunked</code>代表要传输的消息体被分成一系列块(chunk)来传输, 每个块有自己的块长度, 这就是”流模式(streaming)”. 这意味着动态产生的内容就算很长, 并且服务端预先无法知道总长度, 也可以通过这种方式到达客户端, 只要它包含客户端用以判断是否传输完成的必要信息. 这个值也意味着会有后续消息传输, 也意味着连接应该被保持. 文档指出, http1.0及更旧版本的应用可能无法识别<code>Transfer-Encoding</code>这个属性. 后面的内容几乎是对应请求中的可接受内容相应值了, 同时这个响应还设置了cookie值. cookie这个东西挺有意思的, http是无连接的协议, 但有时候又真的需要一些已经生成的信息, 所以就需要把这些未来会用到的信息保存下来, cookie就起这么个作用. 再往后就是消息体了, 消息体里面会包含例如本段消息长度, 下段消息编号, 等这样的信息.  </p>
<p>在http协议中, 没有对请求URL的长度和消息体的长度做任何限制, 但在实践中由于缓存, 性能, 传输效率, 安全等实际需求, 一般对URL长度和消息体大小都会做一定的限制, 这种限制既有客户端(浏览器)限制, 又有服务端限制. 另外, 从前面可以看出, cookie是放在请求的Header中一起发出的, 所以如果对请求Header大小有限制的话, 势必对cookie总大小也有限制. 实际上多数浏览器也确实限制了同一个域下cookie的数目.  </p>
<p>这就是一次URL请求和响应的全部内容. 平时我们用到GET, POST, <code>keep-alive</code>等方法和属性比较多, 可能对其他几种方法和属性不太熟悉.  </p>
<p>讲完了http协议格式, 现在来看https. https又叫 <code>HTTP over TLS</code>, 顾名思义是建立在一层TLS之上的http. TLS全称 Transport Layer Security, 传输层安全协议, 它的前身是SSL, Secure Sockets Layer. HTTPS协议下的URI格式与HTTP完全相同, 只不过它指示浏览器用一层SSL/TLS加密层来保护网络传输. HTTPS协议中, 在传统的HTTP之上又加了一层SSL/TLS, 所以说实现上是SSL/TLS在http之上, 逻辑上是http在SSL/TLS之上. SSL/TLS层创建了一个客户端和服务端之间的隧道, 所有传输都在这个隧道中完成, 这意味着http协议中传输的一切内容, 包括url, 都可以被加密(主机地址和端口号除外, 因为他们是TCP/IP协议的必需部分, 这意味着ip和端口可能被攻击者替换). SSL/TLS层负责服务端信任和传输安全保证.  </p>
<h3 id="http基础-http2-0"><a href="#http基础-http2-0" class="headerlink" title="http基础: http2.0"></a>http基础: http2.0</h3><p>以下内容主要参考<a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank" rel="external">Http2-Wiki</a> <a href="https://http2.github.io/http2-spec/" target="_blank" rel="external">HTTP/2 Spec</a>和<a href="http://blog.csdn.net/pangqiandou/article/details/53098962" target="_blank" rel="external">http协议揭秘</a>  </p>
<p>理解了1.1协议之后, 2.0版本的协议就只需要重点看差异. 2.0版本协议是在2015年发布的, 正式名称是<code>HTTP/2</code>, 因为计划中不再有子版本, 下个版本的HTTP协议主版本号将是3. 在HTTP/2出现之前, 最流行的http1.1协议, 同一个TCP连接里面, 所有数据通信按次序进行, 服务器只有处理完一个回应, 才能进行下一个回应, 任意一个回应都可能成为瓶颈造成阻塞, 造成传输效率底下. 由于这是http1.1协议的缺陷, 因此我们只能设法避开这个问题, 一般有两个思路, 一是减少请求数, 二是多个持久连接, 很多网页优化技巧就是在此基础上开发出来的, 比如合并脚本和样式表, 将图片嵌入css代码, 域名分片等. 2009年, Google公开了它自主研发的SPDY协议, 其主要目的就是解决http1.1协议效率不高的问题, 并且在彼时已经在chrome浏览器上证明了其可行性. SPDY协议被当做HTTP/2协议的基础, 其主要特性在HTTP/2中都有体现.<br>相比http1.1, http/2有以下不同:  </p>
<ul>
<li>纯二进制.<br>在http1.1中头信息可以是文本(ASCII编码), 消息体可以是文本或二进制, 在http/2中, 头信息和消息体都是二进制, 被称为头信息帧(header frame)和数据帧. 这样做可以定义更多种类型的帧, 根据帧类型进行二进制数据解析, 显然比通过文本来获得数据类型, 再进行解析要快捷得多.  </li>
<li>多工.<br>HTTP/2复用TCP连接, 在同一个连接里, 客户端和服务端都可以同时发送多个请求或响应, 而且不用按照顺序. 例如, 服务器同时收到A请求和B请求, 先响应A请求, 发现非常耗时, 于是把A请求已经处理好的部分发送回去, 再响应B请求并处理, 完成后发送A请求剩下的部分. 这样同时允许上行和下行数据的通信方式叫做双工通信, 服务器可以和多个客户端建立这种通信, 因此叫多工.  </li>
<li>数据流.<br>HTTP/2中数据表不按顺序发送, 因此同一个连接里面连续的数据包可能属于不同的响应, 因此在数据包中有做标记表明它属于哪个响应. HTTP/2将一次响应对应的所有数据包, 称为一个数据流(stream), 每个数据流都有独一无二的编号, 每个数据包都必须标记数据流ID. 约定客户端发送的数据流ID一律为奇数, 服务端发送的则为偶数. 在http1.1中要在发送数据的中途取消数据发送, 唯一的方式就是关闭TCP连接, 但http/2中允许在任意时刻由任意一方发送取消信号(RST_STREAM帧)来取消数据流传输, 并且保持TCP连接活跃.  </li>
<li>头信息压缩.<br>http1.1协议中, 由于连接本身不带状态, 所以每次请求都需要携带全部必须信息, 实际情况是同一次TCP连接时候携带的cookie, user agent这些信息往往是不变的, 导致不必要的重复发送, 浪费了带宽. 在http/2中, 引入头信息压缩机制, 一方面, 头信息被gzip或compress压缩后再发送, 另一方面, 客户端和服务端同时维护一张头信息表, 所有字段都会存入这个表, 生成一个索引号, 多次发送只发送索引号而不必发送重复的字段.  </li>
<li>服务器推送.<br>http/2允许服务器主动向客户端发送资源, 即服务器推送(Server Push). 例如, 客户端请求一个页面, 该页面包含很多静态资源. 正常情况下客户端必须解析完返回的html之后, 再根据内容去请求静态资源, 但在http/2协议下, 服务端可以预判客户端在请求该网页后很可能会再次请求静态资源, 因此可以主动把静态资源跟网页一起发送给客户端.  </li>
</ul>
<h2 id="Android中流行的网络框架使用方法及其设计思想"><a href="#Android中流行的网络框架使用方法及其设计思想" class="headerlink" title="Android中流行的网络框架使用方法及其设计思想"></a>Android中流行的网络框架使用方法及其设计思想</h2><p>在Android源码中, 有两种访问网络的方式, 一种是使用<code>HttpClient</code>, 另一种是<code>HttpURLConnection</code>, Google曾选择前者, 后来切换到了后者, 原因见<a href="https://android-developers.googleblog.com/2011/09/androids-http-clients.html" target="_blank" rel="external">这篇文章</a>, 大体是说<code>HttpClient</code>好是好bug也少但是太重, 相比之下Android上使用更轻量级的<code>HttpURLConnection</code>更合适. 在我看来技术本身没有好与不好之分, 只有合不合时宜, 至今我没有改变过这个看法. <code>HttpClient</code>是从Java继承来的, 是Apache基金会负责维护的网络客户端, 它好不好, 当然好, 大量的人在让它变得更好. 但是正因为它用的地方太广了, 需要照顾的人群和情景太多, 所以它在任何特定的情境下都很难作为最好的选择, 例如移动开发. 哪怕是它的兄弟项目<code>AndroidHttpClient</code>专门为Android而生, 也仍然携带了太多API内容, 以至于Android项目如果要使用它, 就会受到它的掣肘. 相反, <code>HttpURLConnection</code>提供的API就要少得多, 这让Android系统团队对它的扩展要容易得多.<br>我们打开SDK中的<code>HttpURLConnection</code>这个类, 可以发现它提供的API确实少, 它连同它的父类<code>URLConnection</code>提供的API都主要是面向上面我们介绍的http协议格式的, 可以很明确地知道我们如何调用它的API来构造一个URL请求.<br>一次网络请求很简单, 但是我们面临的问题往往是复杂的多次网络请求, 比如下载, 比如图片, 比如很多很多其他情况, 这就要求我们对所有需要的网络连接进行管理, 什么时候该开新长连接, 什么时候该关闭, 什么时候该新开线程运行, 什么时候需要缓存, 如何处理异常返回码等等, 而这里面大多数工作其实跟我们的业务没有什么关系. 做网络请求管理, 是一件令人心烦的事情, 有烦心事就会有人想要去解决, 于是Android上出现了诸多网络通信的库, 他们提供更高层级的封装和抽象, 面向业务逻辑而不是http报文格式来设计API. 他们提供缓存机制和连接管理机制, 他们让我们不需要关心网络连接的细节, 只需要关注业务逻辑.<br>下面我们就简单介绍其中较为流行的几种框架.  </p>
<h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>名声很大, 大到什么程度呢? 一问你们用的什么网络框架, Volley都会出现在备选中. 它跟OkHttp应该算是两个主流网络请求框架了. 它是谷歌的亲儿子, 在2013年随着Google I/O推出, 作为一个网络请求模块, 独立于Android系统之外, 它像是把<code>AsyncHttpClient</code>和<code>Universal-Image-Loader</code>的优点都集于一身, 可以简单地进行http通信, 也可以轻松加载网络图片. Google出品不敢说全都是精品, 但至少是一流.<br>Volley在<code>HttpURLConnection</code>基础之上, 设计了简单易用的API, 同时在性能方面也有大幅优化, 设计目标是处理数据量不大但通信频繁的网络操作, 对于大数据量的网络操作则并不擅长.<br>频繁请求的场景是非常常见的, 例如新闻订阅, 定期更新的任何场景, 实时类应用, 像微博啊Twitter之类的都属于这一类.  </p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>既然是独立模块, 自然需要单独下载安装使用.<br>本节主要参考<a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Volley官方文档</a><br>我们可以通过源码下载Volley库:  </p>
<pre><code>git clone https://android.googlesource.com/platform/frameworks/volley
# 或者 https://github.com/google/volley
</code></pre><p>再用Android Studio或者SDK把它导出为jar包, 或者直接将这个库作为library module依赖.<br>也可以使用官方给出的gradle依赖配置:  </p>
<pre><code>compile &apos;com.android.volley:volley:1.0.0&apos;
</code></pre><p>也可以使用别人放在Maven仓库的包(这个是个人行为, 不是官方放上去的, 并且现在已经停止维护了)  </p>
<pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.6&apos;
</code></pre><p>这位作者把Volley放到了Github上, 地址是 <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>, 感谢他.<br>我们将会以一次Get请求和/或一次Post请求为例, 来说明Volley以及接下来几个框架的基本使用方法.  </p>
<pre><code>//简单的 GET 请求
mQueue = Volley.newRequestQueue(getApplicationContext());  
mQueue.add(new JsonObjectRequest(Method.GET, url, null,  
            new Listener() {  
                @Override  
                public void onResponse(JSONObject response) {  
                    Log.d(TAG, &quot;response : &quot; + response.toString());  
                }  
            }, null));  
mQueue.start();
</code></pre><p>这个例子是我在<a href="http://www.codeceo.com/article/android-network.html" target="_blank" rel="external">这篇文章</a>里摘抄的. 从这些代码我们可以猜测一些东西(由于本文不涉及Volley源码解析, 所以我也还没读过源码, 只能猜测, 之后我会抽空把Volley源码和OkHttp源码都走一遍):  </p>
<ol>
<li>Volley类恐怕是单例, 甚至不提供实例, 只提供静态方法. 原因是构造请求队列时调用静态方法, 使用了Context信息, 而且这个例子中使用的是Application Context, 在我有关Context的分析文章中说过, 这个Context实际就是整个Application.  </li>
<li>基于接口. 显而易见, 就连响应类型都已经有预定义的接口了, 需要什么类型的请求直接找Volley的API就搞定, 而且显然即使官方没有也一定有人做了基于泛型的自定义接口. Volley在定义好这些接口之后, 基于这些接口就可以把缓存/并发/性能优化/图片优化/连接管理等功能给做了, 而完全不必关心请求具体是什么样子. 另外, 从队列add方法中新建的匿名类的回调来看, Volley的工作模式显然是异步的.  </li>
<li>轮询. 这个是基于最后一句的猜测, 队列调用了start()方法想必是开始处理请求了, 这一点非常像Handler的使用中调用Looper.loop()方法开始处理消息队列, 所以这么猜测.  </li>
</ol>
<p>可以看到, 相较于HttpURLConnection, Volley的网络请求构造起来就简单多了, 任何细节我们都不必关心, 只需要给出最基本的参数(Method, URL)和一个回调.  </p>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>本节主要参考<a href="http://www.cnblogs.com/yueyanglou/p/5446464.html" target="_blank" rel="external">Volley设计思想和流程分析</a>  </p>
<p><style><br>img {<br>    width: 600px;<br>    height: 400px;<br>}<br></style><br><img src="/images/blogs/volley.png" alt="volley原理图"><br>啊这是个视频截图.  </p>
<p>Volley中的请求数据流在<strong>RequestQueue</strong>中, 一切故事都围绕它展开. 原理图中我们可以看到Volley被设计为三种线程下的分工, 第一种当然是UI线程, 它负责将新产生的请求加入到请求队列, 以及对请求的响应做处理. 第二种是cache thread, 它负责请求及其响应的缓存. 第三种是网络线程, 它负责实际分发网络请求, 响应解析, 以及写缓存.  </p>
<p>在故事开始, 我们通过<code>Volley.newRequestQueue</code>生成了一个请求队列, 并且如果打开源码稍微看一下就会知道Volley在此时就帮我们创建了缓存数据结构(<code>DiskBasedCache</code>)和网络连接线程池, 建立好请求队列之后, 我们同时拥有了缓存请求队列(在缓存线程)和网络请求队列(在网络线程).  </p>
<p>接下来就是处理这些请求. 两种请求对应两种线程, <code>CacheDispatcher</code>处理缓存请求, 传入缓存请求队列和网络请求队列, 这两个队列的具体实现请看源码. 它先从缓存请求队列取出缓存请求, 在缓存中查找请求, 如果命中, 则直接从缓存取得响应进行分发, 如果没有命中或者缓存已过期, 则把这个请求放到网络请求队列中. <code>NetworkDispatcher</code>处理网络请求队列, 它先从网络请求队列中获取请求, 使用网络连接池进行实际的网络请求, 请求完成后如果返回结果可以缓存则存入缓存, 最后将响应结果分发.  </p>
<p>到这里, Volley的魔术就只剩三个地方了: Cache管理, Request定义, 以及Request执行. 这是Volley高效的秘密所在. 先说Request执行. Volley定义了<code>HttpStack.performRequest</code>接口帮助定义Request执行过程, Request执行阶段, 默认的<code>HttpStack</code>实现会通过这个接口获取到Request实例和Headers, 构造http请求, 然后获取到响应的Response二进制流. 随后它调用Request的<code>parseNetworkResponse</code>将响应按照格式进行解析, 得到数据实体.  </p>
<p>来看<code>Request</code>定义. Volley中预定义了几种常用的请求, 例如<code>StringRequest</code>, <code>JsonRequest</code>等, 所有这些请求中都有一个<code>Listener&lt;T&gt;</code>参数, T是请求所预期的返回数据类型. 这个参数就是我们在上面示例代码中添加的回调了, 在解析完<code>Response</code>之后, Volley便会调用<code>Request.deliverResponse</code>方法分发响应, 这跟<code>Handler</code>是不是很像? 在该方法中, 就是调用了<code>Listener.onResponse</code>来处理响应. 针对不同的请求, 可以对<code>Request</code>的定义有特定的优化.  </p>
<p>再看缓存<code>Cache</code>. 前面说了, Volley默认使用<code>DiskBasedCache</code>作为缓存的数据结构. 这里我们不去看它的具体实现, 其实它不见得是最佳选择. 我们重点来看在整个请求生成到执行过程中Cache的作用. 假如没有缓存那么每次请求都会实实在在地被执行, 这在对某一静态资源做多次请求的时候显然不合适, 造成带宽和性能浪费. 缓存在这里的作用就是, 在每次新的请求发生的时候, 先检查是否可以由缓存提供响应, 如果可以就不会执行网络请求了, 这样网络负载就转化成了缓存读取负载, 在<code>DiskBasedCache</code>中就是文件读取负载(因为它把缓存写在了文件里). 在每次真正执行了请求之后, 如果请求预先设置了要进行缓存, 就会把这次请求的url连同它的响应, 包上一个<code>CacheHeader</code>(内含缓存大小等属性), 写入到SD卡中, 并在内存中保存一份<code>&lt;URL, CacheHeader&gt;</code>的映射, 用以判断是否存在缓存以及缓存是否有效.  </p>
<p>关于缓存更详细的内容参见<a href="http://www.voidcn.com/blog/yuan514168845/article/p-4950325.html" target="_blank" rel="external">Volley的cache之硬盘缓存–DiskBasedCache</a>  </p>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>前面说了Volley的原理, 基本上也就展现了它的优点: 面向<code>Request</code>接口, 灵活度高, 对<code>Request</code>有多个封装, 可以取消请求, 有缓存, 可以设置请求优先级, 可以有多个并发的网络连接, 自动异步执行等等. 它当然也有一些缺点或者说不足:  </p>
<ol>
<li><code>ImageRequest</code>, <code>ImageLoader</code>仍然不够高效. 这都是因为后来出了更高效的框架, 技术世界就是这样, 不服老不行.  </li>
<li>默认不支持<code>https</code>  </li>
</ol>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>大神<code>JackWharton</code>出品(他的其他”小作品”还包括: <code>Retrofit</code>, <code>Butterknife</code>, <code>ActionBarSherlock</code>, <code>DiskLruCache</code>… Github上年提交3k+, 精力之旺盛, 执行力之强, 我辈典范).  </p>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用方法参见我另一篇博客<a href="https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/">OkHttp源码探索</a>  </p>
<h4 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h4><p>设计思想其实在上面那篇博客的<code>OkHttp</code>架构图中可以看出. 总的来说是在<code>http/https/SPDY</code>协议基础上做了一层一对一的封装, 接管了缓存管理/请求管理/连接管理/响应解析等环节, 并分别进行了优化, 如多线程并发的请求和连接, 基于<code>DiskLruCache</code>的缓存管理, 非UI线程的响应等.  </p>
<h4 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h4><p><code>OkHttp</code>的优点是好用的同时保留了几乎和<code>HttpURLConnection</code>一样的接口, 学习成本较低, 但同时缺点也是它: API更接近协议, 对用户不够友好, 我们需要处理较多不属于业务的内容.  </p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p><code>Retrofit</code>其实是在<code>OkHttp</code>这样一个Http封装库的基础上再进行的一次封装(当然你也可以用别的方式完成请求), 它更多的是面向业务流程而非协议细节, 所以比上面两个妖艳贱货要高一个层次.  </p>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>Retrofit</code>和<code>OkHttp</code>都是属于<code>Square</code>公司的开源项目, 主力开发同样是<code>JackWharton</code>, 令人敬佩的同时也就理解了它为什么默认采用<code>OkHttp</code>作为底层请求库. 不得不说<code>Okio+OkHttp+Retrofit</code>这套组合不仅好用而且足够灵活和容易扩展, 是开源世界一道优美的风景.  </p>
<h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>见我另一篇博客<a href="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/">Retrofit源码探秘</a>  </p>
<h4 id="设计思想-2"><a href="#设计思想-2" class="headerlink" title="设计思想"></a>设计思想</h4><p><code>Retrofit</code>将网络请求彻底视为<code>路径/参数/响应函数</code>的组合, 于是采用了<code>annotation</code>的方式来描述网络请求, 并用它来标注响应函数, 而把一切构造请求和获取响应的过程都藏到了身后, 开发者不需要知道背后的任何细节.<br>这其实跟<code>Flask</code>的服务端的思路有点相似.  </p>
<h4 id="局限-2"><a href="#局限-2" class="headerlink" title="局限"></a>局限</h4><p><code>Retrofit</code>的好处是隐藏了一切细节, 一切<code>dirty work</code>, 你只需要按照特定格式使用注解去定义一个请求, 其他的事情都可以交给他来做. 同时它保留了足够的灵活性和可扩展性, 实际的请求是由一个单独的请求工具完成的, 这个工具可以换成适合你业务的任意其他工具, 只需要实现一层中间接口.<br>以上都是它的优点, 那么它的缺点在哪里呢?<br>曾经的它无法取消正在进行的请求(而<code>OkHttp</code>是可以的), 也无法仅获取<code>Json</code>格式的字符串返回结果(它会自动使用<code>Gson</code>去解析成实例对象), 然而<code>2.0+</code>版本以后, 请求接口重新定义了之后已经可以像<code>OkHttp</code>那样轻松地取消请求, 同时它去掉了自动, 默认仅仅解析为字符串, 你需要自行添加对应<code>Converter</code>库依赖才能使用它为你实现的解析器, 或者你也可以自行实现一个解析器.<br>然而它依然有一些限制, 例如<code>interface</code>不能继承其他的<code>Interface</code>. 这还算可以接受, 毕竟每个业务完全应该有一套单独的业务接口, 应该通过接口的组合而不是继承来使用接口, 也许它现在最大的缺点就是<code>1.x</code>和<code>2.x</code>完全不兼容了(就连这一点, 它也有提供向下兼容的API库来解决).  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/android/" target="_blank" rel="external">Android源码</a>  </li>
<li><a href="https://developer.android.com/guide/index.html" target="_blank" rel="external">Android官网介绍</a>  </li>
<li><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="external">Android网络请求心路历程</a>  </li>
</ul>
<p><hr><br>update: 2017-02-27 我把<code>OkHttp</code>的源码大致走了一遍, 记录在<a href="https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/">这里</a><br>update: 2017-02-28 我把<code>Retrofit</code>的源码大致走了一遍, 记录在<a href="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/">这里</a>  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Android系统下网络请求的多种姿势
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android源码伴读】OkHttp源码探索</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/27/%5BAndroid%E6%BA%90%E7%A0%81%E4%BC%B4%E8%AF%BB%5DOkHttp%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2017-03-05T11:15:02.011Z</updated>
    
    <content type="html"><![CDATA[<p><code>OkHttp</code>是一种面向<code>http</code>协议的高效网络请求库, 下面我们就来探索它的源码, 找到它高效的秘密.<br>源码github地址: <a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a>  </p>
<h2 id="OkHttp的使用"><a href="#OkHttp的使用" class="headerlink" title="OkHttp的使用"></a>OkHttp的使用</h2><p>这一节是为了那些从未用过<code>OkHttp</code>而写, 如果您已经可以很熟练地使用<code>OkHttp</code>, 这节的内容不适合您.<br>可以通过配置<code>build.gradle</code>指定使用<code>OkHttp</code>.<br><code>OkHttp</code>采用<code>Builder</code>模式构造请求, 它可以做的事情在<code>public static class Builder</code>这个内部类中都告诉你了, 接口对应了<code>http</code>协议请求的内容. 也就是说, 你必须要了解<code>http</code>协议以及你想要构造的请求的具体内容, 才能很方便地使用<code>OkHttp</code>, 这就是我说<code>OkHttp</code>是面向<code>http</code>协议的请求库的原因. 直观上来说, 它把构造请求和获取响应的操作简单化了.<br>更多使用教程参见<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a>.  </p>
<p>不仅如此, 查看它的<a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="external">文档</a>, 可以发现它定义了大约50个类, 除了常规的几个<code>Builder</code>类和<code>Factory</code>类以外, 其他类都是面向网络请求某一方面的. 从类名来看, 涵盖了请求, 响应, 回调, 鉴权, 加密, 证书, 连接池, Cookie, Dns, Tls, MultipartBody等方面. 可以很明显感受到它支持<code>Https</code>和<code>Http/2</code>协议. 据<a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">OkHttp源码解析</a>所述, 它也同时支持<code>SPDY</code>.  </p>
<h2 id="OkHttp源码探索"><a href="#OkHttp源码探索" class="headerlink" title="OkHttp源码探索"></a>OkHttp源码探索</h2><p>废话少说, 我们现在就开始源码探索. 在探索之前, 先对<code>OkHttp</code>工作流, 也就是它的模型有一个整体的认识, 见下图:<br><img src="/images/blogs/okhttp_workflow.png" alt="okhttp-workflow">  </p>
<p>上图来自<a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">这篇博客</a>, 很可惜博客已经过时了, 特别是<code>HttpEngine</code>已经被三个新的拦截器所取代, 不过架构还是没有变的.  </p>
<h3 id="OkHttp请求分发类Dispatcher"><a href="#OkHttp请求分发类Dispatcher" class="headerlink" title="OkHttp请求分发类Dispatcher"></a>OkHttp请求分发类Dispatcher</h3><p>以下我们将介绍<code>OkHttp</code>中的类源码, 重点来介绍<code>OkHttp</code>为了优化网络请求做了哪些工作.<br>在发起一个请求的时候, 是调用<code>OkHttpClient.newCall().enqueue(Callback)</code>来入队一个异步请求, 其中调用<code>Dispatcher.enqueue(AsyncCall)</code>执行真正的入队操作. 我们来看看<code>Dispatcher</code>的注释:  </p>
<pre><code>
/**
 * Policy on when async requests are executed.
 *
 * &lt;p&gt;Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
 * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
 * of calls concurrently.
 */
</code></pre><p>这个分发器负责调度和并发执行请求, 看描述我们大致能猜到它内部使用了<code>ExecutorService</code>去执行请求队列. 打开文件发现它是直接<code>new ThreadPoolExecutor</code>来初始化的, 不限制线程池容量, 使用<code>SynchronousQueue</code>作为底层结构, 自行维护一个<code>maxRequests</code>来限制正在执行的请求的最大数量. 调用<code>enqueue()</code>将准备好的请求加入到正在执行的请求队列中并调用<code>executorService().execute(call)</code>执行(我们知道, 这里面就是把要执行的<code>Runnable</code>加入到队列中,等待被调度到的时候调用<code>Runnable.run()</code>接口).  </p>
<p><code>AsyncCall</code>是<code>RealCall</code>的内部类, 在<code>enqueue</code>的时候实际上就是将一个<code>AsyncCall</code>实例入队到<code>ExecutorService</code>的队列中, 反而没<code>RealCall</code>什么事. <code>AsyncCall</code>继承自<code>NamedRunnable</code>, 而<code>NamedRunnable</code>显然继承自<code>Runnable</code>, 并且在它里面把<code>run()</code>方法实现为调用<code>execute()</code>方法. 这就使得<code>ExecutorService</code>通过调用<code>run()</code>方法最终会调用到<code>AsyncCall.execute()</code>方法. 那外层的<code>RealCall</code>又有什么用呢? 其实它提供了一个同步的<code>execute()</code>方法可以让<code>RealCall</code>实例立即被加入到执行队列中, 并等待返回.<br>下面我们来看<code>RealCall</code>的代码.  </p>
<pre><code>
// in file okhttp3/RealCall.java

 @Override public Response execute() throws IOException {
   synchronized (this) {
     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
     executed = true;
   }
   captureCallStackTrace();
   try {
     client.dispatcher().executed(this);
     Response result = getResponseWithInterceptorChain();
     if (result == null) throw new IOException(&quot;Canceled&quot;);
     return result;
   } finally {
     client.dispatcher().finished(this);
   }
 }

 @Override public void enqueue(Callback responseCallback) {
   synchronized (this) {
     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
     executed = true;
   }
   captureCallStackTrace();
   client.dispatcher().enqueue(new AsyncCall(responseCallback));
 }

   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;

     AsyncCall(Callback responseCallback) {
       this.responseCallback = responseCallback;
     }

     ......

     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
         } else {
           signalledCallback = true;
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
         } else {
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
         client.dispatcher().finished(this);
       }
     }
   }
</code></pre><h3 id="OkHttp请求执行和响应"><a href="#OkHttp请求执行和响应" class="headerlink" title="OkHttp请求执行和响应"></a>OkHttp请求执行和响应</h3><p> 现在我们了解了请求的并发执行, 我们再来看连接. 上述过程中好像没有看到哪里有管理连接的内容? 别急, 我们一步一步来, 先找到第一个返回<code>Response</code>的地方. 经过上述观察我们发现在<code>getResponseWithInterceptorChain</code>方法第一次得到<code>Response</code>. 在这个方法里面, 用了一系列拦截器(<code>Interceptor</code>)来初始化一个<code>RealInterceptorChain</code>实例, 并通过该实例的<code>proceed()</code>方法获得了<code>Response</code>. 打开<code>RealInterceptorChain.proceed</code>可以发现它是对<code>RealInterceptorChain</code>链上的<code>Interceptor</code>逐个地使用同一套连接参数去初始化和调用<code>intercept()</code>方法, 那么具体拦截下来做什么, 就得看具体<code>intercept</code>中的行为了. 这里可以看到拦截器链首先是添加了<code>Client</code>上的拦截器, 然后加上<code>retryAndFollowUpInterceptor</code>和另外三个拦截器. 我们看看默认的拦截器都有哪些:  </p>
<pre><code>
OkHttpClient(Builder builder) {
  this.dispatcher = builder.dispatcher;
  this.proxy = builder.proxy;
  this.protocols = builder.protocols;
  this.connectionSpecs = builder.connectionSpecs;
  this.interceptors = Util.immutableList(builder.interceptors);// 初始化拦截器
  this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
  this.proxySelector = builder.proxySelector;
  this.cookieJar = builder.cookieJar;
  this.cache = builder.cache;
  this.internalCache = builder.internalCache;
  this.socketFactory = builder.socketFactory;

  boolean isTLS = false;
  for (ConnectionSpec spec : connectionSpecs) {
    isTLS = isTLS || spec.isTls();
  }

  if (builder.sslSocketFactory != null || !isTLS) {
    this.sslSocketFactory = builder.sslSocketFactory;
    this.certificateChainCleaner = builder.certificateChainCleaner;
  } else {
    X509TrustManager trustManager = systemDefaultTrustManager();
    this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
    this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
  }

  this.hostnameVerifier = builder.hostnameVerifier;
  this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
      certificateChainCleaner);
  this.proxyAuthenticator = builder.proxyAuthenticator;
  this.authenticator = builder.authenticator;
  this.connectionPool = builder.connectionPool;
  this.dns = builder.dns;
  this.followSslRedirects = builder.followSslRedirects;
  this.followRedirects = builder.followRedirects;
  this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
  this.connectTimeout = builder.connectTimeout;
  this.readTimeout = builder.readTimeout;
  this.writeTimeout = builder.writeTimeout;
  this.pingInterval = builder.pingInterval;
}
</code></pre><p>直接用的<code>Builder</code>的拦截器, 看一下发现是个空的<code>ArrayList</code>, 好吧, 啥都没有. 那第一个被调用<code>intercept</code>方法的就是<code>retryAndFollowUpInterceptor</code>了. 打开看看发现他是首先分配了一个<code>StreamAllocation</code>, 在流不断开的情况下不断调用传入的拦截器获得响应结果, 并与前面得到的响应结果组装起来, 在无后续响应结果的情况下返回响应.<br> 看来我们还得追踪下一个拦截器, 我估计追踪到最后一个就是实际的连接创建了. 果不其然, <code>BridgeInterceptor</code>作为桥, 将用户请求<code>Request</code>重新构造了一个<code>Request</code>并交给传入的拦截器处理, 对返回的<code>Response</code>也做了处理, 如存<code>Cookie</code>, 构造新的<code>Response</code>等. 它的下一个拦截器是<code>CacheInterceptor</code>, 这个拦截器就是处理缓存的了, 根据我们的缓存策略在缓存表中试图获取缓存的响应并判断是否只需要返回缓存就行了. 如果缓存不适用, 则调用传入的拦截器处理请求, 并根据返回的情况更新缓存时间或重写缓存. 我个人觉得需要注意它代码中多处地方都非常注意关闭缓存, 以防止内存泄漏. 下一个拦截器是<code>ConnectInterceptor</code>, 这应该就是真正发起请求的地方了, 它的代码比意料中少:  </p>
<pre><code>
// in file okhttp3/internal/connection/ConnectInterceptor.java
@Override public Response intercept(Chain chain) throws IOException {
  RealInterceptorChain realChain = (RealInterceptorChain) chain;
  Request request = realChain.request();
  StreamAllocation streamAllocation = realChain.streamAllocation();// #1

  // We need the network to satisfy this request. Possibly for validating a conditional GET.
  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);
  HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); // #2
  RealConnection connection = streamAllocation.connection();// #3

  return realChain.proceed(request, streamAllocation, httpCodec, connection);// #4 注意它虽然调用的是`proceed`而不是`intercept`, 但由于`RealInterceptorChain`中`proceed`的实现就是调用当前`intercept.intercept()`, 所以最终还是走到`intercept()`
}
</code></pre><p>这里关键步骤出来了: 分配IO Stream, Connect, Proceed. 这里传入的拦截器是<code>CallServerInterceptor</code>. 打开分别看看这三步对应的代码. <code>streamAllocation</code>返回的是此次连接的<code>StreamAllocation</code>, <code>connection()</code>返回的也是此次连接, 这两个值从上文可以看到是在<code>retryAndFollowUpInterceptor</code>中就已经初始化了. <code>proceed</code>最终走到<code>CallServerInterceptor.intercept</code>, 代码注释如下:  </p>
<pre><code>
// in file okhttp3/internal/http/CallServerInterceptor.java
@Override public Response intercept(Chain chain) throws IOException {
  HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
  StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
  Request request = chain.request();

  long sentRequestMillis = System.currentTimeMillis();
  httpCodec.writeRequestHeaders(request);

  Response.Builder responseBuilder = null;
  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {
    // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100
    // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return what
    // we did get (such as a 4xx response) without ever transmitting the request body.
    ...

    // Write the request body, unless an &quot;Expect: 100-continue&quot; expectation failed.
    ...
  }

  httpCodec.finishRequest();

  if (responseBuilder == null) {
    responseBuilder = httpCodec.readResponseHeaders(false);
  }

  Response response = responseBuilder
      .request(request)
      .handshake(streamAllocation.connection().handshake())
      .sentRequestAtMillis(sentRequestMillis)
      .receivedResponseAtMillis(System.currentTimeMillis())
      .build();

  int code = response.code();
  if (forWebSocket &amp;&amp; code == 101) {
    // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
    response = response.newBuilder()
        .body(Util.EMPTY_RESPONSE)
        .build();
  } else {
    response = response.newBuilder()
        .body(httpCodec.openResponseBody(response))
        .build();
  }

  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))
      || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {
    streamAllocation.noNewStreams();
  }

  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {
    throw new ProtocolException(
        &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());
  }

  return response;
}
</code></pre><p>厉害了, 原来最后用的是<code>HttpCodec</code>的实例来完成的请求发送和响应接收, 查看它的继承类可以看到<code>Http1Codec</code>和<code>Http2Codec</code>, 明显就是对应两种协议了, 前面在<code>ConnectInterceptor#2</code>的时候实例化了这个编码解码器(实例化过程中通过连接池获取一个可用的连接).<br> 这一条路径下来, 请求构造-&gt;连接构造-&gt;请求发送-&gt;响应接收-&gt;响应解析都完成了, 不得不说大神的代码看起来有点吃力但是非常舒服(拦截器链这一块, 原先曾经是<code>HttpEngine.java</code>完成上文三个默认拦截器的工作, 由<code>Square</code>的另一个大神分解为三个单独的职责分明的拦截器), 逻辑清晰层次分明, 而且还有够用的注释, 吃力主要还是因为自己的抽象能力不足, 对于网络连接的场景需要做什么在心里没有一个完整的模型.<br> 代码中可以看到通过连接池对连接进行了复用, 具体的数据读写使用了<code>Okio</code>(也是<code>Square</code>家的项目).  </p>
<h3 id="OkHttp缓存Cache"><a href="#OkHttp缓存Cache" class="headerlink" title="OkHttp缓存Cache"></a>OkHttp缓存Cache</h3><p>下面看看最后一个重点: 缓存<code>Cache</code>.<br>上文提到, 在<code>CacheInterceptor.intercept</code>中, 会在<code>InternalCache cache</code>中寻找当前请求的缓存, 并获取当前请求的缓存策略(<code>CacheStrategy.Factory(time, request, cacheCandidate).get()</code>), 如果<code>cache</code>不为<code>null</code>调用<code>cache.trackResponse</code>, 其余的判断是否请求被禁止或是否需要缓存等内容我们略过不提, 单看缓存更新<code>cache.update(cachedResponse, networkResponse)</code>和<code>cacheWritingResponse(cacheRequest, response)</code>, 这两种情况都已经访问了网络并获得了响应, 前者的响应表示未更改(状态码304), 客户端应直接读缓存, 所以我们只需要更新缓存的部分内容即可, 后者则需要更新整个缓存的<code>cacheResponse</code>. 两者代码分别如下:  </p>
<pre><code>
// in file okhttp3/Cache.java
void update(Response cached, Response network) {
  Entry entry = new Entry(network);
  DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
  DiskLruCache.Editor editor = null;
  try {
    editor = snapshot.edit(); // Returns null if snapshot is not current.
    if (editor != null) {
      entry.writeTo(editor);
      editor.commit(); // 类似map, 写入缓存. 缓存的默认实现是DiskLruCache  
    }
  } catch (IOException e) {
    abortQuietly(editor);
  }
}

// in file okhttp3/internal/cache/CacheInterceptor.java

  /**
   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
   * may never exhaust the source stream and therefore not complete the cached response.
   */
  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
      throws IOException {
    // Some apps return a null body; for compatibility we treat that like a null cache request.
    if (cacheRequest == null) return response;
    Sink cacheBodyUnbuffered = cacheRequest.body();
    if (cacheBodyUnbuffered == null) return response;

    final BufferedSource source = response.body().source();
    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);

    Source cacheWritingSource = new Source() {
      boolean cacheRequestClosed;

      @Override public long read(Buffer sink, long byteCount) throws IOException {
        long bytesRead;
        try {
          bytesRead = source.read(sink, byteCount);
        } catch (IOException e) {
          if (!cacheRequestClosed) {
            cacheRequestClosed = true;
            cacheRequest.abort(); // Failed to write a complete cache response.
          }
          throw e;
        }

        if (bytesRead == -1) {
          if (!cacheRequestClosed) {
            cacheRequestClosed = true;
            cacheBody.close(); // The cache response is complete!
          }
          return -1;
        }

        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
        cacheBody.emitCompleteSegments();
        return bytesRead;
      }

      @Override public Timeout timeout() {
        return source.timeout();
      }

      @Override public void close() throws IOException {
        if (!cacheRequestClosed
            &amp;&amp; !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
          cacheRequestClosed = true;
          cacheRequest.abort();
        }
        source.close();
      }
    }; // 实现一个读取流, 读取Okio.BufferedSource接口的实例`response.body().source()`

    return response.newBuilder()
        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
        .build(); // 使用以上实现构造RealResponseBody, 传入当前响应, 构造新的响应拷贝
  }
</code></pre><p>其中<code>cache</code>的值是在<code>RealCall</code>中传入<code>new CacheInterceptor(client.internalCache())</code>时初始化的, 其值默认是<code>OkHttpClient.cache.internalCache</code>, 除非<code>cache</code>为空, 彼时会使用<code>OkHttpClient.internalCache</code>. 换句话说, 如果我们初始化<code>OkHttpClient</code>时把<code>cache</code>置空则可以通过设置<code>internalCache</code>使用我们自己的缓存. 事实上<code>OkHttpClient.Builder</code>中这两个缓存正是互斥的:  </p>
<pre><code>
/** Sets the response cache to be used to read and write cached responses. */
void setInternalCache(InternalCache internalCache) {
  this.internalCache = internalCache;
  this.cache = null;
}

/** Sets the response cache to be used to read and write cached responses. */
public Builder cache(Cache cache) {
  this.cache = cache;
  this.internalCache = null;
  return this;
}
</code></pre><p>至此, <code>OkHttp</code>的主干流程已经探索得差不多了, 我们也知道了它提升<code>http</code>效率的主要手段: 复用连接, 并发请求, 缓存响应, 异步响应. 它使得<code>http</code>连接在频繁低载荷或多次连续的数据传输中, 不至于在缓存和重新建立连接上花费太多时间.  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp源码</a>  </li>
<li><a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="external">OkHttp文档</a>  </li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a>  </li>
<li><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">OkHttp源码解析</a>  </li>
<li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="external">OkHttp3源码分析综述</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲OkHttp. 总体来说它是一个高效简洁易用易扩展的网络库.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】View/ViewGroup源码阅读</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/24/%5BAndroid%E6%95%99%E7%A8%8B%5DView&amp;ViewGroup%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/24/[Android教程]View&amp;ViewGroup源码阅读/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-03-05T11:14:44.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文基于Android 4.0 源码</p>
</blockquote>
<h2 id="View与ViewGroup类结构"><a href="#View与ViewGroup类结构" class="headerlink" title="View与ViewGroup类结构"></a>View与ViewGroup类结构</h2><p><img src="/images/blogs/view_and_viewgroup.png" alt="View与ViewGroup的类关系">  </p>
<h2 id="View与Window"><a href="#View与Window" class="headerlink" title="View与Window"></a>View与Window</h2><p>Android系统中所有的UI类都是建立在<code>View</code>和<code>ViewGroup</code>基础上。<code>View</code>的子类包括widget包中的那些(常用的<code>TextView</code>、<code>ImageView</code>等都在这个包下)，<code>ViewGroup</code>的子类包括Layout命名的类以及<code>RecyclerView</code>等少数以View命名的类，<code>ViewGroup</code>又是<code>View</code>的直接子类，这样就允许<code>View</code>和<code>ViewGroup</code>并列与嵌套存在。在AS中可以通过F4查看类的继承关系。  </p>
<p>Window不继承于View，它就是一个用来显示东西的窗口，通过<code>setContentView</code>来显示东西(调用该方法之后紧接着调用<code>initWindowDecorActionBar</code>来设置ActionBar)，<code>Activity</code>自身持有一个<code>mWindow</code>(初始化为<code>PhoneWindow</code>，<code>PhoneWindow</code>的定义在源码目录<code>frameworks/policies/base/phone/com/android/internal/policy/impl/PhoneWindow</code>，它是Window的直接子类，被标注为<code>@hide</code>，SDK看不到，需要下载SDK源码才能看到，在SDK源码的<code>android-23/com/android/internal/policy/PhoneWindow</code>下)，<code>Activity</code>的<code>setContentView</code>就是<code>mWindow.setContentView</code>的代理。<code>PhoneWindow</code>有个<code>DecorView</code>内部类(继承自<code>FrameLayout</code>)，在初始化<code>PhoneWindow</code>的时候会创建一个<code>DecorView</code>的实例作为根视图。  </p>
<p>还有一个类叫做<code>LayoutInflater</code>，它本身是个抽象类，但只有一个<code>cloneInContext</code>是抽象方法。它采用工厂模式负责将布局文件xml实例化为View对象。看它的<code>inflate</code>方法，最终调用的都是<code>View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code>这个方法，用<code>XmlResourceParser</code>从resource中获取parser，然后<strong>同步地</strong>完成这些调用：<br><code>result=root, attrs=Xml.asAttributeSet(parser)</code><br>-&gt; <code>temp=createViewFromTag(root, name=parser.next().getName(), inflaterContext=mContext, attrs)</code><br>-&gt; <code>root!=null?(params=root.generateLayoutParams(attrs);if(!attachToRoot)temp.setLayoutParams(params)):null</code><br>-&gt; <code>rInflateChildren(parser, temp, attrs, true)</code><br>-&gt; <code>if(root!=null &amp;&amp; attachToRoot) root.addView(temp, params); if(root==null || !attachToRoot)result = temp</code><br>-&gt; <code>return result</code><br>大致意思是首先解析xml，找到第一个开始的Tag即布局文件的根视图的标签，把它和布局文件的<code>AttributeSet</code>传给<code>createViewFromTag</code>就获得了布局文件的根View，如果root非空且要附加到root上就把这个View附加上去。在处理Tag时单独处理MERGE和INCLUDE两个Tag。在返回前调用了<code>rInflateChildren</code>方法来填充这个View的子视图，这是个递归填充子视图的方法，根据Tag名分别调用<code>parseRequestFocus parseViewTag parseInclude createViewFromTag&amp;&amp;rInflateChildren</code>来一层层创建View，在<code>finishInflate</code>的时候View提供了<code>onFinishInflate</code>回调供子类重写。  </p>
<p>这里就有三个东西了，Window、Inflater、View，他们之间的关系就好像画布、画笔和成品作品，xml布局文件就相当于设计图，Activity作为画家需要将成品按照设计图一层层画到画布上。<br>给个图来表示：<br><img src="/images/blogs/ActivityWindow.png" alt="ActivityWindow">  </p>
<h2 id="View绘制与重绘过程"><a href="#View绘制与重绘过程" class="headerlink" title="View绘制与重绘过程"></a>View绘制与重绘过程</h2><p><code>inflate</code>只是相当于给画作打了个线稿，规定了要画的内容的层次关系，具体画什么、在哪里画，就是View的绘制过程。Android中为View和ViewGroup设计了一致的绘制流程。绘制视图总要有个开端，仍以Activity为例，前面说到Activity通过<code>setContentView</code>用Inflater把xml导入成View树，这时候我们只是在逻辑上得到了View的结构，还没有实际画到屏幕上。猜想Activity载入了View之后，应该是在某个生命周期的时候绘图，回想Activity总是在onStart之后才能看到Activity内容，跟随Activity的生命周期，猜想是某个Manager比如ActivityManager在控制。随便找了一下Activity的startActivity方法，发现Activity中所有的startActivity实际上都是调用的<code>startActivityForResult</code>方法（它有两个重载），它里面又是调用的<code>Instrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this,intent, requestCode, options)</code>，在这个方法中使用<code>ActivityManagerNative</code>的<code>getDefault().startActivity()</code>真正开始Activity，查看源码知道<code>getDefault()</code>得到的是<code>ServiceManager.getService(&quot;activity&quot;)</code>，是系统提供的名为<code>activity</code>的服务，它经过<code>asInterface</code>转换成<code>IActivityManager</code>接口后作为结果返回，显然它的实现在Server端，同时有内部类<code>ActivityManagerProxy</code>用来调用远程服务，前面分析AIDL和Binder机制时候说过，实际上对远程服务的调用中，系统Binder驱动和Server各持有一个服务的实例，其中系统持有的是代理。通过<code>queryLocalInterface</code>区分是从服务端还是客户端进行服务调用，从服务端调用就直接返回本地服务了，从客户端调用则通过代理来访问服务。  </p>
<p>这里暂时停下，看到有一个<code>ActivityManager</code>类，很有意思，它的内部类AppTask有个<code>startActivity</code>方法，首先获取<code>ActivityThread</code>，再通过<code>Instrumentation.execStartActivityFromAppTask</code>在<code>ActivityThread</code>的<code>ApplicationThread</code>上开始Activity，点进去一看它实际上是调用的参数中的<code>IAppTask.startActivity</code>，回来看传入的参数是<code>mAppTaskImpl</code>，它的值由构造函数确定，而AppTask的构造函数是隐藏的，这很Android。顺藤摸瓜发现它在ActivityManager的getAppTasks方法中调用，实际上是从<code>ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName())</code>得到的任务列表，好嘛，又看到<code>ActivityManagerNative</code>了，可问题在于，这货的AppTask又是从哪儿得到的呢？  </p>
<p>以上花了不少力气，结果只看明白了Activity的启动是系统服务负责的，虽然通过查看SDK源码的<code>ServiceManager</code>找到了启动Activity的系统服务，但是仍然没有看到控制Activity绘制内容的相关代码，解耦解得厉害就是有这点不好，全都是面向接口了不太好找实现。用了一个土方法，根据分包直接去找activity服务的实现代码，感谢Android良好的模块设计，很快就找到了<code>com/android/server/am/ActivityManagerService.java</code>，一看它继承了<code>ActivityManagerNative</code>，稳了。直奔<code>startActivity</code>方法发现原来用的是<code>startActivityAsUser</code>方法，它又调用的<code>ActivityStackSupervisor.startActivityMayWait</code>，这个方法挺长的，关键的一步是调用<code>startActivityLocked</code>，里面调用<code>doPendingActivityLaunchesLocked</code>，它又调用<code>startActivityUncheckedLocked</code>，(一路各种设置flag，最后调用了<code>ActivityStack</code>的<code>startActivityLocked</code>，在Activity当前栈栈顶添加一个<code>ActivityRecord</code>，再调用<code>WindowManager.addAppToken</code>在task中存下Token，并且记录<binder,token>对应关系，有空单独写个Activity的启动，这里就不再说了)，惭愧看很久也没看到开始Activity的具体代码。求助Google，然后得知<code>ActivityThread</code>(同样是<code>@hide</code>，在SDK中看不到)是启动Activity的关键类，它运行<code>performLaunchActivity</code>和<code>handleResumeActivity</code>来创建和启动Activity。看到<code>performLaunchActivity</code>的第一个参数是<code>ActivityClientRecord</code>类型，感觉自己前面的功夫没有白费，在这里连接起来了。这里通过Instrumentation(<code>android/app/Instrumentation</code>)依次创建了<code>Activity</code>、<code>Application</code>和<code>Context</code>，然后又依次调用了Activity的<code>OnCreate</code>、<code>performStart</code>、<code>OnRestoreInstanceState</code>、<code>OnPostCreate</code>。现在还没有调用<code>OnResume</code>，理论上应该还没有绘制内容。<code>performStart</code>方法也只是使用<code>Instrumentation</code>调用了Activity自身的<code>OnStart</code>，并且将Start事件分发到<code>mFragments</code>而已。  </binder,token></p>
<p>来看<code>handleResumeActivity</code>，上来先是一记<code>performResumeActivity</code>(一番状态设置之后调用<code>activity.performResume</code>)，一堆状态读取和设置后，<code>if(r.activity.mVisibleFromClient)r.activity.makeVisible()</code>，这个方法看起来很有希望就是我要找的方法！找去源码一看，方法内容出奇的简单：<code>mDecor.setVisibility(View.VISIBLE)</code>可以说就这么一句。靠！根本还没完！  </p>
<hr>
<p>接着看，原来<code>View</code>的<code>setVisibility</code>所调用的<code>setFlags</code>方法会在传入参数为<code>VISIBLE</code>时调用<code>invalidate(true)</code>方法(顺便一提<code>setFlags</code>方法当然也会处理<code>GONE</code>和<code>INVISIBLE</code>，再顺便一提这就解释了为什么设置可见性后不需要调用<code>invalidate</code>就可以自动重绘)。最终还是走到了View源码。  </p>
<p>打开<code>invalidate(boolean invalidateCache)</code>，调用的<code>invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate)</code>，这里出现了一个神奇的<code>mGhostView</code>，之后还记得的话再来看看它是干嘛用的。<code>l t r b</code>是需要invalidate的区域，<code>invalidate</code>方法传入的直接就是View实例的整个区域。调用<code>mParent.invalidateChild</code>来invalidate给定区域。<code>mParent</code>只是一个<code>ViewParent</code>接口，它具体是指向什么实例还是要看代码。想一想Activity中什么内容都不设置的话，是有一个<code>DecorView</code>和一个id为content的<code>FrameLayout</code>，应该可以在<code>FrameLayout</code>或者<code>DecorView</code>找到具体的实现代码。幸运的是，在<code>FrameLayout</code>的父类<code>ViewGroup</code>中找到了<code>invalidateChild</code>方法(<code>ViewGroup</code>实现了<code>ViewParent</code>接口)。  </p>
<p>方法挺长，拣重点说。parent变量初始化为<code>ViewGroup</code>自身，先标记出dirty区域(为<code>transformMatrix</code>变形后的dirty区域上下左右各扩大0.5f)，然后调用parent的<code>invalidateChildInParent</code>方法对dirty区域进行扩展并将返回值赋予parent，如此往复直到parent为<code>null</code>为止。<code>ViewGroup</code>的这个方法返回<code>mParent</code>成员变量，它是一个隐藏的变量，从它的名字和可能为<code>null</code>来推断应该是会随着这个方法的调用而变化(我猜它会<strong>层层向上</strong>直到根视图<code>DecorView</code>的父<code>ViewRootImpl</code>，这个东西之前没有提过，其实它就是最顶层<code>DecorView</code>所添加到的地方, <code>DecorView</code>实例作为一个成员变量<code>mView</code>存在于它的实例中, 它受到<code>WindowManager</code>的实现类<code>WindowManagerImpl</code>实际上是<code>WindowManagerGlobal</code>的管理，它是逻辑上存在的一个东西，类型也不是View，但实现了<code>ViewParent</code>接口)，且是受系统什么服务控制的，我猜是<code>WindowManager</code>。在这个过程中如果如我所猜是层层向上，那么总会到达<code>DecorView</code>，而<code>DecorView</code>的父就是并不属于View子类的<code>ViewRootImpl</code>，当此时就会调用到<code>ViewRootImpl</code>的<code>invalidateChildInParent</code>方法，有意思的是这个方法最终返回<code>null</code>，这从侧面验证了我的猜测可能是对的。  </p>
<p>这里有一个关键变量，即<code>mAttachInfo.mInvalidateChildLocation</code>，这是一个仅两个元素的整型数组，分别存储child的left和top，从名字看存的是要invalidate的child的位置，真正绘制应该跟这个数组有关。</p>
<p>至此我发现前面整个过程是一个计算dirty区域的过程，想想图形的出现和更新其实都可以看做是对特定区域的绘制，通过计算dirty区域就统一了这两个行为。到了<code>ViewRootImpl</code>总算是计算完了dirty区域，接下来总应该画图了吧。一看果然，在<code>ViewRootImpl</code>的<code>invalidateChildInParent</code>方法中调用了<code>invalidateRectOnScreen</code>，而这个方法里又有个<code>scheduleTraversals</code>方法的调用，看起来就像是要遍历重绘的意思，它的代码是往Looper队列里添加了一个同步屏障，并在<code>mChoreographer</code>里添加了一个<code>TraversalRunnable</code>的回调，跑去这个Runnable的定义一看，就是调用了<code>doTraversal</code>方法，方法内容是移除同步屏障并执行<code>performTraversals</code>方法。这样想来，估计窗口第一次显示的时候类似的遍历过程会在<code>WindowManagerGlobal</code>调用<code>addView</code>方法之后调用吧。  </p>
<p>先不去管他，咱们来看<code>performTraversals</code>方法。……………………好长，里面写了一些debug的print，有空的话可以把debug开关打开来profile一下。这里挑重点看：首先是判断了一番当前的状态，是否需要创建Surface，是否需要完全重绘，是否需要硬件渲染，根据这些状态设置相应的条件，在满足Measure的条件时，调用<code>performMeasure</code>进行测量(该方法的内容是调用<code>mView.measure()</code>，在<code>View</code>的该方法实现代码中，调用了<code>onMeasure</code>，而<code>DecorView</code>的<code>onMeasure</code>方法在计算好自身宽高以后，调用了父类的<code>onMeasure</code>方法，我们还记得<code>DecorView</code>的父类是<code>FrameLayout</code>，去查看它的<code>onMeasure</code>方法就会发现，它对每一个child调用了<code>measureChildWithMargins</code>进行<strong>递归measure</strong>，然后才调用<code>setMeasuredDimension</code>设置自己的宽高)，measure不好还有可能measure第二次，测量完了之后<code>layoutRequested=true</code>； 接下来就执行了<code>performLayout</code>进行布局，方法中首先调用host(顶层<code>mView</code>的缓存)的layout进行布局(仍然调用的父类的<code>FrameLayout.onLayout</code>方法，非常暴力，就是一个<code>layoutChildren</code>进行<strong>递归layout</strong>)，然后计算有效的布局请求的View数量，如果此时还有需要布局的View则执行以下三步：遍历调用<code>View.requestLayout</code>，接着调用<code>measureHierarchy</code>，然后是<code>host.layout</code>再走一遍。这三步是第二次layout了，此时再检查还有没有需要布局的View，如果还有就只好将遍历调用<code>View.layout</code>的任务post到队列中等待下一帧执行，该方法完成后源码中注释说此时所有View就已经计算好并放置好了，接下来就会计算透明区域，主要就是把透明区域搜集起来并设置，如果透明区域跟之前的不同，则要求完全重绘；此时已经知道了屏幕上哪些地方需要重绘，哪些地方是透明的，接下来判断是否cancelDraw，<code>mAttachInfo.mTreeObserver.dispatchOnPreDraw()</code>完成(<code>AttachInfo</code>是<code>View</code>的内部类，当某个<code>View</code>附着到它的父窗口时，这个类的实例就存储一些相关的信息)或者<code>viewVisibility!=VISIBLE</code>都会被记为<code>cancelDraw</code>，如果可见性为<code>VISIBLE</code>则此时还会再试一次<code>scheduleTraversals</code>。只有在经过前面的状态判断后仍然需要绘制的情况下，才会调用<code>performDraw()</code>进行绘制，该方法调用<code>draw()</code>方法，在<code>draw()</code>中首先<code>mAttachInfo.mTreeObserver.dispatchOnDraw()</code>将事件传给观察者(<code>dispatchOnDraw</code>方法中，依次调用已注册的<code>OnDrawListener</code>中的<code>onDraw()</code>方法)，然后根据情况调用<code>mAttachInfo.mHardwareRenderer.draw</code>或者<code>drawSoftware</code>(在<code>drawSoftware</code>中会调用<code>mView.draw</code>，查看<code>DecorView</code>源码知道其实主要是调用的<code>super.draw</code>，再看<code>FrameLayout</code>源码发现未被重写，再往上到<code>ViewGroup</code>的源码，很棒仍然没找到<code>draw</code>不过找到了<code>drawChild</code>，再往上看，就到<code>View</code>了，<code>View</code>的<code>draw</code>方法中会先调用<code>drawBackground</code>，再调用<code>onDraw</code>来画自身内容，然后调用<code>dispatchDraw</code>请求孩子进行绘制，最后调用<code>onDrawForeground</code>。然而<code>View</code>中<code>dispatchDraw</code>是个空方法，根据逻辑它应该是个<code>ViewGroup</code>来实现，于是回来找到<code>ViewGroup</code>，果然里面有<code>dispatchDraw</code>的实现代码，这个方法大体还是对每个child调用<code>drawChild</code>，<code>drawChild</code>方法只是返回<code>child.draw</code>的结果，至此完成<strong>递归draw</strong>)，这期间有可能再来一次<code>scheduleTraversals</code>。  </p>
<p>看到这里有个疑问，<code>dirty</code>区域哪去了？其实回头一看就会知道，<code>dirty</code>早在<code>invalidateRectOnScreen</code>的时候就被合并到<code>mDirty</code>中了，而<code>mDirty</code>会在<code>draw</code>方法中使用。想必各位也注意到了，只有<code>draw</code>是要先<code>dispatchOnDraw</code>的，这暗示了这三个重要的步骤的逻辑是前两者由孩子发起，到父亲结束，而绘制动作是由父亲发起。但三个步骤的实际执行都是先执行孩子的对应方法，才执行父亲的对应方法。回想一下，一切的开端都在View调用<code>invalidate(true)</code>的时候。至此，整个重绘的过程就已经清楚了。  </p>
<p>那么，当一切开始时，Activity是怎样从零开始绘制<code>DecorView</code>的呢？借助前面重绘过程的探索分析，我发现了在执行<code>ActivityThread#handleResumeActivity</code>时会调用<code>r.activity.makeVisible()</code>方法使<code>activity</code>可见，这个过程就是上面我们分析过的测量和绘制视图的过程了。那么这些视图是什么时候初始化的呢？从<code>setContentView</code>到视图可见，之间经历了什么？其实在<code>makeVisible()</code>这个调用之前，在<code>performResumeActivity</code>之后，还有一个重要的步骤，就是添加<code>DecorView</code>，具体是先通过<code>r.window = r.activity.getWindow()</code>获取Activity所在的Window，并记录到r中，一般来说这个Window就是<code>PhoneWindow</code>了，所以接下来就不难理解调用<code>r.window.getDecorView()</code>获取到了<code>DecorView</code>的引用。获取到<code>DecorView</code>引用后，首先设置为<code>INVISIBLE</code>，然后通过<code>ViewManager wm = a.getWindowManager()</code>获取到<code>ViewManager</code>实例，通过<code>WindowManager.LayoutParams l = r.window.getAttributes()</code>获取到布局参数，最后通过<code>wm.addView(decor, l)</code>添加<code>DecorView</code>到<code>WindowManager</code>中。  </p>
<p>来看<code>addView</code>，前面讲过这里的<code>WindowManager</code>实际上是<code>WindowManagerGlobal</code>，所以我们知道这里实际调用的是<code>WindowManagerGlobal.addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code>(这里的后两个参数来自于<code>WindowManagerImpl</code>的<code>mDisplay</code>和<code>mParentWindow</code>)，它做了什么呢？打开源码，看到它首先使用<code>params</code>参数调整父窗口的子窗口(<code>parentWindow.adjustLayoutParamsForSubWindow(wparams)</code>)，然后<strong>同步地</strong>先确保之前的<code>removeView()</code>执行完毕，再用<code>View.getContext()</code>实例化了<code>ViewRootImpl</code>并赋值给局部变量<code>root</code>，同时分别在<code>mViews mRoots mParams</code>添加记录<code>view root params</code>。同步块之后调用了<code>root.setView(view, params, panelParentView)</code>设置视图内容。这个<code>setView</code>方法厉害了，它整个都是同步的，跳过一些我暂时看不懂的<code>SurfaceHolder</code>等内容后，首先设置<code>mAttachInfo.mRootView = view</code>，然后调用了<code>requestLayout</code>，然后调用<code>mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel)</code>将<code>mWindow</code>加入到<code>WindowManagerGlobal</code>中，然后<code>view.assignParent(this)</code>把<code>ViewRootImpl</code>注册为<code>DecorView</code>的父亲。其中<code>mWindowSession</code>是<code>WindowManagerService</code>的远程事务。至此，<code>DecorView</code>就已经被加入到<code>ViewRootImpl</code>并随着<code>PhoneWindow</code>加入到了<code>WindowManagerService</code>中接受其管理。  </p>
<p>总结一下，可以看到<code>View</code>的绘制过程和重绘过程其实本质上是一样的，只不过绘制的dirty区域是整个窗口。在<code>Activity</code>初始化的时候，在<code>ResumeActivity</code>之后，真正显示之前，<code>ActivityThread</code>进行了Activity中DecorView的创建、初始化和添加，然后通过调用<code>setVisibility</code>来间接调用<code>invalidate</code>方法进行重绘，在重绘时子View通过调用<code>invalidate</code>方法，请求父亲计算dirty区域并递归依次按需执行<code>measure、layout、draw</code>三种方法。孩子节点要进行重绘的时候，只需要在设置好新的界面值之后直接或间接调用<code>invalidate</code>方法，就可以触发该孩子节点及其所有<strong>祖先</strong>的重绘。源码为了健壮性，有很多地方都可能进行两次甚至三次某个步骤，有些地方甚至直接重新全部执行，过多次数的计算和重绘可能会产生性能瓶颈。  </p>
<h2 id="View与ViewGroup事件分发"><a href="#View与ViewGroup事件分发" class="headerlink" title="View与ViewGroup事件分发"></a>View与ViewGroup事件分发</h2><p>在前面我们已经见到了两个神奇的方法<code>dispatchOnPreDraw</code>和<code>dispatchOnDraw</code>，这一节我们来看更多的<code>dispatchXXX</code>, 也就是Android中的<strong>事件分发机制</strong>。多一句嘴, View的事件分发机制只是针对触屏事件的一种处理思路, 这种思路完全可以用在别的事件的分发和处理流程上.  </p>
<p>我们知道, 对于用户来说, 跟Activity交互的主要方式之一就是触屏, 而展示在用户面前, 用户可以看见的东西, 就是我们的 <code>View</code> 和 <code>ViewGroup</code>, 所以 <code>View</code> 和 <code>ViewGroup</code> 必然会对触屏事件做处理. 这里我们直接通过读源码的方式去了解<code>View</code>的时间分发机制, 并着重根据以下几种触屏事件来梳理思路, 加深理解:  </p>
<ol>
<li>点击事件(Click)分发  </li>
<li>按下事件/释放事件  </li>
<li>滑动事件  </li>
</ol>
<p>同时, 我们需要注意一个事件的处理周期, 即它分发的路径是怎样的, 是否会停止分发, 满足什么条件会停止分发.<br>对事件分发机制有充分理解, 那么各种按键事件响应处理和事件冲突问题, 就可以迎刃而解.<br>写这一节参考了网上的一些资料, 这里先做个说明, 本节不会以”消费”来表示事件处理函数返回<code>true</code>的情况, 纯粹因为我个人不喜欢这个词, 觉得表意不明确, 我认为方法的返回值只是表示”是否停止处理事件”, 而这个意思用”消费”来表示不太准确, 尽管源代码中用来表示这种情况的<code>Consume</code>通常确实被翻译为消费. 各位读者如果习惯这样称呼, 也并无不妥. 其他内容如有引用会在文中注明.<br>本节行文方式是先背景知识, 再总体流程图, 再贴源码详细解释.  </p>
<h3 id="事件产生"><a href="#事件产生" class="headerlink" title="事件产生"></a>事件产生</h3><p>触屏对操作系统提供硬件接口用以通知操作系统产生了什么事件, 操作系统通过硬件驱动读取和解析硬件接口的事件, 这个跟源码关系不大我们就不说了. 我们只说当事件被Android系统捕捉到之后, 传入Activity的时候是个什么形式, 没错, 就是<code>MotionEvent</code>. 硬件输入事件被<code>InputEvent</code>来描述, 该类是一个抽象类, 其有两个直接子类, 即<code>MotionEvent</code>和<code>KeyEvent</code>, 分别对应触屏事件和按键事件. 我们这里重点关注<code>MotionEvent</code>.<br>它在<code>frameworks/base/core/java/android/view/MotionEvent.java</code>中定义, 比较大, 注释也多, 我们只抽象地简单了解一下它刻画了触屏事件的哪些属性.<br>首先它定义了一系列ACTION常量来表示触屏事件, 例如我们下面会用到的<code>ACTION_DOWN</code> <code>ACTION_MOVE</code> <code>ACTION_UP</code>, 以及<code>ACTION_OUTSIDE</code> <code>ACTION_CANCEL</code> <code>ACTION_POINTER_DOWN</code> <code>ACTION_POINTER_UP</code> <code>ACTION_SCROLL</code>等.<br>其次它还定义了触屏事件的坐标属性包括偏移量等信息, 对应的处理和转换方法(@hide), 以及相应的Getter.<br>最后它定义了触屏事件的发生时间, 以及一系列<code>toString</code>方法.<br>这里面有很多方法都是native的, 而且也用到了aidl可见跟binder驱动估计也有关系. 如果今后有时间, 我会深入去看一下硬件到事件的过程, 今天先点到为止.<br>对<code>MotionEvent</code>本身感兴趣的同学可以去看看源码和官网的文档, 也可以在网上搜一下, 已经有很多人写过相关的博客.  </p>
<h3 id="事件分发和处理"><a href="#事件分发和处理" class="headerlink" title="事件分发和处理"></a>事件分发和处理</h3><p>事件产生之后(<code>MotionEvent</code>), 是怎么分发和处理呢? 我们先来看一张图:<br><img src="/images/blogs/view_event_dispatch.png" alt="事件分发总流程"><br>上图来自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>. 图中白色箭头代表事件流动的方向. 大体上来说一个全新的事件就是按照这个过程分发和分级处理的.<br>可见事件处理的主体主要分三个层级, 即<code>Activity</code> <code>ViewGroup</code> <code>View</code>, 你没看错, <code>Activity</code>这个浓眉大眼的家伙也可以处理<code>MotionEvent</code>.<br>网上常说”从上往下传递事件, 从下往上处理事件”, 其实默认是从”View树层次结构”的角度去说的, 而不是”View的显示层次”, 在”View树层次结构”这个角度上, <code>Activity</code>及其<code>DecorView</code>就是最上层, 逐层往下是<code>ViewGroup</code>和<code>View</code>, 这其实是一个<strong>深度优先搜索</strong>的过程, 对于一个确定的<code>MotionEvent</code>, 在这棵树上的路径也是确定的. 其实每一层都是先往下搜索看子节点是否处理完毕这个事件, 如果处理完毕了, <code>dispatchTouchEvent</code>就返回<code>true</code>, 否则本层调用<code>onTouchEvent</code>进行处理并返回处理结果.<br>所以我们可以猜测代码逻辑是这样:  </p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent e){
    View target;
    for (View child: children){
        target = child.getTouchTarget(e); // find event target
        if (target != null){
            break;
        }
    }
    if (target != null &amp;&amp; target.dispatchTouchEvent(e)){
        return true;
    }

    return onTouchEvent(e);
}
</code></pre><p>当然事实上远没有这么简单, 在<code>View</code>和<code>ViewGroup</code>中, 在实际分发和处理事件之前, 进行了一系列的逻辑处理(这里我就不贴源码了, 有兴趣的同学可以自行查看), 如: 在<code>ViewGroup</code>中, 判断当前是<code>DOWN</code>事件或者目标非空, 如果满足条件, 则设置一系列标记, 并判断该事件是否被自己拦截(<code>onInterceptTouchEvent</code>). 如果不满足条件, 即非<code>DOWN</code>事件且目标为空, 则直接标记该事件被拦截, 随后关键步骤是调用<code>dispatchTransformedTouchEvent</code>, 根据传入参数来决定是调用孩子节点的<code>onTouchEvent</code>还是调用<code>super.dispatchTouchEvent</code>(即<code>View.dispatchTouchEvent</code>, 这条路径会让自己的<code>onTouchListener</code>或<code>onTouchEvent</code>处理事件); 在<code>View</code>中, <code>DOWN</code>事件会让<code>View</code>停止滚动, 判断是否被<code>OnTouchListener</code>处理完毕(该步取代了<code>dispatchTouchEvent</code>, 原因显而易见), 如果没有则调用<code>OnTouchEvent</code>处理; 以上两者都会判断事件是否满足一致性校验, 是否满足安全性策略, 是否被取消.<br>与此相比, <code>Activity</code>中的事件处理就是一股清流, 它的代码非常简短, 几乎就跟我上面给出的差不多. 它先将<code>DOWN</code>事件交给<code>onUserInteraction</code>处理, 然后并不返回, 继续将该事件交给<code>getWindow().superDispatchTouchEvent</code>, 如果未被处理完毕则交给自身的<code>onTouchEvent</code>处理并返回.<br>神秘的就在于<code>superDispatchTouchEvent</code>了, 复习一下第一节的知识知道它八成是在<code>PhoneWindow</code>中定义的. 打开一看, 果不其然, 又被<code>mDecor</code>代理了…我们回忆一下, <code>DecorView</code>这个内部类是继承自<code>FrameLayout</code>的, 也就是说他是个<code>ViewGroup</code>, 好, 我们来看看这个类中<code>superDispatchTouchEvent</code>怎么定义的:  </p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
            return super.dispatchTouchEvent(event);
}
</code></pre><p>直接丢给父类了, 人干事? 好在我们惊喜地发现这个方法是<code>public</code>的, 我们可以自己定义<code>Window.superDispatchTouchEvent</code>. 当然, 最惊喜的是<code>getWindow()</code>也是<code>public</code>的, 使得自定义<code>Window</code>并修改事件分发策略成为可能, 这个设计绝赞.  </p>
<p>现在我们已经大体知道了事件分发和处理的逻辑, 不清楚读者心中产生了什么新的疑问, 我有两个疑问: 1. 事件从何处传递给<code>Activity</code>(我们怎么确定顶层处理组件是<code>Activity</code>而不是其他什么东西?); 2. 事件何时终止传递, 连续事件(<code>DOWN-&gt;MOVE-&gt;UP</code>)有时候是要同一个<code>View</code>进行处理的, 例如滑动<code>ListView</code>, 如何保证这个过程?  </p>
<p>对于第一个问题, 我自己想想就觉得头大, 首先它肯定是硬件传递给我们操作系统再分发给某个服务(<code>ActivityManagerService</code>?)的, 这里面估计涉及到<code>Binder</code>通讯, 分析<code>Binder</code>原理的时候要了我半条命(感兴趣的同学可以在我博客里搜索到<code>Binder</code>原理解析的文章). 其次, 对于裸的驱动事件, 必然需要借助设备驱动将事件进行重新包装和定义, 这一步可能是<code>Android</code>提供接口, 设备驱动来完成, 也可能是<code>Android</code>系统自己来完成, 具体实现过程不太好找. 没办法, 有此疑问必然辗转反侧, 所以还是来看看吧. <code>Window.Callback</code>接口类定义了<code>dispatchTouchEvent</code>这个接口, 但是对于<code>Activity</code>来说哪个调用了它的这个方法, 我一点线索也没有. 回忆应用启动过程, 应该可以从<code>MotionEvent</code>的构造方法找到一点蛛丝马迹. 具体艰辛的过程我就不细述了, 总之最后终于发现了如下流程:<br><code>Linux</code>系统已经实现了对触屏事件的封装和传递, 硬件事件将会通过内核底层的硬件驱动进行处理, <code>Android</code>系统在此基础上进一步封装内核传递过来的触屏事件, 并根据事件的具体值, 依据硬件设备协议, 来初始化触屏事件<code>MotionEvent</code>.(回忆<code>adb sendevent</code>其实传输的就是触屏事件或按键事件)  </p>
<p>然后事件被包装成<code>QueuedInputEvent</code>, 并且由被设置了<code>Callback</code>的<code>Message</code>携带, 进入了主线程<code>ActivityThread</code>的消息队列, 处理时直接<code>handleCallback</code>调用了<code>Callback</code>, 而这个<code>Callback</code>是调用<code>ViewRootImpl.dispatchInputEvent</code>(接口来自<code>InputEventReceiver</code>)分发给了<code>ViewRootImpl</code>由<code>ViewRootImpl.onInputEvent</code>处理, 它才是真正意义上第一个处理触屏事件的类, 在该类中经过一系列处理后会传递到以下代码中:  </p>
<pre><code>private int processPointerEvent(QueuedInputEvent q) {
    ...
    final MotionEvent event = (MotionEvent)q.mEvent;
    final View eventTarget =
            (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; mCapturingView != null) ?
                    mCapturingView : mView;
    mAttachInfo.mHandlingPointerEvent = true;
    boolean handled = eventTarget.dispatchPointerEvent(event);
    ...
}
</code></pre><p>至于<code>mView</code>其实就是<code>DecorView</code>的实例, 是整个<code>View</code>树中最上层的可见元素, 见上文. 于是在这里调用了要么是<code>mCapturingView</code>要么是<code>mView</code>的<code>dispatchPointerEvent</code>, 而在<code>View.dispatchPointerEvent</code>的实现是, 如果它是<code>MotionEvent</code>, 则调用<code>dispatchTouchEvent</code>.<br>在<code>DecorView.dispatchTouchEvent</code>中, 如果有<code>Callback</code>调用<code>Callback.dispatchTouchEvent</code>, 否则调用<code>super.dispatchTouchEvent</code>. 这就厉害了, 这里对于<code>Activity</code>来说, 它是实现了<code>Callback</code>接口的, 也就是说这里如果传入的<code>Callback</code>是<code>Activity</code>实例, 那么就是直接调用<code>Activity.dispatchTouchEvent</code>了, 一切都解释得通了.<br>来梳理一下这一段的调用:  </p>
<pre><code>ActivityThread.mH.handleMessage(Message msg) -&gt;  
ActivityThread.mH.handleCallback(msg.callback)  
ViewRootImpl.dispatchInputEvent(q) -&gt;  
ViewRootImpl.onInputEvent(mEvent) -&gt;  
ViewRootImpl.processPointerEvent(q) -&gt;  
DecorView.dispatchPointerEvent(q.mEvent) -&gt;  
DecorView.dispatchTouchEvent -&gt;  
Activity.dispatchTouchEvent -&gt;  
Activity.getWindow().superDispatchTouchEvent -&gt;  
DecorView.superDispatchTouchEvent -&gt;  
FrameLayout.dispatchTouchEvent
</code></pre><p>可以看到最后好像是绕了个圈, 从<code>DecorView.dispatchTouchEvent</code>出发, 又回到<code>DecorView.super.dispatchTouchEvent</code>.  </p>
<p>对触屏事件的定义见代码<code>./bionic/libc/kernel/common/linux/input.h</code>.<br>触屏驱动见驱动代码目录<code>./kernel/goldfish/drivers/input/touchscreen/</code>.<br>事件封装见<code>./frameworks/base/services/input/EventHub.cpp</code>.  </p>
<p>(如果有兴趣, 可以沿这条路径查阅代码, 感受一下我的艰辛: <code>MotionEvent.obtain() -&gt; ./frameworks/base/services/input/EventHub.cpp</code> -&gt; 实在找不到触发点, 写了个Demo打印调用栈, 发现是异步调用, 事件被放进<code>ActivityThread</code>的<code>looper</code>中 -&gt; 我能怎么办, 我也很绝望啊, 事件从哪里放进looper中的? 沿着处理栈看看吧 -&gt; 惊喜发现)  </p>
<p>至此, 第一个疑问基本得到解答. 第二个疑问是, 事件何时终止传递, 对于连续事件如何处理? 事实上, 从以上代码可以看到, 当任意一层<code>dispatchTouchEvent</code>提前返回而无论自身还是父亲节点都不再调用下一层<code>dispatchTouchEvent</code>的时候, 就终止事件传递了, 具体来说就是<code>dispatchTouchEvent</code>在调用孩子节点的<code>dispatchTouchEvent</code>之前就返回了<code>true</code>(例如, 被拦截或者传递给<code>onTouchEvent</code>并返回<code>true</code>). 连续事件分两类, 一类是像<code>ACTION_MOVE</code>这样的, 由一系列连续的事件点构成的一个事件, 另一类就是像我上文提到的那种, 按下不放滑动手指.  </p>
<p>对于第一类, <code>Android</code>系统实际上将这种多次事件封装在了一个<code>MotionEvent</code>中, 并且用<code>ACTION_MOVE</code>这种标记来表示, 实际上我们手指触摸屏幕的时候, 很难达到仅有<code>ACTION_DOWN</code>-&gt;<code>ACTION_UP</code>, 中间多少都会夹几个<code>ACTION_MOVE</code>.  </p>
<p>对于第二类, 其实也很简单, 在<code>DOWN</code>事件发生时, “<strong>ACTION_DOWN在哪个View的onTouchEvent返回true，那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent 并结束本次事件传递过程… 如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</strong>“(以上引用自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>).<br>现象好像确实如此, 但是代码是怎么做到的呢? 带着好奇我重新看了<code>ViewGroup</code>和<code>View</code>的事件分发, 发现了实现方法. 对于<code>View</code>, 如果在<code>dispatchTouchEvent</code>时调用了默认的<code>onTouchEvent</code>, 并且它是可点击的, 那么<code>DOWN</code> <code>UP</code> <code>MOVE</code> <code>CANCEL</code>四个事件会进入该函数的<code>switch</code>, <code>switch</code>之后必然返回<code>true</code>, 即触屏事件被处理完毕. 由于<code>View</code>本来就是事件分发的最底层, 所以它并没有显示后续事件拦截是如何实现的. 对于<code>ViewGroup</code>, 由于它并没有重写<code>onTouchEvent</code>方法, 故所有事件如果传递到了<code>onTouchEvent</code>则必然也是走<code>View</code>的方法. 在<code>dispatchTouchEvent</code>过程中, 特殊处理<code>DOWN</code>事件, 此时会清除掉内部保存的<code>target</code>链表, 并遍历一个有序的<code>View[] children</code>数组(按绘制先后顺序排序), 对于每一个孩子节点, 在<code>target</code>链表中寻找是否存在它对应的<code>target</code>, 如果存在则循环结束跳出, 否则对这个孩子调用<code>dispatchTransformedTouchEvent</code>, 并在返回<code>true</code>时构造这个孩子的<code>target</code>并插入到链表头部, 然后结束循环, 以上内容都是仅在<code>DOWN</code>事件时发生. 这就意味着, 如果一个<code>child</code>在<code>DOWN</code>事件时<code>dispatchTransformedTouchEvent</code>返回<code>true</code>了, 那么它在链表中就应该存在对应的<code>target</code>. 用<code>newTouchTarget</code>这个变量来暂时存储, 而且这个<code>target</code>应该在链表靠头部的位置. 如果<code>newTouchTarget</code>为空(意味着<code>dispatchTransformedTouchEvent</code>返回<code>false</code>)但<code>target</code>链表不为空(意味着本<code>ViewGroup</code>中已经有一组<code>target</code>等待接收事件), 则<code>newTouchTarget</code>存储链表尾节点. 循环结束后, 根据<code>target</code>链表继续处理事件, 如果<code>target</code>链表为空说明本<code>ViewGroup</code>的孩子节点没有曾经将事件处理完毕过(一旦有过, 就会被链表保存)或者本次事件是<code>DOWN</code>事件但被取消或拦截了, 那么调用<code>View.dispatchTouchEvent</code>继续处理事件, 而该方法默认是调用自身的<code>onTouchEvent</code>. 如果<code>target</code>链表不为空, 遍历<code>target</code>链表把事件传给对应的<code>View</code>进行处理(划重点!!<strong>事件如果被标记为取消或者拦截, 则不继续传递给孩子节点, 事件要么由自身<code>onTouchEvent</code>处理, 要么传递给已经在target列表中的节点处理; 事件不被取消也不被拦截的情况下, 如果孩子节点有一个返回true, 则以后的非DOWN事件也只交给target列表中的节点处理, 不再继续传递给其他孩子; target列表中的节点则是调用其dispatchTouchEvent方法继续传递和处理事件</strong>), 有任意一个处理完毕则都标记本<code>ViewGroup</code>已处理完毕该事件(但是不会中断遍历). 在该过程中如果有<code>View</code>标记为下次<code>UP</code>事件时取消, 则同时从链表中删除并回收该<code>target</code>.  </p>
<p>小结一下, 借助<code>target</code>链表, <code>ViewGroup</code>记录了处理<code>DOWN</code>事件的<code>View</code>集合, 并在下次其他事件传入时仅传给这个链表中的<code>View</code>, 这就实现了对连续事件的处理. 而且对于<code>View</code>的<code>onTouchEvent</code>默认实现来说, 四种事件均会返回<code>true</code>, 即<code>View</code>本身默认就是会拦截事件的.  </p>
<h3 id="事件冲突"><a href="#事件冲突" class="headerlink" title="事件冲突"></a>事件冲突</h3><p>仔细理解了上一节的内容之后, 就不难预见事件冲突这种情况发生的原因以及解决方案了.<br>总的来说, 事件冲突的原因就是意料之外的<code>View</code>或者<code>ViewGroup</code>把事件拦截了, 从而我们想用来处理事件的<code>View</code>或者<code>ViewGroup</code>无法接收到事件.  </p>
<p>典型的, <code>ScrollView</code>中嵌套<code>ListView</code>, 冲突产生的原因是<code>ScrollView</code>在滑动拖拽的过程中会让<code>onInterceptTouchEvent</code>返回<code>true</code>, 直接导致<code>ScrollView</code>拦截事件, 不会被传递到深一层的<code>ListView</code>(其他<code>View</code>也一样). 解决方案也很简单, 就是重写<code>ScrollView</code>的<code>onInterceptTouchEvent</code>, 告诉<code>ScrollView</code>哪些情况该拦截, 哪些情况不该拦截. 如果不能修改这个拦截事件的<code>View</code>怎么办呢? 也好办, 从自己可控的<code>ViewGroup</code>出发, 调用<code>requestDisallowInterceptTouchEvent</code>要求该<code>ViewGroup</code>及其祖先节点不拦截事件, 再视情况恢复这个标记位.<br>可以看出, 了解了<code>Android</code>系统各个层次对事件的分发处理和返回的策略之后, 遇到任何事件冲突问题我们都能够很容易找到症结所在并给出解决方案.  </p>
<p>对于嵌套滑动, <code>View</code>定义了一个接口<code>dispatchNestedScroll</code>用来传递嵌套滑动事件. 今后有空我将会继续研读这一块的设计.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲View
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Context全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DContext%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/23/[Android教程]Context全解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-03-05T08:29:43.703Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中会遇到很多场景需要Context, 包括但不限于: 获取资源, 创建View, 显示UI元素… 稍微追踪一下知道Context是一个接口, 当然从名字知道它是提供环境信息的接口, 今天我们就来看看, Context以及它的衍生类.  </p>
<h2 id="Context接口和作用"><a href="#Context接口和作用" class="headerlink" title="Context接口和作用"></a>Context接口和作用</h2><p>位于<code>frameworks/base/core/java/android/content/Context.java</code>, 是一个抽象类, 它定义了所有可用的接口, 在AS中查看它的类继承关系, 可以发现它有<code>MockContext</code>和<code>ContextWrapper</code>两个直接子类, 继续追下去会发现它有数量不少的间接子类, <code>Application</code> <code>Activity</code> <code>Service</code>都是它的子类, 这也正是在这些类中用到Context参数时可以直接传<code>this</code>的原因. 我们来看Context定义了哪些接口, 接口及其说明在官网Context页都有说明, 我这里只是相当于翻译一下. 大致上可以分为两类:  </p>
<ol>
<li><p>全局信息资源接口及其配套常量. 包括但不限于以下接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">getResources 返回Resources实例, 提供应用包的资源管理接口.  </div><div class="line">getAssets 返回AssetManager实例, 它提供资源管理接口. 它管理的资源应当和getResources管理的资源保持一致, 即它们维护同一套资源.  </div><div class="line">getPackageManager 返回PackageManager实例, 提供全局包信息.  </div><div class="line">getContentResolver 返回ContentResolver实例, 提供内容解析接口.  </div><div class="line">getText 封装Resources.getText  </div><div class="line">getString 封装Resources.getString</div><div class="line">getClassLoader 获取ClassLoader实例, 可以由此获取包内所有类</div><div class="line">getPackageName 获取应用包的包名  </div><div class="line">getSystemService 获取系统服务, 系统服务的名字以常量形式存在Context类中</div></pre></td></tr></table></figure>
</li>
<li><p>公共方法及其配套常量. 包括但不限于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getMainLooper 返回当前Context的Looper实例  </div><div class="line">getApplicationContext 获取应用的Context实例, 它不同于当前Context实例, 而是一个属于当前进程的, 全局的, 单例的, Application对象, 这意味着它的生命周期不同于当前Context, 而是跟当前进程捆绑  </div><div class="line">registerComponentCallbacks 注册组件回调  </div><div class="line">unregisterComponentCallbacks 注销组件回调  </div><div class="line">deleteFile 删除与当前应用包关联的私有文件  </div><div class="line">deleteDatabase 删除与当前应用包关联的私有SQLiteDatabase数据库  </div><div class="line">startActivity 开始一个Activity  </div><div class="line">registerReceiver 注册广播接收器  </div><div class="line">unregisterReceiver 注销广播接收器</div><div class="line">bindService 绑定服务  </div><div class="line">unbindService 解绑服务  </div><div class="line">startService 开始服务  </div><div class="line">stopService 停止服务  </div><div class="line">createPackageContext 以给定应用包名创建该应用的Context</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Context默认实现"><a href="#Context默认实现" class="headerlink" title="Context默认实现"></a>Context默认实现</h2><p><img src="./images/blogs/context.png" alt="context关系"><br>前文说了, <code>Activity</code>和<code>Application</code>都是<code>Context</code>的间接子类. 但是他们处于不同层级, 拥有不同的继承链, <code>Application</code>继承了<code>ContextWrapper</code>(<code>Service</code>也继承了它), 而<code>Activity</code>继承了<code>ContextThemeWrapper</code>(它是<code>ContextWrapper</code>的直接子类). 在<code>ContextWrapper</code>中提供了大多数方法的默认实现, 正如其名, 它只是包装了一个<code>Context</code>实现, 这个实现就是它的<code>mBase</code>成员变量, 是通过构造函数或者<code>attachBaseContext</code>传入的<code>Context</code>实例. 在应用启动过程中, <code>performLaunchActivity</code>会将一个<code>ContextImpl</code>实例作为参数传入<code>Activity.attach</code>方法, 该方法就用这个实例调用<code>attachBaseContext</code>设置好<code>Context</code>. 换句话说, <code>Activity</code>所拥有的<code>Context</code>就是一个随<code>Activity</code>生命周期的<code>ContextImpl</code>实例, <code>Activity</code>中对<code>Context</code>接口的调用, 中途经过<code>ContextThemeWrapper</code>和<code>ContextWrapper</code>, 最终到达这个<code>mBase</code>指向的<code>ContextImpl</code>的相应接口调用. 也就是说, 它就是我们要找的Activity Context默认实现.<br>那么Application Context呢? 它调用Context接口时最终同样会传达到mBase上, 它的mBase对象又是什么呢? 我们考察应用启动过程, 发现在<code>performLaunchActivity</code>中, 有一步是<code>makeApplication</code>, 返回一个<code>Application</code>对象. 该方法属于<code>LoadedApk</code>类, 打开该类查看, 发现它维护了一个<code>Application mApplication</code>成员变量, <code>makeApplication</code>方法在该变量非空时直接返回该变量(意味着无论调用多少次, 都返回同一个Application实例), 否则新建一个<code>ContextImpl</code>对象, 并以它为参数之一, 调用<code>mActivityThread.mInstrumentation.newApplication</code>返回一个<code>Application</code>对象. 再查看<code>newApplication</code>方法, 它位于<code>frameworks/base/core/java/android/app/Instrumentation.java</code>中, 其行为是使用给定的<code>ClassLoader</code>先装载给定的类(这里是<code>LoadedApk.makeApplication</code>中字符串<code>appClass</code>代表的<code>Application</code>类, 如果没有指定或强制使用默认appClass, 则该值为”android.app.Application”), 再用该类对象的<code>newInstance</code>创建实例并调用<code>attach</code>方法绑定Context实例. 可见, <code>Application</code>的Context仍然是<code>ContextImpl</code>实例, 不同的是它的生命周期与<code>Application</code>一致.<br><code>ContextImpl</code>类中对Context大多数接口方法都有了默认实现, 我们重点只看<code>getApplicationContext</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// in file ContextImpl.java</div><div class="line"></div><div class="line">@Override</div><div class="line">public Context getApplicationContext() &#123;</div><div class="line">    return (mPackageInfo != null) ?</div><div class="line">            mPackageInfo.getApplication() : mMainThread.getApplication();</div><div class="line">&#125;// mPackageInfo是LoadedApk类型</div></pre></td></tr></table></figure></p>
<p>方法<code>Activity.getApplication</code>返回的是成员变量<code>mApplication</code>, 根据其构造过程, 是在<code>attach</code>时赋值的<code>Application</code>实例, 换句话说, 在同一个应用中时, <code>Activity</code>中调用<code>getApplication</code>跟调用<code>getApplicationContext</code>返回的是同一个对象, 这可以很方便地验证.  </p>
<h2 id="Context使用中需要注意的问题"><a href="#Context使用中需要注意的问题" class="headerlink" title="Context使用中需要注意的问题"></a>Context使用中需要注意的问题</h2><p>前文中我们曾特地指出, <code>Activity</code>的Context跟<code>Application</code>的Context生命周期不同, 细心的同学可能要问了, 强调这个是因为有什么坑吗? 是的, 这里有坑.<br>原因就在于我们在创建组件的时候经常会用到Context这个参数, 有时为了图方便就直接传<code>this</code>, 大多数情况下也挺好使, 但其实这里存在很大的内存泄漏风险.<br>举个例子, 我们假设在<code>Activity</code>中创建了一个<code>Bitmap</code>, 为了在手机横竖屏切换的时候不至于重新装载这个资源, 我们将它写成<code>static</code>, 这样它的生命周期也就跟<code>Activity.class</code>相同了. 然后我们通过<code>setBackgroundDrawable</code>将它设置成了某个<code>View</code>(该<code>View</code>是通过<code>new View(this)</code>方法构造的实例)的背景. 我们知道, 在手机横竖屏切换的时候, 当前Activity会被销毁再重新创建, 因此此间会有一个gc标记过程. 这里存在什么问题呢? <code>setBackgroundDrawable</code>之后, 静态变量<code>Bitmap</code>会持有一个该<code>View</code>的引用, 而这个<code>View</code>持有一个<code>Activity</code>的引用, 这就导致<code>Activity</code>的引用计数不为0, gc过程无法回收该对象内存, 但是该对象已经不被任何过程使用, 于是就泄露了. 归根到底是因为创建<code>View</code>的时候使用了<code>Activity</code>作为Context, 但是该<code>View</code>由于存在被静态变量<code>Bitmap</code>引用的情况, 其实际生命周期要长于<code>Activity</code>.<br>解决这种泄露的方法是, 保证在<code>Activity</code>中使用<code>Activity</code>或<code>this</code>作为Context的任何对象, 其生命周期都不长于<code>Activity</code>本身, 否则应该考虑使用<code>Application Context</code>.<br>另外, 如果定义了非静态内部类, 那么对非静态内部类实例的引用也有可能导致外部类实例内存泄漏, 解决这种内存泄漏的方法是控制内部类的引用, 对于生命周期长于外部类的内部类, 应定义为静态内部类.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Android中的Context
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】SharedPreference详解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DSharedPreference%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/23/[Android教程]SharedPreference详解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-02-07T09:12:54.883Z</updated>
    
    <content type="html"><![CDATA[<p>Android为各位开发者提供了简单的数据存储和交换的方式, 就是<code>SharedPreference</code>, 它是一个在应用数据目录下的<code>.xml</code>文件, 无论是从名字还是实际应用来看, 它都是存取轻量不涉及安全问题的数据(例如设置项)的趁手方式之一. 当然, 它采用xml这样的格式有其自己的考虑, 但未必是最合适的. 当然它的缺点也跟优点一样明显, 今天我们就来看看它在源码中是怎样实现的, 由此也可看出它的优缺点何在.<br>老方法, 我们从实际使用场景来倒推.<br>本文结构:  </p>
<ol>
<li>SharedPreference实现  </li>
<li>SharedPreference优缺点  </li>
</ol>
<h2 id="SharedPreference实现"><a href="#SharedPreference实现" class="headerlink" title="SharedPreference实现"></a>SharedPreference实现</h2><p>一个简单的读写场景通常用到<code>getSharedPreferences</code>接口, 和<code>SharedPreferences.Editor</code>. 例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// TextView ttvv has been initiated before</div><div class="line">SharedPreferences sp = getSharedPreferences(&quot;Test&quot;, MODE_PRIVATE);</div><div class="line">sp.edit().putBoolean(&quot;Another test key&quot;, true).commit();</div><div class="line">Map&lt;String, ?&gt; content = sp.getAll();</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">for(String key : content.keySet())&#123;</div><div class="line">    sb.append(String.format(&quot;%s=%s\n&quot;, key, content.get(key).toString()));</div><div class="line">&#125;</div><div class="line">ttvv.setText(&quot;SharedPreference测试:\n &quot;);</div><div class="line">ttvv.append(sb.toString());</div></pre></td></tr></table></figure></p>
<p>首先追踪<code>getSharedPreferences</code>发现它调用的是<code>ContextWrapper.mBase.getSharedPreferences</code>, <code>mBase</code>这个东西我在另一篇分析<code>Context</code>的博客中讲过, 这里不赘述, 我们直接看它的实现, 发现它返回的是一个<code>SharedPreferencesImpl</code>实例, 其首先在静态成员变量<code>sSharedPrefs</code>中获取以传入的参数<code>name</code>为key的实例, 如果没有则在一个固定目录<code>getPreferencesDir()</code>(默认是<code>shared_prefs</code>)以传入的参数(name)创建一个新的<code>SharedPreference</code>文件<code>name.xml</code>(默认实现中, name不能包含路径分隔符), 然后以(name, mode)创建一个<code>SharedPreferencesImpl</code>实例. 第一个参数很好理解, 就是SharedPreference文件的文件名, 第二个参数指的是文件创建模式, 可选的值在<code>Context</code>抽象类中有定义, 主要是<code>MODE_PRIVATE</code>(默认文件打开方式就是这个, 即仅有创建者所在的应用或共享该应用User ID的其他应用有访问权限) <code>MODE_WORLD_READABLE</code>等常量, 在<code>SharedPreference</code>写的时候会根据创建模式判断是否有写权限.<br><code>SharedPreferencesImpl</code>构造方法中, 开启了一个线程从文件系统中载入指定名称的<code>SharedPreference</code>文件(构造方法中会先备份文件, 载入时如果存在备份文件, 先删除当前文件, 再从备份文件恢复), 并解析成Map存在成员变量<code>mMap</code>中. 可见, 我们实际获得的就是一个普通的xml文件解析成的<code>HashMap</code>.<br>以上, 我们知道了一个<code>SharedPreference</code>文件的创建和读取. 至于<code>edit()</code>接口返回的<code>Editor</code>接口很好理解, 它就是提供了对<code>SharedPreference</code>文件操作的封装, 它的默认实现是<code>SharedPreferencesImpl.EditorImpl</code>, 基本上就是同步地读写<code>mModified</code>成员变量, 它是<code>Maps.newHashMap</code>创建的实例, 它只存储有更改的键值对. 这里我们需要重点关注Editor两个地方的实现<code>boolean commit()</code>和<code>void apply()</code>.<br>相信用过<code>SharedPreference</code>的同学都知道, 这两个接口都是用来提交变化到文件的, 但具体提交过程可能不是人人都清楚. 我们先来看两个接口的说明, 通常源码里面会有重要信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call commit wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line"> * using this from your application&apos;s main thread, consider</div><div class="line"> * using &#123;@link #apply&#125; instead.</div><div class="line"> *</div><div class="line"> * @return Returns true if the new values were successfully written</div><div class="line"> * to persistent storage.</div><div class="line"> */</div><div class="line">boolean commit();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call apply wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line"> * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line"> * commits its changes to the in-memory</div><div class="line"> * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line"> * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line"> * any failures.  If another editor on this</div><div class="line"> * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line"> * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line"> * &#123;@link #commit&#125; will block until all async commits are</div><div class="line"> * completed as well as the commit itself.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line"> * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line"> * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line"> * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line"> * writing to disk.  The framework makes sure in-flight disk</div><div class="line"> * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line"> * states.</div><div class="line"> *</div><div class="line"> * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line"> * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line"> * previously did implement it and are now getting errors</div><div class="line"> * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line"> * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line"> */</div><div class="line">void apply();</div></pre></td></tr></table></figure></p>
<p>果不其然, 接口注释中有重要提示. 首先对于<code>commit</code>接口, 源码注释给出了三个信息: 1. 返回值表示是否成功写入到存储器; 2. 两个Editor竞争时, 后调用commit的Editor最终生效; 3. 它<code>原子地</code>写入新值, 如果不关心返回值, 而且是在主线程中调用, 应该考虑<code>apply</code>接口. 第1点和第3点预示着commit方法是同步写入, 可能效率会比较低, 在主线程中调用会引起响应变慢, 同时暗示着<code>apply</code>可能是异步写入. 再来看<code>apply</code> 接口, 源码注释给出了三个信息: 1. commit是同步写入外存, 而apply是先写到内存, 再异步写入到外存, 并且不会给出失败通知; 2. 对于同一个<code>SharedPreference</code>, 如果一个apply在等待时, 另一个editor调用了一个commit, 那么这个commit会被阻塞直到所有异步提交以及这个commit本身完成为止; 3. 它<code>原子地</code>写入新值, 在<code>SharedPreference</code>本身是单例实现的情况下(现在默认情况就是), 将所有的<code>commit</code>替换成<code>apply</code>是安全的, Android Framework保证在改变状态前完成已入队的apply操作, 所以你也不用担心组件生命周期会影响apply.<br>可见二者的最主要区别就是, commit是同步地, apply是异步的. 那么它们写入<code>SharedPreference</code>时候, 是具体怎么写入的呢? 这就要看<code>SharedPreferencesImpl.EditorImpl</code>的实现了.<br>先看<code>EditorImpl.commit()</code>, 它首先调用<code>commitToMemory</code>提交到内存, 然后调用<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把提交结果<code>MemoryCommitResult</code>入队, 再调用<code>MemoryCommitResult.writtenToDiskLatch.await()</code>阻塞直到<code>MemoryCommitResult.setDiskWriteResult</code>被调用, 即该结果已经被处理. 到这里我们知道写入工作分两步, 先写入到内存, 再写入到外存. 稍后我们分别来看这两步具体内容, 这里先看<code>EditorImpl.apply()</code>的实现. 它首先调用<code>commitToMemory</code>提交到内存, 然后新建了一个<code>Runnable awaitCommit</code>内容是<code>MemoryCommitResult.writtenToDiskLatch.await()</code>, 所以这个<code>Runnable</code>中会阻塞直到结果被处理. 然后它把这个<code>Runnable</code>加入到了<code>QueuedWork</code>中, 并且再新建了一个<code>Runnable postWriteRunnable</code>, 里面调用<code>awaitCommit.run()</code>, 并从<code>QueueWork</code>中移除<code>awaitCommit</code>. 最后, 它通过<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把这个<code>postWriteRunnable</code>入队. 可见, 它是一个异步的提交过程. 以上两个方法的具体实现, 也解释了apply和commit冲突时commit将会阻塞直到所有的apply完成的原因: commit会等待直到自己的提交被执行, 而它之前调用的apply在队列中会先于它处理.<br>现在清楚了提交过程, 来看Editor的数据是如何写入到内存的.<br>在<code>commitToMemory</code>中, 首先实例化了一个<code>MemoryCommitResult mcr</code>, 并让它保存了一个<code>mMap</code>的引用在<code>mapToWriteToDisk</code>成员中. 存在监听器时, 初始化它的<code>keysModified</code>和<code>listeners</code>成员, 并在后面把变化了的键放到<code>keysModified</code>中. 然后遍历<code>mModified</code>, 将新的值写入到<code>mMap</code>中, 或者从<code>mMap</code>中移除预定要移除的值, 最后清空<code>mModified</code>并返回<code>mcr</code>. 简单来说, 它把变化的内容复制到了<code>mMap</code>这个原始内容中.<br>最后, 来看被加入到队列中的<code>MemoryCommitResult</code>是如何被处理的. 先把源码放上方便各位对照:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                              final Runnable postWriteRunnable) &#123;</div><div class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr);</div><div class="line">                &#125;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                if (postWriteRunnable != null) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</div><div class="line"></div><div class="line">    // Typical #commit() path with fewer allocations, doing a write on</div><div class="line">    // the current thread.</div><div class="line">    if (isFromSyncCommit) &#123;</div><div class="line">        boolean wasEmpty = false;</div><div class="line">        synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">        &#125;</div><div class="line">        if (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看<code>enqueueDiskWrite</code>函数, 发现它先定义了一个<code>Runnable writeToDiskRunnable</code>, 内容是同步地调用<code>writeToFile(mcr)</code>, 递减<code>mDiskWritesInFlight</code>计数(该计数在调用<code>commitToMemory</code>时递增), 调用<code>postWriteRunnable.run</code>. 然后判断是否commit, 判断的方法也是非常暴力: <code>postWriteRunnable == null</code>就是同步commit. 此时先判断当前是否只有自己一个任务在执行, 是的话直接在当前线程上调用<code>writeToDiskRunnable.run</code>然后返回, 否则调用<code>QueueWork.singleThreadExecutor().execute(writeToDiskRunnable)</code>来执行. 我另一篇讲Java并发的博客讲过<code>singleThreadExecutor</code>是什么鬼. 显然, 无论是commit还是apply, 最后都是在用一个单线程池在跑, 跑的内容主要就是<code>writeToFile</code>. 在<code>QueueWork</code>中, 添加的任务都在<code>ConcurrentLinkedQueue sPendingWorkFinishers</code>队列中, 这里我们不再讲该队列的处理.<br>查看<code>writeToFile</code>的实现, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// Note: must hold mWritingToDiskLock</div><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mcr.changesMade) &#123;</div><div class="line">            // If the file already exists, but no changes were</div><div class="line">            // made to the underlying map, it&apos;s wasteful to</div><div class="line">            // re-write the file.  Return as if we wrote it</div><div class="line">            // out.</div><div class="line">            mcr.setDiskWriteResult(true);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mBackupFile.exists()) &#123;</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, &quot;Couldn&apos;t rename file &quot; + mFile</div><div class="line">                      + &quot; to backup file &quot; + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        if (str == null) &#123;</div><div class="line">            mcr.setDiskWriteResult(false);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        FileStatus stat = new FileStatus();</div><div class="line">        if (FileUtils.getFileStatus(mFile.getPath(), stat)) &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                mStatTimestamp = stat.mtime;</div><div class="line">                mStatSize = stat.size;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125; // catch exceptions</div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, &quot;Couldn&apos;t clean up partially-written file &quot; + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码放在博客里有一丢丢长, 但是除了log以外我都没舍得删, 因为我觉得写得很美, 尤其是虽然代码不多但注释不少. 该函数首先判断是否有改变, 没有改变就返回了, 然后判断备份文件是否存在, 不存在则把当前文件作为备份文件. 备份好了后在原文件位置创建新的文件来操作, 把整个<code>mcr.mapToWriteToDisk</code>写入到新文件中, 一切顺利的情况下, 更新<code>SharedPreferencesImpl</code>文件状态信息, 删除备份文件, 并设置写入结果为true, 然后返回. 一旦出错, 就会执行到后面的扫尾代码, 此时将新文件删除, 并设置写入结果为false. 注释里面有一个小提示, <code>Attempt to write the file, delete the backup and return true as atomically as possible</code>, 也就是说这个写入过程可能不是原子的, 只是实现上尽量保证原子而已.<br>至此, <code>SharedPreference</code>的实现原理我们已经大致了解.  </p>
<h2 id="SharedPreference优缺点"><a href="#SharedPreference优缺点" class="headerlink" title="SharedPreference优缺点"></a>SharedPreference优缺点</h2><p><code>SharedPreference</code>的优点是显而易见的: 系统实现, 拿来即可用; 接口定义清晰, 容易使用; 采用Map数据结构实现, 可以存储对象; 在Application中全局可见, 并且全局单例.<br>同时它的缺点也是很明显:  </p>
<ol>
<li>从第一节的分析可以看出, 每次有变化时, 系统默认是将整个<code>SharedPreference</code>文件备份, 写入新文件, 再删除备份文件. 这就意味着<code>SharedPreference</code>不适合存储大量内容, 也不适合对内容改动很少但很频繁的场景, 否则会因为文件读写而存在性能瓶颈. 前者是天然限制, 而后者可以通过尽量少调用commit和apply来规避;  </li>
<li>apply中混用commit可能导致效率降低. 原因在上面分析中讲过, commit会等待前面所有的apply完成, 也就意味着无论前面用了多少次apply, 一旦后面跟着一个commit, 对于commit所在的线程来说, apply的优势就荡然无存了.<br>另外, 由于该文件是通过应用创建的, 所以可以直接在应用数据目录下看到文件内容, 安全性不能保证, 不过这就不在本文讨论范围之内了.  </li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>分析了这些, 对于我们有什么用呢? 虽然我很讨厌什么都用”有没有用”来衡量, 但不写个结论确实也感觉文章虎头蛇尾. <code>SharedPreference</code>源码分析至少给我们几点启示:  </p>
<ol>
<li>注意<code>SharedPreference</code>的使用场景, 尽量规避它所不擅长的情景. 使用时如果对实时性和写入结果要求不高, 尽量只使用<code>apply</code>提交改动.  </li>
<li>完全可以仿照源码自行实现<code>SharedPreference</code>读写接口. 一个应用显然可以有多个<code>SharedPreference</code>文件, 将强耦合的内容分别聚拢到各自的<code>SharedPreference</code>文件中, 理论上可以提高读写效率, 如果有更高效的<code>SharedPreference</code>内容管理方式, 可以完全抛开系统实现, 自行管理<code>SharedPreference</code>文件.  </li>
<li><code>SharedPreference</code>的访问权限是创建时决定的, 依赖于文件创建模式参数, 不一定只有本应用可以访问.  </li>
<li>它一点也不神秘, 甚至在Android系统架构中地位也不太重要, 任何时候它被别的方式取代我也不会吃惊, 但它的实现代码, 透露着一种简洁的优雅.  </li>
</ol>
<p>本篇博客没有参考文献, 唯一参考来源是Android 4.0源码及其注释, 当然自己写来验证想法的Demo不算.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲SharedPreference共享设置
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Binder全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/10/%5BAndroid%E6%95%99%E7%A8%8B%5DBinder%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/10/[Android教程]Binder全解/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-03-05T11:12:16.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回-hu-顾-zhou"><a href="#某渣的凭印象回-hu-顾-zhou" class="headerlink" title="某渣的凭印象回(hu)顾(zhou)"></a>某渣的凭印象回(hu)顾(zhou)</h2><p>Binder是Android提供的一种RPC机制, 它是C/S架构, 可以远程调用服务, 调用其他进程甚至其他App的服务. 它利用AIDL描述服务接口, 通过bind和unbind绑定和解绑具体服务, 其内部使用代理完成服务功能的调用. 调用方需要知道AIDL, 被调用方需要实现AIDL. Android系统的服务就是通过Binder机制来使用的.  </p>
<h2 id="Binder的设计思想-工作原理"><a href="#Binder的设计思想-工作原理" class="headerlink" title="Binder的设计思想/工作原理"></a>Binder的设计思想/工作原理</h2><p>Binder是一种进程间通讯的机制, 不同于Handler的线程间通讯, 由于进程间没有共享区域, 所以Handler那种消息队列的机制在进程之间进行就会变得比较麻烦(进程A将消息拷贝到内核缓存空间, 另一进程B从内核缓存空间取消息), 特别是当进程间通讯涉及到接口调用等业务流程时. 出于安全性考虑, 一个进程的空间只对进程内部开放, 外部想要访问进程内的数据, 就只能曲线救国. Binder就是其中一种方式.  </p>
<p>Binder是一种特化的AIDL服务, 换句话说, AIDL是对Binder机制的上层封装, 它可以快速实现进程间通讯, 所以要想理解Binder就必须理解AIDL. 关于AIDL可以看我的博文<a href="http://hjhjw1991.github.io/android/2016/04/01/[Android%E6%95%99%E7%A8%8B]AIDL%E5%85%A5%E9%97%A8/">AIDL入门</a>, 简单来说, AIDL是服务的接口描述文件, 它在服务端和客户端都共同存在且内容相同, SDK的aidl工具可以帮助我们把<code>.aidl</code>文件转换成同名的<code>.java</code>文件, 只要我们手工调用该工具转换一下, 并看一看转换后的文件, 我相信就能够完全理解aidl的使用原理了(其实跟Hessian之类的RPC框架大同小异). 具体到Binder, 我们可以去看看Binder的实现源码和Binder驱动的源码, 说白了就是系统为我们实现了一套基于Binder接口的获取/绑定/解绑/释放服务代理的业务逻辑, 我们只需要负责将具体的服务传给Binder就可以了. 如果没有Binder, 进行进程间通讯就必须要自己实现基于AIDL的业务逻辑, 实际上这样也是行得通的, 只不过系统服务都是基于Binder实现的, 所以我们有必要了解Binder的实现原理.<br>在最下层, Binder驱动通过Native代码实现, 它是Binder接口的最终实现, 关于Binder驱动的源码可以看这篇博客<a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>, 尤其是其代码注释.  </p>
<p>在Linux中有很多进程间通讯的方式, 为什么Android唯独自己实现了一个Binder机制? 我认为主要原因是现有的Linux进程间通讯方式都太”重”了, 含有许多虽然好但是在Android环境下并不实用的特性. 可以明确的是, 现有的进程间通讯方式肯定可以应用在Android这个基于Linux系统内核的操作系统上. 相比之下, Binder的设计使得它只进行一次数据拷贝, 传输更加高效, 而且发送方和接收方都互相知道对方身份, 更加安全.  </p>
<h2 id="Binder实践"><a href="#Binder实践" class="headerlink" title="Binder实践"></a>Binder实践</h2><p>依旧, 如果只想用Binder, 那直接继承它并实现相应接口即可, 这里的实践指的是看Binder源码. 默认大家已经看过并理解了AIDL的相关内容.<br>不同于上层Framework, 这里要理解Binder需要涉及到底层native代码, 所以我们要提前准备好Android系统源码, 当然前面看Java层代码时不需要. 这里我以4.0源码为基础.<br>照惯例我们先从Binder源码看起. 打开<code>frameworks/base/core/java/android/os/Binder.java</code>, 先来看看它都有哪些主要内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">注释, 大意是说这个类是一个用于远程调用的基类, 是IBinder中定义的轻量级RPC的核心部分, 提供了远程对象本地实现的标准支持, 多数情况下开发者不需要直接实现Binder类, 而是利用aidl工具描述服务接口, 让aidl自动生成合适的Binder子类, 但是开发这当然可以直接继承Binder来实现自己的RPC协议或者仅仅是实例化一个Binder对象作为token在进程之间共享.</div><div class="line">*/</div><div class="line">public class Binder implements IBinder&#123;// Binder类实现IBinder接口</div><div class="line">private int mObject;</div><div class="line">private IInterface mOwner;</div><div class="line">private String mDescriptor;</div><div class="line"></div><div class="line">public static final native int getCallingPid();// 调用者进程ID, 可以用来检查权限</div><div class="line">public static final native int getCallingUid();// 返回与进程绑定的调用者用户ID, 可以用来检查权限</div><div class="line">public static final native long clearCallingIdentity();// 重置调用者ID, 当你需要调用别的Interface的时候, 为了让被调用的Interface检查你自己的权限, 你需要重置调用者ID. 它返回的token可以通过下面这个方法恢复调用者ID  </div><div class="line">public static final native void restoreCallingIdentity(long token);// 恢复调用者ID</div><div class="line">public static final native void setThreadStrictModePolicy(int policyMask);// 设置native层StrictMode策略</div><div class="line">public static final native int getThreadStrictModePolicy();// 获取native层StrictMode策略</div><div class="line">public static final native void flushPendingCommands();// 把等待中的命令刷到内核驱动. 如果将要执行一个可能阻塞很长时间的命令, 那么本方法可以将线程中等待的命令刷到内核驱动, 以防止本线程过久地持有等待中命令的引用</div><div class="line">public static final native void joinThreadPool();// 把调用者线程加入IPC线程池, 该方法仅在进程退出时返回</div><div class="line"></div><div class="line">public Binder() &#123;</div><div class="line">	init();// native method</div><div class="line">	// code to check potential leaks</div><div class="line">&#125;</div><div class="line">public void attachInterface(IInterface owner, String descriptor);// 绑定IInterface和对应的descriptor</div><div class="line">public String getInterfaceDescriptor();</div><div class="line">public boolean pingBinder();// 默认返回true</div><div class="line">public boolean isBinderAlive();// 默认返回true</div><div class="line">public IInterface queryLocalInterface(String descriptor);// 返回descriptor对应的IInterface或者null</div><div class="line">protected boolean onTransact(int code, Parcel data, Parcel reply, int flags);// 真正的事务执行函数, 希望子类重写</div><div class="line">public final boolean transact(int code, Parcel data, Parcel reply, int flags);// 事务执行函数, 里面回调onTransact</div><div class="line">private boolean execTransact(int code, int dataObj, int replyObj, int flags);// 回调onTrasact, 如果抛出异常则返回true</div><div class="line">public void linkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line">public boolean unlinkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line"></div><div class="line">private native final void init();</div><div class="line">private native final void destroy();</div><div class="line">&#125;// Binder类</div><div class="line"></div><div class="line">final class BinderProxy implements IBinder &#123;// BinderProxy类</div><div class="line">    BinderProxy() &#123;</div><div class="line">        mSelf = new WeakReference(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 以下六个方法都成了native方法</div><div class="line">    public native boolean pingBinder();</div><div class="line">    public native boolean isBinderAlive();</div><div class="line">    public native String getInterfaceDescriptor();</div><div class="line">    public native boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line">    public native void linkToDeath(DeathRecipient recipient, int flags);</div><div class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</div><div class="line"></div><div class="line">    final private WeakReference mSelf;// 指向自身的弱引用</div><div class="line">    private int mObject;</div><div class="line">    private int mOrgue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完源码至少有三个疑问: 1. IInterface和IBinder定义了哪些接口? 2. BinderProxy是什么, 怎么用的? 3. <code>Binder.java</code>中涉及到的那些native方法, 是怎么实现的?<br>打开<code>frameworks/base/core/java/android/os/IBinder.java</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/** 注释中详细讲述了IBinder的设计思路. 核心API是transact(), 与Binder的onTransact成对. 作为本地对象的它发送一个调用到远程IBinder对象, 同时作为远程对象的它可以接受一个调用并放到一个Binder对象中. 这个API是同步的, 以保证仅在远程onTransact返回后, 本地transact才返回, 这是所期望的行为.  </div><div class="line">系统在每个进程中维护一个事务线程池, 用于分发所有从外部进程进来的IPC. Binder系统允许递归调用, 比如A调用B, B的onTransact中又调用了A. */</div><div class="line">    // 定义了用户可以使用的事务代码</div><div class="line">    int FIRST_CALL_TRANSACTION  = 0x00000001;</div><div class="line">    int LAST_CALL_TRANSACTION   = 0x00ffffff;</div><div class="line"></div><div class="line">    // IBinder协议的事务代码</div><div class="line">    int PING_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;P&apos;&lt;&lt;16)|(&apos;N&apos;&lt;&lt;8)|&apos;G&apos;;</div><div class="line">    int DUMP_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;D&apos;&lt;&lt;16)|(&apos;M&apos;&lt;&lt;8)|&apos;P&apos;;</div><div class="line">    int INTERFACE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;N&apos;&lt;&lt;16)|(&apos;T&apos;&lt;&lt;8)|&apos;F&apos;;</div><div class="line">    int TWEET_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;T&apos;&lt;&lt;16)|(&apos;W&apos;&lt;&lt;8)|&apos;T&apos;;</div><div class="line">    int LIKE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;L&apos;&lt;&lt;16)|(&apos;I&apos;&lt;&lt;8)|&apos;K&apos;;// 告诉app调用者喜欢它. 可选命令, 应用不必处理, 没啥卵用. 默认实现啥也不做.  </div><div class="line">    int SYSPROPS_TRANSACTION = (&apos;_&apos;&lt;&lt;24)|(&apos;S&apos;&lt;&lt;16)|(&apos;P&apos;&lt;&lt;8)|&apos;R&apos;;// hide</div><div class="line"></div><div class="line">    // transact的标记, 表示这是一个单向调用, 调用者不等待被调用者的结果, 而是立即返回</div><div class="line">    int FLAG_ONEWAY             = 0x00000001;</div><div class="line">    public static final int MAX_IPC_SIZE = 64 * 1024;// hide</div><div class="line"></div><div class="line">    public String getInterfaceDescriptor();</div><div class="line">    // 查询Binder是否可用有三种方式, 当Binder不可用时, transact()会抛出RemoteException, pingBinder()会返回false, linkToDeath()预先连接一个DeathRecipient, 不可用时会回调这个DeathRecipient的binderDied()</div><div class="line">    public boolean pingBinder();</div><div class="line">    public boolean isBinderAlive();</div><div class="line"></div><div class="line">    public IInterface queryLocalInterface(String descriptor);</div><div class="line"></div><div class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line"></div><div class="line">    public interface DeathRecipient &#123;</div><div class="line">        public void binderDied();</div><div class="line">    &#125;</div><div class="line">    public void linkToDeath(DeathRecipient recipient, int flags);// 连接一个DeathRecipient接收器, 当Binder不可用时回调</div><div class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</div></pre></td></tr></table></figure></p>
<p>可见, IBinder定义了一套Transaction协议用于指明发起的Transaction类型, 定义了<code>transact()</code>核心接口, 该接口与Binder中的<code>onTransact</code>配合使用才能完成远程调用的功能. 定义了查询接口, 返回一个<code>IInterface</code>实例. 下面看看这个接口定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IInterface</div><div class="line">&#123;</div><div class="line">    public IBinder asBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就这一个接口方法, 返回<code>IBinder</code>实例. 注释中说该方法返回与该Interface绑定的Binder实例.<br>以上这些内容, 定义了一个基本的Binder系统框架, 即通过同一套<code>Binder &amp; IBinder &amp; IInterface</code>接口, 本地以<code>transact()</code>发起远程调用, 远程在<code>onTransact()</code>中处理相应调用. 本地以<code>asInterface()</code>获取远程服务的实例(实际获得的是服务的代理, 代理内对每个服务接口中的方法, 调用远程服务的transact方法, 传递一个约定好的事务代码和方法参数, 远程服务的onTransact会对每个约定好的事务代码, 生成相应的switch case, 调用真正的服务接口实现. 由于客户端和服务端对服务接口的定义是相同的, 故生成的服务接口也相同, 可以在本地aidl生成的java文件中查看onTransact的实现), 远程以<code>asBinder()</code>返回远程服务的实例, 本地通过asInterface返回的代理来调用远程服务的方法, 跟调用本地服务方法表面上看起来没有差别.  </p>
<h3 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h3><p>离开具体实现的Binder是无法工作的, 我们自己当然可以自行继承Binder来写自己的远程服务. AIDL是Android为我们提供的一种方便快捷生成Binder实现的方式和工具, 而Service是由系统实现了服务端的Binder. 我们以它为例, 说明如何启动服务, 以及其中哪里用到了Binder.<br>我们知道, 要获取服务(系统服务除外, 其实系统服务就是提供了一个通过descriptor获取服务的接口), 首先我们要知道服务的全名, 在Intent中设定服务全名, 并指定一个ServiceConnection回调, 调用<code>bindService(Intent, ServiceConnection, CONTEXT_OPTION)</code>绑定服务(其中第三个参数的含义稍后解释), 在<code>ServiceConnection</code>中获取到服务实例. 我们已经知道<code>ServiceConnection</code>的回调方法被调用时已经得到了服务实例, 下面我们看看<code>bindService</code>如何绑定服务获取服务实例.  </p>
<p><code>bindService</code>方法的定义来自于<code>Context</code>, <code>Activity</code>的<code>bindService</code>调用的是<code>ContextWrapper.bindService</code>, 其默认实现是调用<code>mBase.bindService</code>, <code>mBase</code>是一个<code>Context</code>类型的成员变量, 这里的<code>mBase</code>是一个<code>ContextImpl</code>实例变量. 在<code>ContextImpl.java</code>中, <code>bindService</code>是这么定义的:  </p>
<pre><code>class ContextImpl extends Context {
    ......

    @Override
    public boolean bindService(Intent service, ServiceConnection conn,
            int flags) {  
        IServiceConnection sd;  
        if (mPackageInfo != null) {  
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),  
                mMainThread.getHandler(), flags);  
        } else {  
            ......  
        }  
        try {  
            int res = ActivityManagerNative.getDefault().bindService(  
                mMainThread.getApplicationThread(), getActivityToken(),  
                service, service.resolveTypeIfNeeded(getContentResolver()),  
                sd, flags);  
            ......  
            return res != 0;  
        } catch (RemoteException e) {  
            return false;  
        }
    }
    ......
}
</code></pre><p>这里的mMainThread是一个<code>ActivityThread</code>实例, 通过它的<code>getHandler</code>函数可以获得一个Handler对象(这里返回的Handler是在<code>ActivityThread</code>类内部从Handler类继承下来的一个H类实例变量), 有了这个Handler对象后, 就可以把消息分发到<code>ActivityThread</code>所在的线程消息队列中去了.<br>获得了这个Handler对象后, 就调用<code>mPackageInfo.getServiceDispatcher</code>函数来获得一个<code>IServiceConnection</code>接口, 这里的<code>mPackageInfo</code>的类型是<code>LoadedApk</code>, 它的<code>getServiceDispatcher</code>函数比较长我就不贴了, 大致上它先以传进来的context为key查找<code>mServices</code>成员中是否已经有对应的<code>ServiceDispatcher</code>, 没有则新建一个, 将传进来的<code>ServiceConnection</code>和Handler都保存在<code>ServiceDispatcher</code>内部, 并创建一个<code>InnerConnection</code>, <font color="red">这是一个Binder对象!</font> 最后返回给sd的就是这个<code>InnerConnection</code>对象.  </p>
<div id="LoadedApk.ServiceDispatcher.InnerConnection"></div><br>接着调用<code>ActivityManagerNative.getDefault().bindService()</code>, 在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>文件中, 函数定义如下:<br><br><div id="ActivityManagerService-bindService"></div>  

<pre><code>class ActivityManagerProxy implements IActivityManager  
{  
    ......  

    public int bindService(IApplicationThread caller, IBinder token,  
            Intent service, String resolvedType, IServiceConnection connection,  
            int flags) throws RemoteException {  
        Parcel data = Parcel.obtain();  
        Parcel reply = Parcel.obtain();  
        data.writeInterfaceToken(IActivityManager.descriptor);  
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeStrongBinder(token);  
        service.writeToParcel(data, 0);  
        data.writeString(resolvedType);  
        data.writeStrongBinder(connection.asBinder());// 被调用的服务的Binder作为数据传输给服务端
        data.writeInt(flags);  
        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);// 调用了transact, 进Binder驱动
        reply.readException();  
        int res = reply.readInt();  
        data.recycle();  
        reply.recycle();  
        return res;  
    }  

    ......  
}  
</code></pre><p>这个函数通过Binder驱动程序就进入到<code>ActivityManagerService</code>的<code>bindService</code>函数去了(到此为止, 代码执行就从Binder客户端进入到了Binder服务端), 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>文件中, 代码比较长就不贴了. 主要做了以下这些事:<br>函数首先根据传进来的参数token(是调用者Activity在<code>ActivityManagerService</code>里面的令牌), 将这个代表调用者Activity的<code>ActivityRecord</code>取回来.<br>接着通过<code>retrieveServiceLocked</code>函数, 得到一个<code>ServiceRecord</code>, 这个<code>ServiceReocrd</code>描述的是一个Service对象,这是根据传进来的参数service的内容获得的(service是个Intent, 带有我们要用的具体Service的信息).<br>接着把传进来的connection参数封装成一个<code>ConnectionRecord</code>对象, 并保存了它的一个引用到<code>activity.connections</code>中以方便后续取用.<br>最后, 传进来的第四个参数flags是有限的几种<code>BindServiceFlags</code>中的一种, 它决定了具体行为. 以<code>BIND_AUTO_CREATE</code>为例, 它会走到<code>private final boolean bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean whileRestarting)</code>, 第一个参数就是前面的Intent service, 第二个参数通过<code>service.getFlags()</code>得到, 第三个参数传的false. 该函数中, 首先判断应用进程是否存在, 如果存在则调用<code>realStartServiceLocked(r, app)</code>, app是通过进程名和uid获取到的<code>ProcessRecord</code>(如果不存在则启动新进程, 并将服务压栈等待进程启动完成, 在这个新进程上执行serivce). 来看这个函数实现:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......
    private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app) throws RemoteException {  
        ......  
        r.app = app;  
        ......  

        app.services.add(r);
        ......  

        try {  
            ......  
            app.thread.scheduleCreateService(r, r.serviceInfo);  
            ......  
        } finally {  
            ......  
        }  

        requestServiceBindingsLocked(r);  

        ......  
    }
    ......
}
</code></pre><p>这个函数执行了两个操作, 一个是<code>app.thread.scheduleCreateService(r, r.serviceInfo)</code>在应用程序进程内部创建Service, 这个操作会导致Service的<code>onCreate</code>被调用; 另一个操作是调用<code>requestServiceBindingsLocked</code>函数向服务获取一个Binder对象, 这个操作会导致Service的<code>onBind</code>函数被调用. 可能有读者觉得有点偏题了, 实际不然, 这两个操作都依赖Binder机制. 先来看前者:  </p>
<pre><code>class ApplicationThreadProxy implements IApplicationThread {  
    ......  

    public final void scheduleCreateService(IBinder token, ServiceInfo info)  
            throws RemoteException {  
        Parcel data = Parcel.obtain();  
        data.writeInterfaceToken(IApplicationThread.descriptor);  
        data.writeStrongBinder(token);  
        info.writeToParcel(data, 0);  
        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null,  
            IBinder.FLAG_ONEWAY);// 又一次Binder调用, 进入到的是ApplicationThread.scheduleCreateService, flag引人注目
        data.recycle();  
    }  

    ......  
}  
</code></pre><p>这里通过Binder驱动程序就进入到<code>ApplicationThread</code>的<code>scheduleCreateService</code>函数去了. 它的定义在<code>frameworks/base/core/java/android/app/ActivityThread.java</code>文件中:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    private final class ApplicationThread extends ApplicationThreadNative {  
        ......  

        public final void scheduleCreateService(IBinder token,  
            ServiceInfo info) {  
            CreateServiceData s = new CreateServiceData();  
            s.token = token;  
            s.info = info;  

            queueOrSendMessage(H.CREATE_SERVICE, s);  
        }  

        ......  
    }  
    ......  
}  
</code></pre><p>其中<code>queueOrSendMessage</code>是<code>ActivityThread</code>的方法, 它用Handler把创建服务的操作放到了Activity线程的消息队列中, 在<code>handleMessage</code>时调用<code>handleCreateService</code>处理该消息, 代码如下:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    private final void handleCreateService(CreateServiceData data) {  
        ......  

        LoadedApk packageInfo = getPackageInfoNoCheck(  
        data.info.applicationInfo);  
        Service service = null;  
        try {  
            java.lang.ClassLoader cl = packageInfo.getClassLoader();  
            service = (Service) cl.loadClass(data.info.name).newInstance();  // 加载类, 获得实例
        } catch (Exception e) {  
            ......  
        }  

        try {  
            ......  

            ContextImpl context = new ContextImpl();  
            context.init(packageInfo, null, this);  

            Application app = packageInfo.makeApplication(false, mInstrumentation);  
            context.setOuterContext(service);  
            service.attach(context, this, data.info.name, data.token, app,  
                ActivityManagerNative.getDefault());  // 绑定服务

            service.onCreate();  // 进入onCreate生命周期
            mServices.put(data.token, service); // 保存服务映射
            ......  
        } catch (Exception e) {  
            ......  
        }  
    }  
    ......  
}  
</code></pre><p>至此, 服务实例就创建出来了. 下面回到<code>realStartServiceLocked</code>看<code>requestServiceBindingsLocked</code>, 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>中:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative  
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......  

    private final void requestServiceBindingsLocked(ServiceRecord r) {  
        Iterator&lt;IntentBindRecord&gt; bindings = r.bindings.values().iterator();  
        while (bindings.hasNext()) {  
            IntentBindRecord i = bindings.next();  
            if (!requestServiceBindingLocked(r, i, false)) {  
                break;  
            }  
        }  
    }  

    private final boolean requestServiceBindingLocked(ServiceRecord r,  
            IntentBindRecord i, boolean rebind) {  
        ......  
        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) {  
          try {  
              ......  
              r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);  
              ......  
          } catch (RemoteException e) {  
              ......  
          }  
        }  
        return true;  
    }  

    ......  
}  
</code></pre><p>(下回分解)<br>1月9日, 继续分解Service启动过程.<br>前面说到经过<code>handleCreateService</code>之后, <code>Service</code>实例就通过ClassLoader载入到内存, 并通过newInstance创建了实例, 且进入到<code>onCreate</code>周期. 创建完毕后, 接着调用<code>requestServiceBindingsLocked</code>, 这个方法从名字看应该是要绑定服务了, 打开源码发现它实际调用了<code>app.thread.scheduleBindService</code>, 传的参数<code>ServiceRecord r</code>代表我们启动的自定义服务. <code>app.thread</code>是一个Binder对象的远程接口, 它的类型是<code>ApplicationThreadProxy</code>, 这一点从前面也看得出来. 通过代理和Binder驱动, 我们就进入到<code>ApplicationThread</code>的<code>scheduleBindService</code>中了:  </p>
<pre><code>class ApplicationThreadProxy implements IApplicationThread {  
    ......  

    public final void scheduleBindService(IBinder token, Intent intent, boolean rebind)  throws RemoteException {  
        Parcel data = Parcel.obtain();  
        data.writeInterfaceToken(IApplicationThread.descriptor);  
        data.writeStrongBinder(token);  
        intent.writeToParcel(data, 0);  
        data.writeInt(rebind ? 1 : 0);  
        mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, null,  
            IBinder.FLAG_ONEWAY);  
        data.recycle();  
    }  

    ......  
}  
</code></pre><p>那么, 我们来看看<code>ApplicationThread</code>中<code>scheduleBindService</code>是怎么实现的:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    public final void scheduleBindService(IBinder token, Intent intent,  
            boolean rebind) {  
        BindServiceData s = new BindServiceData();  
        s.token = token;  
        s.intent = intent;  
        s.rebind = rebind;  

        queueOrSendMessage(H.BIND_SERVICE, s);  
    }  

    ......  
}  
</code></pre><p>很眼熟对不对? 相信不用我说你也知道之后是什么了:  </p>
<div id="Service.onBind"></div>  

<pre><code>switch (msg.what) {  
......  
case BIND_SERVICE:  
    handleBindService((BindServiceData)msg.obj);  
    break;  
......  
}  

...
private final void handleBindService(BindServiceData data) {  
    Service s = mServices.get(data.token);  
    if (s != null) {  
        try {  
            data.intent.setExtrasClassLoader(s.getClassLoader());  
            try {  
                if (!data.rebind) {  
                    IBinder binder = s.onBind(data.intent);  
                    ActivityManagerNative.getDefault().publishService(  
                        data.token, data.intent, binder);  
                } else {  
                    ......  
                }  
                ......  
            } catch (RemoteException ex) {  
            }  
        } catch (Exception e) {  
            ......  
        }  
    }  
}
</code></pre><p>首先将前面保存在<code>mServices</code>中的服务通过<code>data.token</code>取出来放到本地变量, 然后让它执行<code>onBind</code>获得一个Binder对象, 接着将这个对象传递给<code>ActivityManagerService.getDefa().publishService()</code>. <code>onBind</code>是自定义服务自己重写的, 就是返回一个实现了IBinder接口的Binder对象. <code>publishSerivce</code> 定义在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>中, 如下:  </p>
<pre><code>class ActivityManagerProxy implements IActivityManager  
{  
    ......  
    public void publishService(IBinder token,  
    Intent intent, IBinder service) throws RemoteException {  
        Parcel data = Parcel.obtain();  
        Parcel reply = Parcel.obtain();  
        data.writeInterfaceToken(IActivityManager.descriptor);  
        data.writeStrongBinder(token);  
        intent.writeToParcel(data, 0);  
        data.writeStrongBinder(service);  
        mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0);// 眼熟不?  
        reply.readException();  
        data.recycle();  
        reply.recycle();  
    }  
    ......  
}
</code></pre><p>再来看<code>publishService</code>的实现, 理所当然它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>中:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative  
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......  

    public void publishService(IBinder token, Intent intent, IBinder service) {  
        ......  
        synchronized(this) {  
            ......  
            ServiceRecord r = (ServiceRecord)token;  
            ......  

            ......  
            if (r != null) {  
                Intent.FilterComparison filter  
                    = new Intent.FilterComparison(intent);  
                IntentBindRecord b = r.bindings.get(filter);  
                if (b != null &amp;&amp; !b.received) {  
                    b.binder = service;  
                    b.requested = true;  
                    b.received = true;  
                    if (r.connections.size() &gt; 0) {  
                        Iterator&lt;ArrayList&lt;ConnectionRecord&gt;&gt; it  
                            = r.connections.values().iterator();  
                        while (it.hasNext()) {  
                            ArrayList&lt;ConnectionRecord&gt; clist = it.next();  
                            for (int i=0; i&lt;clist.size(); i++) {  
                                ConnectionRecord c = clist.get(i);  
                                ......  
                                try {  
                                    c.conn.connected(r.name, service);  
                                } catch (Exception e) {  
                                    ......  
                                }  
                            }  
                        }  
                    }  
                }  

                ......  
            }  
        }  
    }  

    ......  
}
</code></pre><p>这里传进来的service不出意外的话就是我们自定义<code>onBinder</code>返回的那个东西了, 也就是我们自定义服务的实例. 这里的<code>token</code>是一个<code>ServiceRecord</code>对象, 是在前面<a href="#ActivityManagerService-bindService">bindService</a>中中创建的. 在那里, 我们保存了自定义服务的一个<code>ConnectionRecord</code>在这个<code>ServiceRecord.connections</code>列表中, 因此这里可以通过<code>r.connections</code>取出那个<code>ConnectionRecord</code>.<br>取出<code>ConnectionRecord</code>之后, 调用成员变量的函数<code>conn.connected()</code>. 这个conn是一个<code>IServiceConnection</code>类型, 它是一个Binder对象的远程接口, 这个Binder对象, 就是我们在<a href="#LoadedApk.ServiceDispatcher.InnerConnection">前面</a>创建的<code>LoadedApk.ServiceDispatcher.InnerConnection</code>对象. 因此, 这里的<code>connected</code>就到了<code>InnerConnection.connected</code>:  </p>
<pre><code>// in file frameworks/base/core/java/android/app/LoadedApk.java
final class LoadedApk {  
    ......  

    static final class ServiceDispatcher {  
        ......  

        private static class InnerConnection extends IServiceConnection.Stub {  
            ......  

            public void connected(ComponentName name, IBinder service) throws RemoteException {  
                LoadedApk.ServiceDispatcher sd = mDispatcher.get();  
                if (sd != null) {  
                    sd.connected(name, service);  // 转到了外层ServiceDispatcher类中的connected
                }  
            }  
            ......  
        }  
        ......  

        public void connected(ComponentName name, IBinder service) {  
            if (mActivityThread != null) {  
                mActivityThread.post(new RunConnection(name, service, 0)); // 放到ActivityThread的消息队列中. mActivityThread是一个Handler实例  
            } else {  
                ......  
            }  
        }  
        ......  

        private final class RunConnection implements Runnable {  
            ......  

            public void run() {  
                if (mCommand == 0) {  
                    doConnected(mName, mService);  
                } else if (mCommand == 1) {  
                    ......  
                }  
            }  
            ......  
        }  
        ......  

        public void doConnected(ComponentName name, IBinder service) {  
            ......  

            // If there is a new service, it is now connected.  
            if (service != null) {  
                mConnection.onServiceConnected(name, service);  
            }  
        }  
    }  
    ......  
}
</code></pre><p>新建了一个<code>RunConnection</code>并调用<code>H.post</code>放到了<code>ActivityThread</code>的消息队列中. 当处理该消息时, 会运行的<code>RunConnection</code>的<code>run()</code>来处理, 原因见我另一篇文章<a href="./handler.md">Handler原理</a>. 此时<code>mCommand==0</code>, 最后就会执行到<code>mConnection.onServiceConnected</code>函数. 这里的<code>mConnection</code>的类型是<code>ServiceConnection</code>, 它是在<a href="#ActivityManagerService-bindService">前面</a>设置好的, 它是我们调用<code>bindService</code>时传入的<code>ServiceConnection</code>实例, 在前面我们用它通过<code>ServiceDispatcher</code>换得了一个<code>IServiceConnection</code>对象.<br>传入的第二个参数<code>service</code>是一个IBinder对象, 它其实就是我们<a href="#Service.onBind">前面</a>从自定义Service中得到的自定义Binder对象, 因此这里我们可以直接强转成那个自定义Binder类型, 并通过它的<code>getService</code>接口获取到自定义服务的接口. 至此, 我们经过<code>onServiceConnection</code>, 调用<code>getService</code>, 绑定并获取了自定义服务.  </p>
<h3 id="Binder驱动的实现"><a href="#Binder驱动的实现" class="headerlink" title="Binder驱动的实现"></a>Binder驱动的实现</h3><p>上面多次提到”进入了Binder驱动”, 可见Binder驱动在这个设计中具有重要的桥梁作用. 那么除了上面看到的那些, Binder驱动到底是什么样子呢? 接下来让我们深入Binder驱动源码.<br>首先我们要知道是哪里进入到Native Binder驱动的:<br><code>IYourService.Stub.Proxy.YOUR_API()</code>中, 调用<code>android.os.IBinder(实现在 android.os.Binder.BinderProxy).transact()</code>发送<code>Stub.TRANSACTION_YOUR_API</code> ==&gt; <strong><code>BinderProxy.transact()</code>进入Native层</strong> ==&gt; 由jni转到<code>android_os_BinderProxy_transact()</code>函数 ==&gt; 调用<code>IBinder-&gt;transact</code>函数.  </p>
<h4 id="调用mRemote-transact时进到了BinderProxy并在其中调用native方法android-os-BinderProxy-transact"><a href="#调用mRemote-transact时进到了BinderProxy并在其中调用native方法android-os-BinderProxy-transact" class="headerlink" title="调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()"></a>调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()</h4><p>直到jni为止的内容我们前面已经了解过了, 下面来看<code>android_os_BinderProxy_transact()</code>函数:  </p>
<pre><code>// in file frameworks/base/core/jni/android_util_Binder.cpp

......

static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,
        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException
{
    // check and parse data
    ......

    IBinder* target = (IBinder*)
        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);// 获取mObject指向的本地对象

    status_t err = target-&gt;transact(code, *data, reply, flags);// 调用本地代码的transact

    if (err == NO_ERROR) {
        return JNI_TRUE;
    } else if (err == UNKNOWN_TRANSACTION) {
        return JNI_FALSE;
    }

    signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize());
    return JNI_FALSE;
}
......

static const JNINativeMethod gBinderProxyMethods[] = {
     /* name, signature, funcPtr */
    {&quot;pingBinder&quot;,          &quot;()Z&quot;, (void*)android_os_BinderProxy_pingBinder},
    {&quot;isBinderAlive&quot;,       &quot;()Z&quot;, (void*)android_os_BinderProxy_isBinderAlive},
    {&quot;getInterfaceDescriptor&quot;, &quot;()Ljava/lang/String;&quot;, (void*)android_os_BinderProxy_getInterfaceDescriptor},
    {&quot;transactNative&quot;,      &quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;, (void*)android_os_BinderProxy_transact},
    {&quot;linkToDeath&quot;,         &quot;(Landroid/os/IBinder$DeathRecipient;I)V&quot;, (void*)android_os_BinderProxy_linkToDeath},
    {&quot;unlinkToDeath&quot;,       &quot;(Landroid/os/IBinder$DeathRecipient;I)Z&quot;, (void*)android_os_BinderProxy_unlinkToDeath},
    {&quot;destroy&quot;,             &quot;()V&quot;, (void*)android_os_BinderProxy_destroy},
};
......
</code></pre><p>其中, <code>gBinderProxyOffsets.mObject</code>是在Java层调用<code>IBinder.getContextObject()</code>时, 在<code>javaObjectForIBinder</code>函数中设置的:  </p>
<pre><code>// in file frameworks/base/core/jni/android_util_Binder.cpp
......

static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)
{
    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);
    return javaObjectForIBinder(env, b);
}

jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)
{
    ...
    LOGDEATH(&quot;objectForBinder %p: created new proxy %p !\n&quot;, val.get(), object);
    // The proxy holds a reference to the native object.
    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());// 设置本地IBinder对象, 令mObject指向它
    val-&gt;incStrong((void*)javaObjectForIBinder);
    ...
}

.....
########################################################################

// in file frameworks/native/libs/binder/ProcessState.cpp
......

sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)
{
    return getStrongProxyForHandle(0);
}

sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;
    ...
    b = new BpBinder(handle);
    result = b;
    ...
    return result;
}
</code></pre><p>可见, <code>android_os_BinderProxy_transact()</code>函数实际上调用的是 <code>BpBinder::transact()</code> 函数.  </p>
<h4 id="jni中的target-gt-transact调用进到BpBinder-再进到IPCThreadState"><a href="#jni中的target-gt-transact调用进到BpBinder-再进到IPCThreadState" class="headerlink" title="jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState"></a>jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState</h4><p>来看看<code>BpBinder::transact()</code>, 它位于<code>frameworks/native/libs/binder/BpBinder.cpp</code>:  </p>
<pre><code>status_t BpBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);// 调用IPCThreadState::self()-&gt;transact
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}
</code></pre><p><code>IPCThreadState</code>中是这么写的:  </p>
<pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    if (err == NO_ERROR) {
        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),
            (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            Parcel fakeReply;
            err = waitForResponse(&amp;fakeReply);
        }
    } else {
        err = waitForResponse(NULL, NULL);
    }

    return err;
}

status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */
    tr.target.handle = handle;
    tr.code = code;
    ...

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}
</code></pre><p>由函数内容可以看出, 数据再一次通过 <code>writeTransactionData()</code> 传递给 <code>mOut</code> 进行写入操作. <code>mOut</code> 是一个 <code>Parcel</code> 对象, 声明在 <code>IPCThreadState.h</code> 文件中. 之后则调用 <code>waitForResponse()</code> 函数.</p>
<h4 id="IPCThreadState-waitForResponse-在一个-while-循环里不断的调用-talkWithDriver-并检查是否有数据返回"><a href="#IPCThreadState-waitForResponse-在一个-while-循环里不断的调用-talkWithDriver-并检查是否有数据返回" class="headerlink" title="IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回"></a>IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回</h4><!-- 此处插代码 -->  
<pre><code>// in file frameworks/base/libs/binder/IPCThreadState.cpp
......

status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) { // 永真循环
        if ((err=talkWithDriver()) &lt; NO_ERROR) break; // 调用talkWithDriver, 当返回负时退出循环
        err = mIn.errorCheck();
        if (err &lt; NO_ERROR) break;
        if (mIn.dataAvail() == 0) continue;

        cmd = mIn.readInt32(); // 读取命令

        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;
                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;
        }

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            if (!reply &amp;&amp; !acquireResult) goto finish;
            break;

        case BR_DEAD_REPLY:
            err = DEAD_OBJECT;
            goto finish;

        case BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;
            goto finish;

        case BR_ACQUIRE_RESULT:
            {
                LOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);
                const int32_t result = mIn.readInt32();
                if (!acquireResult) continue;
                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
            }
            goto finish;

        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));// 读取远端返回的数据
                LOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);
                if (err != NO_ERROR) goto finish;

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        err = *static_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);
                        freeBuffer(NULL,
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t), this);
                    }
                } else {
                    freeBuffer(NULL,
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t), this);
                    continue;
                }
            }
            goto finish;

        default:
            err = executeCommand(cmd); // 处理其他命令, 例如NO_ERROR
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    if (err != NO_ERROR) {
        if (acquireResult) *acquireResult = err;
        if (reply) reply-&gt;setError(err);
        mLastError = err;
    }

    return err;
}
......
</code></pre><p><div id="talkWithDriver"></div></p>
<h4 id="IPCThreadState-talkWithDriver-函数是真正与-binder-驱动交互的实现"><a href="#IPCThreadState-talkWithDriver-函数是真正与-binder-驱动交互的实现" class="headerlink" title="IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现"></a>IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现</h4><!-- 此处插代码 -->  
<pre><code>......

status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= 0, &quot;Binder driver is not opened&quot;);

    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();

    // We don&apos;t want to write anything if we are still reading
    // from data left in the input buffer and the caller
    // has requested to read the next data.
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    // 写入数据
    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    // 读取数据
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
    }

    IF_LOG_COMMANDS() {
        TextOutput::Bundle _b(alog);
        if (outAvail != 0) {
            alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;
            const void* cmds = (const void*)bwr.write_buffer;
            const void* end = ((const uint8_t*)cmds)+bwr.write_size;
            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;
            while (cmds &lt; end) cmds = printCommand(alog, cmds);
            alog &lt;&lt; dedent;
        }
        alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size
            &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;
    }

    // Return immediately if there is nothing to do.
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        }
#if defined(HAVE_ANDROID_OS)
        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令
        // 该过程在下一节详述
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            err = -errno;
#else
        err = INVALID_OPERATION;
#endif
        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        }
    } while (err == -EINTR);

    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)err &lt;&lt; &quot;, write consumed: &quot;
            &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()
            &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;
    }

    if (err &gt;= NO_ERROR) {
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        IF_LOG_COMMANDS() {
            TextOutput::Bundle _b(alog);
            alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
            alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;
            const void* cmds = mIn.data();
            const void* end = mIn.data() + mIn.dataSize();
            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;
            while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);
            alog &lt;&lt; dedent;
        }
        return NO_ERROR;
    }

    return err;
}
......
</code></pre><p><code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code> 就是使用系统调用函数 <code>ioctl</code> 向 <code>binder</code> 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令.<br>回到上一步<code>waitForResponse</code>, 获取到<code>talkWithDriver</code>返回的命令<code>cmd</code>后默认执行<code>executeCommand(cmd)</code>, 来处理返回命令  </p>
<h4 id="IPCThreadState-executeCommand-int32-t-cmd-处理返回命令"><a href="#IPCThreadState-executeCommand-int32-t-cmd-处理返回命令" class="headerlink" title="IPCThreadState::executeCommand(int32_t cmd) 处理返回命令"></a>IPCThreadState::executeCommand(int32_t cmd) 处理返回命令</h4><p>除了在switch case中处理的命令以外, 其他的命令都通过调用<code>executeCommand</code>来处理, 它的实现如下:<br><!-- 此处插代码 -->  </p>
<pre><code>......

status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
    // switch能处理的命令很多, 我们省略掉其他命令, 重点看正常数据处理
    ...
    case BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr));
            LOG_ASSERT(result == NO_ERROR,
                &quot;Not enough command data for brTRANSACTION&quot;);
            if (result != NO_ERROR) break;

            Parcel buffer;
            buffer.ipcSetDataReference(
                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t), freeBuffer, this);

            // 判断和设置优先级
            ...

            Parcel reply;
            if (tr.target.ptr) {
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);// 实际执行的是 BBinder.transact() !
                if (error &lt; NO_ERROR) reply.setError(error);

            } else {
                const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);
            }

            if ((tr.flags &amp; TF_ONE_WAY) == 0) {
                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);
                sendReply(reply, 0);
            } else {
                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);
            }
            ...
        }
        break;
    ...
    return result;
}
......
</code></pre><p>可见它调用了<code>BBinder::transact()</code>来处理数据, 该函数定义如下:  </p>
<pre><code>// in file frameworks/base/libs/binder/Binder.cpp
status_t BBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    data.setDataPosition(0);

    status_t err = NO_ERROR;
    switch (code) {
        case PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            break;
        default:
            err = onTransact(code, data, reply, flags);// 调用onTransact
            break;
    }

    if (reply != NULL) {
        reply-&gt;setDataPosition(0);
    }

    return err;
}
</code></pre><p>在此处<code>b-&gt;transact</code>调用时, <code>b</code>是一个<code>JavaBBinder</code>实例, <code>JavaBBinder</code>继承了<code>BBinder</code>类, 重写了<code>onTransact</code>, 所以这里实际调用的是<code>JavaBBinder.onTransact</code>, 定义见<code>frameworks/base/core/jni/android_util_Binder.cpp</code>:  </p>
<pre><code>virtual status_t onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)
{
    JNIEnv* env = javavm_to_jnienv(mVM);
    ...
    jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,
        code, (int32_t)&amp;data, (int32_t)reply, flags);// 调用gBinderOffsets.mExecTransact
    ...
    return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;
}


static int int_register_android_os_Binder(JNIEnv* env)
{
    jclass clazz;

    clazz = env-&gt;FindClass(kBinderPathName);
    LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Binder&quot;);
    ...
    gBinderOffsets.mExecTransact
        = env-&gt;GetMethodID(clazz, &quot;execTransact&quot;, &quot;(IIII)Z&quot;);
    ...
    return AndroidRuntime::registerNativeMethods(
        env, kBinderPathName,
        gBinderMethods, NELEM(gBinderMethods));
}
</code></pre><p>由上可见, <code>JavaBBinder</code>通过JNI的<code>gBinderOffsets.mExecTransact</code>调用java方法<code>android.os.Binder.execTransact</code>. 执行的实际上是<code>android.os.Binder.onTransact</code>. 它的实现如下:  </p>
<pre><code>// in file frameworks/base/core/java/android/os/Binder.java

// Entry point from android_util_Binder.cpp&apos;s onTransact
private boolean execTransact(int code, int dataObj, int replyObj,
        int flags) {
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we&apos;ll just call it directly.
    boolean res;
    try {
        res = onTransact(code, data, reply, flags);
    }
    // catch clauses
    ...
    reply.recycle();
    data.recycle();
    return res;
}

protected boolean onTransact(int code, Parcel data, Parcel reply,
       int flags) throws RemoteException {
   if (code == INTERFACE_TRANSACTION) {
       reply.writeString(getInterfaceDescriptor());
       return true;
   } else if (code == DUMP_TRANSACTION) {
       ParcelFileDescriptor fd = data.readFileDescriptor();
       String[] args = data.readStringArray();
       if (fd != null) {
           try {
               dump(fd.getFileDescriptor(), args);
           } finally {
               try {
                   fd.close();
               } catch (IOException e) {
                   // swallowed, not propagated back to the caller
               }
           }
       }
       // Write the StrictMode header.
       if (reply != null) {
           reply.writeNoException();
       } else {
           StrictMode.clearGatheredViolations();
       }
       return true;
   }
   return false;
}
</code></pre><p>由此可见, 经过Binder驱动之后, 最终会在服务端进程的<code>android.os.Binder.onTransact</code>处理命令和数据. 而我们在服务端的<code>IYourService.Stub</code>中, 重写了<code>onTransact</code>来调用服务接口的服务端实现(大多数情况下, 这个重写是aidl工具帮你完成的). 至此, Binder驱动下的IPC通讯过程已全部明了(除了中间处理进程状态的过程以及打开Binder设备文件进行数据读写的过程以外).  </p>
<p>一句话总结就是: 客户端发送<code>BC_TRANSACTION</code>命令到Binder驱动-&gt;服务端进程监听<code>BR_TRANSACTION</code>命令并处理;如果是服务端返回数据, 过程类似, 但发送的命令是<code>BC_REPLY</code>命令-&gt;客户端监听<code>BR_REPLY</code>命令  </p>
<h4 id="Binder设备驱动实现"><a href="#Binder设备驱动实现" class="headerlink" title="Binder设备驱动实现"></a>Binder设备驱动实现</h4><p>在<a href="#talkWithDriver">上一节中</a>, 我们只简单提了一下<code>ioctl</code>系统调用是对<code>/dev/binder</code>设备文件进行读写操作, 这一节详述该过程.  </p>
<p>首先, <code>ioctl</code>第一个参数<code>mProcess-&gt;mDriverFD</code>是Binder驱动的文件描述符(File Descriptor), 它是在<code>ProcessState</code>初始化时由函数<code>open_driver()</code>初始化的, <code>open_driver</code>代码如下:  </p>
<pre><code>// in file frameworks/base/libs/binder/ProcessState.cpp
static int open_driver()
{
    int fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (fd &gt;= 0) {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
        int vers;
        // 获取驱动版本
        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);
        if (result == -1) {
            LOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));
            close(fd);
            fd = -1;
        }
        // 检查驱动版本是否一致
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            LOGE(&quot;Binder driver protocol does not match user space protocol!&quot;);
            close(fd);
            fd = -1;
        }
        // 设置最多15个线程
        size_t maxThreads = 15;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);
        if (result == -1) {
            LOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));
        }
    } else {
        LOGW(&quot;Opening &apos;/dev/binder&apos; failed: %s\n&quot;, strerror(errno));
    }
    return fd;
}
</code></pre><p>初始化后文件描述符保存在<code>mDriverFD</code>中, 以后通过它就可以和设备文件交互.  </p>
<p>其次, 在经过<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>调用后, 对设备驱动文件的读写操作就被完全封装在了结构体<code>binder_write_read</code>中. 具体的读写过程见<a href="#talkWithDriver">talkWithDriver的实现代码</a>及我的注释.<br>可见, 真正的数据读写都是通过<code>/dev/binder</code>来执行的, 其上封了命令<code>BINDER_WRITE_READ</code>用一个数据结构<code>binder_write_read</code>来存储读取和写入的数据, 再上封了<code>transact</code>处理不同逻辑概念下的事务. 再上通过<code>BBinder</code>接口联系到JNI代码和Java代码.  </p>
<p>最后, 让我们看看<code>/dev/binder</code>这个驱动程序的实现. 它是Binder的最终实现.<br>在看驱动代码前, 我们需要了解一些背景知识. 作为一个特殊的字符型设备, Binder的挂载节点是<code>/dev/binder</code>, 遵循Linux设备驱动模型, 在驱动实现过程中主要通过<code>binder_ioctl</code>函数与用户空间的进程交换数据. Android中的Service都是通过它来完成IPC的, 具体来说, 在Android虚拟机启动前, 系统会先启动<code>ServiceManager</code>进程, 它负责打开Binder驱动程序, 并告诉驱动程序自己将作为系统服务的管理者(通过特殊命令<code>BINDER_SET_CONTEXT_MGR</code>, 此后<code>ServiceManager</code>也通过Binder驱动与其他进程进行通讯), 然后<code>ServiceManager</code>进入循环, 等待处理来自其他进程的数据.<br>在Android系统中共有三种IPC机制:  </p>
<ul>
<li>标准Linux Kernel IPC 接口  </li>
<li>标准D-BUS 接口  </li>
<li>Binder接口  </li>
</ul>
<p>由于我没有了解过其他两种方式, 所以这里我就不评价孰优孰劣了, 在Android系统中大部分程序都使用了Binder接口. Binder是OpenBinder的精简实现, 包含一个Binder驱动程序, 一个Binder服务器, 一个Binder客户端.  </p>
<p>清楚了以上背景之后, 让我们看一下Binder驱动程序的实现. Android中Binder协议的定义在头文件<code>binder.h</code>中, 不同版本源码的路径不太一样, 4.0的路径在<code>external/kernel-headers/original/linux/binder.h</code>, 定义了五种Binder类型(<code>bhd</code>分别表示<code>binder</code> <code>handle</code> <code>FD</code>三个大类):  </p>
<pre><code>enum {
    BINDER_TYPE_BINDER    = B_PACK_CHARS(&apos;s&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(&apos;w&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_HANDLE    = B_PACK_CHARS(&apos;s&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(&apos;w&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_FD        = B_PACK_CHARS(&apos;f&apos;, &apos;d&apos;, &apos;*&apos;, B_TYPE_LARGE),
};
</code></pre><p>同样是在这个头文件中, 定义了用于进程间传输的数据结构, 称作Binder Object, 它是一个<code>flat_binder_object</code>结构体, 定义如下(为方便理解我把注释也放上来了):  </p>
<pre><code>/*
 * This is the flattened representation of a Binder object for transfer
 * between processes.  The &apos;offsets&apos; supplied as part of a binder transaction
 * contains offsets into the data where these structures occur.  The Binder
 * driver takes care of re-writing the structure type and data as it moves
 * between processes.
 */
struct flat_binder_object {
    /* 8 bytes for large_flat_header. */
    unsigned long        type;// Binder对象类型, 即前面Binder协议中五种类型的一种
    unsigned long        flags;// 传输方式, 见下面transaction_flags

    /* 8 bytes of data. */
    union {
        void        *binder;    /* local object */
        signed long    handle;        /* remote object */
    };

    /* extra data associated with local object */
    void            *cookie;
};

...
enum transaction_flags {
    TF_ONE_WAY    = 0x01,    /* this is a one-way call: async, no return */
    TF_ROOT_OBJECT    = 0x04,    /* contents are the component&apos;s root object */
    TF_STATUS_CODE    = 0x08,    /* contents are a 32-bit status code */
    TF_ACCEPT_FDS    = 0x10,    /* allow replies with file descriptors */
};
</code></pre><p>从注释可以知道, <code>flat_binder_object</code>中的union结构存的就是要传输的数据, 当类型为<code>Binder</code>时, 数据是一个本地对象<code>*binder</code>, 当类型为<code>Handle</code>时, 数据是一个远程对象<code>handle</code>. Binder对象在进程间传递时, Binder驱动会修改它的类型和数据.<br>正如Binder的客户端和服务端是相对而言的一样, 这里的本地Binder和远程Handle对象也是相对而言的, 其实他们都指向同一个对象, 所以他们共用一个union空间, 只不过A的本地对象binder对于另一进程B来说就是远程对象handle.  </p>
<p>虽然<code>flat_binder_object</code>是要传输的Binder对象, 但实际上Binder驱动并不直接操作它, 而是将它封装成了一个<code>binder_transaction_data</code>, 操作的直接对象是这个封装的数据. 该封装的定义如下:  </p>
<pre><code>struct binder_transaction_data {
    /* The first two are only used for bcTRANSACTION and brTRANSACTION,
     * identifying the target and contents of the transaction.
     */
    union {
        size_t    handle;    /* target descriptor of command transaction */
        void    *ptr;    /* target descriptor of return transaction */
    } target;
    void        *cookie;    /* target object cookie */
    unsigned int    code;        /* transaction command */

    /* General information about the transaction. */
    unsigned int    flags;
    pid_t        sender_pid;
    uid_t        sender_euid;
    size_t        data_size;    /* number of bytes of data */
    size_t        offsets_size;    /* number of bytes of offsets */

    /* If this transaction is inline, the data immediately
     * follows here; otherwise, it ends with a pointer to
     * the data buffer.
     */
    union {
        struct {
            /* transaction data */
            const void    *buffer;// flat_binder_object被封装在*buffer中
            /* offsets from buffer to flat_binder_object structs */
            const void    *offsets;
        } ptr;
        uint8_t    buf[8];
    } data;
};
</code></pre><p><hr><br>了解了真正传输的数据结构之后, 让我们来深入Binder生命周期. 以下内容涉及到: Binder设备创建, Binder启动, Binder释放,  Binder数据关联, Binder接口及命令含义. 我尽量从我自己追踪代码的习惯来讲解, 这样虽然效率比较低但是好处是更容易理解和回忆. 以下内容与源码实现紧密关联, 再次声明, 本文基于<code>Android4.0</code>源码写就, 不适用于其他版本.  </p>
<ol>
<li><p>Binder设备创建<br> 作为一个特殊的符号设备, Binder设备也是需要进行创建的. 可以合理猜测系统有一个统一的创建驱动设备的过程, Binder作为其中一个设备一起被创建(如果不对, 就追踪调用栈, 看哪里引用了<code>frameworks/base/cmds/servicemanager/binder.c</code>, 特别是调用了里面的<code>binder_open</code>). 在这种猜测下, 我们来找一下符号设备的创建(我假设你跟我一样不知道Android下启动过程是否跟Linux一样). 到源码目录搜索<code>/dev/binder</code>, 除了前面提到的<code>ProcessState.open_driver</code>以外, 在以下三个文件中还出现了<code>/dev/binder</code>: <code>frameworks/base/cmds/servicemanager/binder.c</code>, <code>system/core/rootdir/ueventd.rc</code>, <code>system/extras/tests/fstest/perm_checker.conf</code>. 好像没有看出哪个是创建binder设备? 别急, 如果你看过老罗的&lt;<a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>&gt;一文, 就可能猜测, 在文件<code>frameworks/base/cmds/servicemanager/binder.c</code>中, 有完整的<code>binder_open</code> <code>binder_release</code> <code>binder_write</code>实现, 正好这三个操作是实现Linux设备驱动时需要定义的基本操作的一部分, 这意味着该文件很可能就是Binder设备驱动文件. 我们假设它的确是, 那么应该有设备注册和初始化操作(模块加载, 卸载方法), 但很遗憾搜索之后发现没有. 难道Binder设备不用注册吗? 不是的, 进一步在整个源码范围搜索binder注册函数<code>binder_init</code>, 发现它匹配到了<code>prebuilt/android-arm/kernel/vmlinux-qemu</code>, 而这个我们知道是预编译好的Linux内核, 看来应该是在Linux内核源码里实现的设备注册, 遗憾的是直接下载Android源码的话是不带内核源码的, 我只好去下载了对应的内核源码(4.0系统对应3.0内核, 2.2系统对应2.6内核, 4.2~4.3系统对应3.4内核). 本文不讲怎么下载Android内核代码, 直接给出相关代码片段:  </p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

// 定义文件操作函数
static const struct file_operations binder_fops = {
    .owner = THIS_MODULE,
    .poll = binder_poll,
    .unlocked_ioctl = binder_ioctl,
    .mmap = binder_mmap,
    .open = binder_open,
    .flush = binder_flush,
    .release = binder_release,
};

static struct workqueue_struct *binder_deferred_workqueue;

// 初始化函数
static int __init binder_init(void)
{
    int ret;

    // 创建了一个内核工作队列对象workqueue, 用于执行可以延期执行的工作任务
    binder_deferred_workqueue = create_singlethread_workqueue(&quot;binder&quot;);
    if (!binder_deferred_workqueue)
        return -ENOMEM;

    // 创建调试目录 /sys/kernel/debug/binder
    binder_debugfs_dir_entry_root = debugfs_create_dir(&quot;binder&quot;, NULL);
    if (binder_debugfs_dir_entry_root)
        binder_debugfs_dir_entry_proc = debugfs_create_dir(&quot;proc&quot;,
                         binder_debugfs_dir_entry_root);
    // 注册字符设备
    ret = misc_register(&amp;binder_miscdev);
    // 创建调试文件
    if (binder_debugfs_dir_entry_root) {
        debugfs_create_file(&quot;state&quot;,
                    S_IRUGO,
                    binder_debugfs_dir_entry_root,
                    NULL,
                    &amp;binder_state_fops);
                    ...
    }
    return ret;
}

// 调用初始化函数加载内核, 基本等价于不支持动态编译驱动模块的module_init, 如果需要把Binder改成动态的内核模块, 直接把这个device_initcall改成module_init, 同时添加驱动卸载接口函数 module_exit即可
device_initcall(binder_init);
</code></pre><p>可见在系统装载设备的时候, 就加载了Binder设备模块, 并绑定了设备操作对应的函数.  </p>
<p>好奇心重一点的读者可能会去自行发掘Linux设备模块怎么编写. Linux驱动程序的一个主要功能就是向用户空间的程序提供操作接口, 这个接口是标准的, Binder包含的接口有:  </p>
<pre><code>-Proc接口（/proc/binder）
    . /proc/binder/state
    . /proc/binder/stats
    . /proc/binder/transactions
    . /proc/binder/transaction_log
    . /proc/binder/failed_transaction_log
    . /proc/binder/proc/

-设备接口（/dev/binder）
    . binder_open
    . binder_release
    . binder_flush
    . binder_mmap
    . binder_poll
    . binder_ioctl
</code></pre></li>
<li><p>Binder启动<br> 在<code>frameworks/base/cmds/servicemanager/binder.c</code>中定义了binder设备打开的函数<code>binder_open</code>:  </p>
<pre><code>struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    if (!bs) {
        errno = ENOMEM;
        return 0;
    }

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (bs-&gt;fd &lt; 0) {
        fprintf(stderr,&quot;binder: cannot open device (%s)\n&quot;,
                strerror(errno));
        goto fail_open;
    }

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);
    if (bs-&gt;mapped == MAP_FAILED) {
        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,
                strerror(errno));
        goto fail_map;
    }

        /* TODO: check version */

    return bs;

fail_map:
    close(bs-&gt;fd);
fail_open:
    free(bs);
    return 0;
}
</code></pre><p> 这个函数作用是把设备映射到内存, 在Binder设备驱动中还有一个同名函数负责打开Binder设备和设置引用计数, 如下:  </p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    // 初始化, 分配 binder_proc 数据结构内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
        return -ENOMEM;

    // 增加当前线程/进程的引用计数并赋值给proc-&gt;tsk
    get_task_struct(current);
    proc-&gt;tsk = current;
    // 初始化binder_proc队列和默认优先级
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    init_waitqueue_head(&amp;proc-&gt;wait);
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    // 增加 BINDER_STAT_PROC对象计数
    binder_stats_created(BINDER_STAT_PROC);
    // 添加进程节点proc_node到binder_procs的全局列表中, 任何进程都可以访问其他进程的binder_proc对象
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 保存进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 驱动文件的private_data指向proc
    filp-&gt;private_data = proc;

    binder_unlock(__func__);
    ...

    return 0;
}
</code></pre></li>
<li><p>Binder释放<br> 同样是在<code>frameworks/base/cmds/servicemanager/binder.c</code>文件中定义了设备释放函数<code>binder_release</code>:  </p>
<pre><code>void binder_release(struct binder_state *bs, void *ptr)
{
    uint32_t cmd[2];
    cmd[0] = BC_RELEASE;
    cmd[1] = (uint32_t) ptr;
    binder_write(bs, cmd, sizeof(cmd));
}
</code></pre><p> 可见只是发送了一个释放命令给Binder驱动, 那么可以肯定驱动中也有一个释放函数, 正好前面看到过设备操作的接口中有一个就是<code>binder_release</code>与这里的函数同名, 不会是巧合. <code>kernel/goldfish/drivers/staging/android/binder.c</code>中相关代码片段如下:  </p>
<pre><code>static int binder_release(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc = filp-&gt;private_data;
    debugfs_remove(proc-&gt;debugfs_entry);
    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);

    return 0;
}
</code></pre><p> 好嘛, 释放操作给了<code>binder_defer_work</code>, 这又是嘛? 其实前面我们在初始化的时候就有内容涉及到它: 在<code>create_singlethread_workqueue</code>的时候创建了一个叫做<code>binder_deferred_workqueue</code>的队列, 该队列用来调度执行<code>binder_deferred_work</code>, 而两者发生联系就是在函数<code>binder_defer_work</code>中, <code>queue_work</code>使用了他们作为函数参数. 前面说过这个队列里都是可以延期执行的任务, 而<code>binder_deferred_work</code>有三种类型, 即枚举变量<code>binder_deferred_state</code>中定义的<code>PUT_FILES</code> <code>FLUSH</code> <code>RELEASE</code>.<br> 显然, 释放的具体操作就要看<code>queue_work</code>函数了, 很可惜我查的资料里没有详述这个函数做了啥. 它的定义在<code>kernel/goldfish/kernel/workqueue.c</code>中, 粗略看了下, 理解不一定对, 感觉它跟Handler类似, 在入队work的时候获取执行work的worker, 而由别的过程控制出队和实际执行, 只不过它所处的层次更靠近硬件.  </p>
</li>
<li>Binder数据关联<br> 前面说过, 传输对象中<code>binder</code>和<code>handle</code>其实指向的是同一个对象, 现在来解释一下为什么. 在一次调用中, 对于客户端进程来说, handle存储的索引是一个远端对象的句柄, 当数据经由Binder驱动传达到服务端的时候, 服务端就会把这个索引解释为本地对象的地址, 对于第三方来说, 客户端的handle和服务端的binder都是指向了服务端的那个Binder对象. 对于Binder来说, 对象的索引和映射是通过<code>binder_node</code>和<code>binder_ref</code>两个核心数据结构来完成的, 两个定义都可以在文件<code>kernel/goldfish/drivers/staging/android/binder.c</code>中看到. 对于Binder本地对象, 对象的Binder地址保存在<code>binder_node-&gt;ptr</code>里, 对于远程对象, 索引保存在<code>binder_ref-&gt;desc</code>里, 每一个<code>binder_node</code>都有一个<code>binder_ref</code>与之对应, 他们通过<code>ptr</code>和<code>desc</code>来做映射. 前面说过进程间传递的Binder对象实际上是<code>flat_binder_object</code>这个数据结构, 每个<code>flat_binder_object</code>在内核都有一个唯一的<code>binder_node</code>对象与之对应, 这个对象挂载在<code>binder_proc</code>的一棵二叉树上, 而每一个<code>binder_node</code>又有唯一一个<code>binder_ref</code>对象与之对应. 可以这么理解, <code>binder_ref-&gt;desc</code> <code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code> <code>flat_binder_object-&gt;handle</code>四者都指向同一个对象, 其中<code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code>的<code>binder_node</code>位于服务端. <code>binder_ref</code>按照node和desc两种方式映射到<code>binder_proc</code>对象上, 因此可以通过<code>binder_node</code>或者<code>desc</code>查找到<code>binder_ref</code>或<code>binder_node</code>. 对于一个<code>flat_binder_object</code>对象来说, 它的<code>binder, cookie, handle</code>都指向的同一个<code>binder_node</code>对象.<br> Binder驱动中, flush操作在关闭一个设备文件描述符拷贝时被调用, 这里不做探究. 另一个操作mmap(memory map)负责把设备内存映射到用户进程地址空间中, 用户进程可以像操作内存一样操作设备. 一般的设备驱动, 设备内存是设备本身具有的, 或者在驱动初始化时由<code>vmalloc</code>或<code>kmalloc</code>等内核函数分配好, Binder不同于此, 它的设备内存是由mmap操作来分配的, 分配方法是现在内核虚拟映射表上获取一段可用区域, 再分配物理页, 并把物理页映射到获取的虚拟地址区域. 每个进程/线程只能做一次mmap操作, 其后重复操作都会返回错误. mmap分配内存的代码见文件<code>kernel/goldfish/drivers/staging/android/binder.c#binder_mmap</code>片段, 过程大致是先做检查调用合法性等准备工作, 然后申请虚拟内存空间, 再使用<code>binder_update_page_range</code>分配物理空间(实际是分配了1个页的物理内存用来存储指针buffer, 1个物理页是4K, 1个指针是4字节, 所以1页最多可存1K个指针, 每个指针对应一个物理页, 所以对应最多4M物理空间, 这是一次mmap最多可以分配的物理内存量, 这里不管实际申请了多大的物理内存, 内核总是提供1页物理内存用来放buffer指针, 即每次都允许申请最多的物理页), 在该函数中利用Linux系统中内存相关函数完成具体分配任务, 完成后由<code>binder_buffer</code>负责管理该内存区域, <code>binder_buffer</code>放到了<code>proc-&gt;buffers</code>链表中, 今后就可以通过这段内存区域完成设备数据读写了. 更形象的插图见<a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a>相关章节, 本段主要参考该文和内核代码完成.  </li>
<li>Binder接口及命令<br> Binder能得以正确工作, 首先要依赖于一致的Binder协议. 其中Binder类型在前文<code>external/kernel-headers/original/linux/binder.h</code>中提到过, 一共3大类5小类. 其实该文件中还定义了Binder驱动支持的命令格式和数据定义, 分为客户端的<code>BinderDriverCommandProtocol</code>和服务端的<code>BinderDriverReturnProtocol</code>, 两个都是枚举类型, 很可惜以我现在的C水平, 看不懂枚举成员<code>BC_TRANSACTION = _IOW_BAD(&#39;c&#39;, 0, struct binder_transaction_data)</code>的写法是什么意思, 大概猜测是第一个参数是访问模式, 第二个参数是指令, 第三个参数是数据指针. 客户端命令(BC)中第一个参数都是’c’, 宏<code>_IOR_BAD</code>根据资料应该是指向的<code>ioctl</code>的, 也就是说这里的参数传给了<code>ioctl</code>. 服务端返回(BR)的第一个参数都是’r’, 表示read. 两个数据结构定义了Binder客户端和服务端可以执行的全部命令. 既然有协议, 自然就有版本, 细心的读者可能发现, 前文<code>binder_open</code>函数里面就隐藏了一段注释, 说明以后会有<code>check version</code>的步骤.  </li>
</ol>
<p>本节主要参考:  </p>
<ul>
<li><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a>  </li>
<li><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>  </li>
<li><a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">BinderIPC原理</a>  </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>给两个主要结论和一个图(图不是我画的, 但来源记不得了), 方便大家按图索骥.  </p>
<p><img src="/images/blogs/binder_native_stack.png" alt="binder native stack">  </p>
<ol>
<li><p>Binder的实现从上到下涉及到Java层(Application层)/JNI层/Native层(Runtime层)/Linux kernel层, 可以说涉及到了Android的整个架构, 说是它的核心之一一点不过分. 系统服务的注册/获取/使用/Intent传递都通过Binder驱动, 对它的深入理解将会起到提纲挈领的效果.  </p>
</li>
<li><p>上层的<code>android.os.Binder</code>是对Binder的一层封装, 一般不直接使用. 如果定义服务, 使用系统提供的<code>Service</code>接口即可(它完成了一个默认的<code>android.os.Binder</code>实现), 如果是自定义跨进程服务, 使用<code>AIDL</code>将是更快的方式, 它本质是一个对Binder操作进行封装的工具. 如果不嫌麻烦, 直接使用<code>android.os.Binder</code>来定义客户端和服务端也是完全可行的.  </p>
</li>
</ol>
<p>说实话这篇文章写得有点吃力, 一个是时间拉太长, 记忆跟不上, 另一个是这个内容本身比较难用平白的语言讲清楚. 感谢大家阅读, 难免理解有误或以讹传讹, 欢迎大家指正.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Binder机制
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Handler全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/06/%5BAndroid%E6%95%99%E7%A8%8B%5DHandler%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/06/[Android教程]Handler全解/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-02-07T09:11:13.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回顾"><a href="#某渣的凭印象回顾" class="headerlink" title="某渣的凭印象回顾"></a>某渣的凭印象回顾</h2><p>Handler是线程间消息通讯的一种方式. 使用它需要Message, MessageQueue, Looper几个东西的配合. 每个线程都有一个Looper对象, 它里面有个方法loop()会去轮询消息队列MessageQueue中的Message, 对每个Message去调用它目标线程的Handler来处理这个消息. 轮询的操作会调用native方法使用epoll机制来获得Message. 最常见的使用场景就是子线程中做计算, 将结果返回给主线程, 此时子线程就需要使用主线程的Handler来发送消息到主线程的消息队列, 再由主线程的Handler来处理消息.  </p>
<h2 id="为什么需要Handler"><a href="#为什么需要Handler" class="headerlink" title="为什么需要Handler"></a>为什么需要Handler</h2><p>参考: <a href="http://blog.csdn.net/innost/article/details/47317823" target="_blank" rel="external">&lt;&lt;深入理解Android 卷III&gt;&gt;第二章 深入理解Java Binder和MessageQueue</a>  </p>
<ol>
<li>线程之间通信的需要. 在Android中, 系统做了一个隐含假设, 即用来显示UI的线程应该只用来显示UI包括更新UI, 不应该做过多的事情, 而同时, 其他线程应该做他们该做的事情, 而不应该更新UI. 因此, 如果试图在一个非UI线程中更新UI组件, 会抛出异常(如果你知道某个叫<code>runOnMainThread</code>的黑科技你当然可以用), 而如果在UI线程中做了过多的事情, 会导致UI线程阻塞(ANR). 这就造成一个问题, 我们经常需要根据业务逻辑或计算结果去更新UI, 这怎么办呢? 就需要其他线程和UI线程之间进行通信, 传递需要的信息.  </li>
<li>事件异步处理的需要. 有时候我们会遇到这样一种情况: 我们希望过一段时间去做某件事, 但又不希望线程阻塞去等待这个时间, 这时候我们当然可以通过新建一个线程在一段时间后与主线程通信的方式来实现这个目的, 但这样显然有点小题大做了, 有没有更好的机制能够异步处理消息而不需要额外创建子线程呢? 答案就是Handler.  </li>
</ol>
<h2 id="Handler的设计思想-工作原理"><a href="#Handler的设计思想-工作原理" class="headerlink" title="Handler的设计思想/工作原理"></a>Handler的设计思想/工作原理</h2><p>Handler不是一个孤立的类, 它与MessageQueue, Message, Looper几个类共同构成了线程间消息传递的系统.<br>其中, Message是具体消息的载体, Handler负责生产和消耗Message, MessageQueue负责把Message构成一个有序的队列, Looper负责从MessageQueue中取出Message对象. Handler, MessageQueue, Looper三个类构成了一个Message流动的循环.  </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>对于一般的线程, 我们只需要定义一个MyHandler类, 让它继承Handler类, 实现我们自己的<code>handleMessage</code>方法, 处理对应类型的Message就可以了, 大多数情况下甚至我们只需要在UI线程代码中定义一个继承Handler的匿名内部类并实现其<code>handleMessage</code>方法足矣. <code>Handler</code>中的<code>sendMessage</code>系列方法可以完成将Message入队的操作. <code>obtainMessage</code>可以获取一个空闲的Message对象. 如果你只满足于<code>Handler</code>的基本使用方法, 那知道这些就足够用了.(完)  </p>
<p><div name="empty"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><br>很好, 看来你跟我一样不只想要知道怎么用, 还想知道为什么这样用. Android那帮大牛将Handler设计得很巧妙, 机制简单易懂, 封装得非常好, 以至于我们一般情况下只需要知道上面那段话就行了. 不一般的情况呢, 我们从问题入手, 随便抛出几个问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?  </li>
</ol>
<p>以上都是很容易想到的问题, 而要彻底搞懂它们, 免不了要打开Android源码.<br>我说的”实践”, 就是看Android源码对Handler的实现.<br>现在, 先让我们抛开那些问题, 从Handler开始, 一步一步看清这背后的真相. 打开Handler源码查看它的定义, 发现它有以下几个成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final MessageQueue mQueue;</div><div class="line">final Looper mLooper;</div><div class="line">final Callback mCallback;</div><div class="line">final boolean mAsynchronous;</div></pre></td></tr></table></figure></p>
<p>一看到这几个我们心里就有点猜测了, 前两个不就是前面提到的消息队列和消息循环器吗! 不过后两个是什么鬼? 别急, 先看Handler构造方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来上面几个成员变量都在构造函数中初始化了. 其中<code>mLooper</code>使用的是<code>Looper.myLooper()</code>的返回结果, 而<code>mQueue</code>直接使用了<code>mLooper.mQueue</code>. 可以猜测MessageQueue实例是由Looper来创建的, Handler持有这个Looper实例的引用, Handler和mLooper共同持有MessageQueue实例的引用. 构造方法传进来的两个参数用来初始化其余两个成员变量.<br>来看<code>Looper.myLooper()</code>, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从Looper的静态成员变量<code>sThreadLocal</code>中获取的Looper实例. 那么有<code>get()</code>应该也有<code>set()</code>, 可我们好像没有看到哪里有调用<code>set()</code>? 以及<code>ThreadLocal</code>这个类是个什么东西?<br>关于ThreadLocal可以看<a href="http://blog.csdn.net/singwhatiwanna/article/details/48350919" target="_blank" rel="external">任玉刚的这篇博客</a>了解, 简单来说就是一个可以存储和访问仅对当前线程可见的数据的类.<br>我们直奔<code>set()</code>方法去看看, 发现了下面这段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来是<code>prepare()</code>这个方法直接新建了一个<code>Looper</code>对象放在里面, 这样在之后取的话就能取到这个Looper了. 可是我们好像也没有调用<code>prepare()</code>? 事实上, 如果我们没有调用<code>prepare()</code>的话, 就会抛出上面Handler构造方法里面mLooper为空时的那个异常啦! 所以<code>prepare()</code>这个方法是必调的, 而且一定是在Handler所在线程中先于Handler实例创建.<br>再来看Looper的构造函数, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">       mQueue = new MessageQueue(quitAllowed);</div><div class="line">       mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>明白了, 在Looper构造函数中, 新建了MessageQueue, 并且持有了当前线程的引用.<br>细心的同学可能会问了: “我在Activity里面没有调用prepare方法, 可我用Handler也用得很6啊!”. 这位同学, 我很欣赏你的细心. <code>Activity</code>就是我们的UI线程了, 为什么我们在UI线程里面可以不调用<code>prepare</code>呢? 答案是, 系统已经帮我们调用过了. 有看过Activity启动源码的同学可能会知道, 在Android中Activity的启动是通过<code>ActivityManagerService</code>做到的, 其中在<code>ActivityThread</code>里面, 会调用<code>Looper.prepareMainLooper()</code>为主线程准备一个Looper, 并且调用<code>Looper.loop()</code>开始轮询. 其中<code>prepareMainLooper()</code>大体上就是调用了<code>prepare</code>方法, 只不过加了个锁来保证主线程Looper对象的唯一性.  </p>
<p>到此, 我们已经知道了Looper对象从哪里来, 到哪里去, 我们也知道调用<code>loop()</code>方法之后Looper就开始轮询MessageQueue了, 但我们还不知道Looper对象的<code>loop()</code>方法在干嘛. 看看源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line"></div><div class="line">    //获得一个 Looper 对象</div><div class="line">    final Looper me = myLooper();</div><div class="line"></div><div class="line">    // 拿到 looper 对应的 mQueue 对象</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    //死循环监听(如果没有消息变化，他不会工作的) 不断轮询 queue 中的 Message</div><div class="line">    for (;;) &#123;</div><div class="line">        // 通过 queue 的 next 方法拿到一个 Message</div><div class="line">        Message msg = queue.next(); // 可能会阻塞, 具体是调用native方法时可能阻塞</div><div class="line">        //空判断</div><div class="line">        if (msg == null)return;</div><div class="line">        //消息分发   </div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        //回收操作  </div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取到MessageQueue实例, 死循环读取下一个消息, 再调用<code>Message.target.dispatchMessage(msg)</code>将消息分发到<code>target</code>中去处理.<br>诶? 这个target是啥? 显然, 它是在Message中设置好的东西, 让我们看看Handler的<code>sendMessage</code>源码. Handler中有许多发送消息的方法, 但追本溯源会到达下面这个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Handler target;</div><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    // 使用默认的 handler 构造方法时，mAsynchronous 为 false。</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">       msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有意思, 发送消息时首先检验MessageQueue是不是为空, 不空的话就执行入队操作, 在入队的方法中让Message对象持有当前Handler的引用, 然后调用MessageQueue的入队方法. 有兴趣的同学可以再深入看一下MessageQueue的入队方法是怎么实现的, 里面会涉及到更加具体的所使用的数据结构, 由于它不影响咱们理解Handler机制, 这里就暂不展开了.<br>再看<code>dispatchMessage</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一切都连起来了. 在这里, 如果你的Message对象中, callback为空, 那么就会执行到Handler成员<code>mCallback</code>的<code>handleMessage</code>方法或Handler的<code>handleMessage</code>方法, 否则会直接执行<code>handleCallback</code>. 我们去看一下<code>handleCallback</code>和<code>Message</code>的源码, 就会发现<code>callback</code>是一个<code>Runnable</code>对象, 而<code>handleCallback</code>中直接调用了这个对象的<code>run()</code>方法. 所以我们可以得出结论, 如果设置了Message的callback, 那handleMessage就不起作用了, 转而用callback来处理这个消息. 按Android那帮天才的习惯, Handler里应该有对应的API来供开发者调用. 果不其然, 可以找到<code>post</code>等相关方法.  </p>
<p>至此, Message是怎么进入和退出MessageQueue, 又是怎么被Handler处理的, 这个过程我们都已经清楚了. 尝试回答一下本节开头时提出的问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: 看源码.  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: 看源码.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 看源码, 看我上面的分析.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 看我上面的分析.  </li>
</ol>
<p>如果你有种上当的感觉的话, 你的感觉是对的, 我上面这一段分析基本上没有回答这几个问题. 其实看到这里你应该也有所感觉, 重要的是这种设计的思路, 厘清了思路之后, 具体能做什么/怎么做, 就是可以自己把控的了.  </p>
<p>然鹅, 这里我正正经经回答一下上面那些问题, 免得搜索那些问题进来的同学们失望:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: <code>android.os.Message</code>是一个<code>final</code>类, 它实现了<code>Parcelable</code>接口, 通过一个<code>int</code>型的<code>flags</code>来标记状态, 状态包括<code>FLAG_IN_USE</code>, <code>FLAG_ASYNCHRONOUS</code>, <code>FLAGS_TO_CLEAR_ON_COPY_FROM</code>三种. <code>Message</code>内主要的成员变量有:  <ul>
<li>公共成员变量what/arg1/arg2/obj/replyTo/sendingUid, 前三个是整型, 后三个分别是<code>Object</code>, <code>Message</code>, <code>int</code>型. 我们可以通过<code>obtain</code>方法的重载来设置前四个变量.  </li>
<li>包可见成员变量flags(及其三个标志状态)/when/data/target/callback/next, 类型分别是<code>int</code>, <code>long</code>, <code>Bundle</code>, <code>Handler</code>, <code>Runnable</code>, <code>Message</code>. 其中除了next以外都有对应的设置方法.  </li>
<li>私有变量sPoolSync/sPool/sPoolSize/MAX_POOL_SIZE/gCheckRecycle, 类型分别是<code>Object</code>, <code>Message</code>, <code>int</code>, <code>final int</code>, <code>boolean</code>. 前四个的作用是在消息池非空时同步地从消息池(单链表, sPool指向表头)中摘出表头节点作为<code>obtain()</code>的返回值(所有重载的<code>obtain</code>方法都通过该无参方法获得Message实例), 或者在<code>recycleUnchecked()</code>时将当前消息插入到表头. 表的最大容量是50. 最后一个是在API 21加入的标记, 标志是否要检查回收状态. 使用中的<code>Message</code>被回收时如果该标志为<code>true</code>则抛出<code>IllegalStateException</code>异常.<br>总结来说, Message实现了一个最大容量为50的单链表结构, 其类静态变量<code>sPool</code>指向表头, 其实现了<code>Parcelable</code>接口, 可以承载包括<code>Bundle</code>在内的复杂数据.  </li>
</ul>
</li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: <code>android.os.Handler</code>是一个专用于继承实现的类, 它的<code>handleMessage</code>是一个空方法. 它内部定义了一个<code>Callback</code>接口, 含有<code>boolean handleMessage(Message msg)</code>方法, 成员变量<code>mCallback</code>就是这个接口类型, 在Handler的<code>dispatchMessage</code>中拥有第二优先权, 仅次于Message本身的Callback. 继承Handler类容易造成内存泄漏, 这一点需要格外注意. <code>obtainMessage</code>代理了<code>Message</code>类的静态多态方法<code>obtain</code>. 由于<code>Message</code>没有显式定义构造函数, 直接<code>new Message</code>显然是可以的, <code>obtain()</code>就是通过这个构造函数初始化消息池. 但这样做无法循环利用消息池, 造成内存浪费, 因此<code>obtainMessage</code>是更好地获取Message实例的方法. <code>sendMessage</code>做了什么见上文的相关段落,  由于这个是系统调用机制, 效率上我没有想到更好的实现方式. <code>sendMessageAtTime</code>等方法允许子类重写. 除了<code>handleMessage</code>和<code>sendMessage</code>, Handler中还定义了一些实用的方法和类, 例如可以获取到Looper, 可以传入Runnable获取Message实例, 可以dump信息, 实现了一个阻塞的<code>final class BlockingRunnable</code>用于内部的<code>runWithScissors</code>. 实现了一个<code>final class MessengerImpl</code>用于在发送Message之前设置Message的Uid为Binder的Uid, 并让包可见成员变量mMessenger持有该类的实例, 但实际上这个成员变量未在别处引用.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 上文已经分析了<code>MessageQueue</code>是什么时候创建的(创建Looper时). 在每个消息进入队列(<code>enqueueMessage</code>)的时候, 会根据该消息的时间when将它插入到消息队列链表(这个链表不同于消息池的链表)中, 因此消息队列中的消息都是按照消息时间排序好的, 在取出Message时, 如果没有到该消息的执行时间, 会<code>nativePollOnce</code>等待到执行时间. <code>MessageQueue</code>从代码看没有容量限制.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 上文已经分析了Looper是什么时候创建的(<code>Looper.prepare()</code>调用时). 它怎么处理Message为空的情况? 答案是退出循环, 因为Message为空只可能出现在MessageQueue已经没有内容时. 它怎么分发到正确的Handler对象, 这可以看前文分析, 答案是在<code>sendMessage</code>调用<code>enqueueMessage</code>时, Handler默认会把每个<code>Message</code>的<code>target</code>都设置为它自己, 循环处理时直接调用<code>msg.target.dispatchMessage(msg)</code>来分发. 循环时Looper会保证始终在同一线程上处理消息队列, 如果线程发生变化, Looper会记录一个<code>Log.wtf()</code>日志(注释说是<code>What a Terrible Failure</code>, 但我怎么看都觉得是<code>What The Fxxk</code>). Looper每处理完一个Message都会调用它的<code>recycleUnchecked()</code>让它进入消息池.  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Handler异步消息机制
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】NDK&amp;JNI入门</title>
    <link href="https://hjhjw1991.github.io/android/2016/12/21/%5BAndroid%E6%95%99%E7%A8%8B%5Dndk&amp;jni/"/>
    <id>https://hjhjw1991.github.io/android/2016/12/21/[Android教程]ndk&amp;jni/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2017-02-07T09:48:01.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NDK-amp-JNI"><a href="#NDK-amp-JNI" class="headerlink" title="NDK &amp; JNI"></a>NDK &amp; JNI</h2><p>NDK和JNI的关系是: Java通过JNI的方式调用由NDK编译生成的本地库.<br>JNI是独立于NDK的一个技术, NDK是帮助编译c/cpp文件的一个工具.  </p>
<p>在JNI的c文件中如果用到了<code>#include &lt;utils/Log.h&gt;</code>  </p>
<p>然后用NDK 编译的时候会提示<code>error: utils/Log.h: No such file or directory</code><br>这个是因为这个头文件在Android源码的<code>frameworks/base/include</code>中，不在SDK或NDK中  </p>
<p>如果想要使用NDK的LOG功能的话  </p>
<p>1—–修改Android.mk文件配置,添加如下语句，这是载入liblog库，其中$(SYSROOT)是NDK中platform的路径  </p>
<p><code>LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog</code>  </p>
<p>2—–在.c文件中修改为如下语句。这是引入NDK中的日志头文件，位置在<code>$(SYSROOT)/usr/include</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include&lt;android/log.h&gt;</div></pre></td></tr></table></figure></p>
<p>3—–使用方法。其中这后面的方法在头文件中可以找到定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define LOG_TAG &quot;debug&quot;</div><div class="line">#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, fmt, ##args)</div></pre></td></tr></table></figure>
<p>4—-打印语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOGI(&quot;test log!!!!&quot;);</div><div class="line"></div><div class="line">LOGI(&quot;the string is: %s \n&quot;,buff);</div></pre></td></tr></table></figure></p>
<p>5—-错误输出到日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOGI(strerror(errno))</div></pre></td></tr></table></figure></p>
<p>如果想要开启NDK的Debug功能，需要按照下列步骤操作。  </p>
<h2 id="JNI中的映射关系"><a href="#JNI中的映射关系" class="headerlink" title="JNI中的映射关系"></a>JNI中的映射关系</h2><p>基本类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">Java 类型</th>
<th>jni本地类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td>jboolean</td>
<td style="text-align:left">C/C++ unsigned 8 bits</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td>jbyte</td>
<td style="text-align:left">C/C++ signed 8 bits</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td>jchar</td>
<td style="text-align:left">C/C++ unsigned 16 bits</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>jshort</td>
<td style="text-align:left">C/C++ signed 16 bits</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td>jint</td>
<td style="text-align:left">C/C++ signed 32 bits</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td>jlong</td>
<td style="text-align:left">C/C++ signed 64 bits</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>jfloat</td>
<td style="text-align:left">C/C++  32位浮点型</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>jdouble</td>
<td style="text-align:left">C/C++  64位浮点型</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td>void</td>
<td style="text-align:left">N/A</td>
</tr>
</tbody>
</table>
<p>命名规则就是java基本类型加j前缀.  </p>
<p>引用类型和数组类型也差不多:<br>引用类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>jobject</td>
<td>任何Java对象，或者没有对应java类型的对象</td>
</tr>
<tr>
<td>Class</td>
<td>jclass</td>
<td>class对象</td>
</tr>
<tr>
<td>String</td>
<td>jstring</td>
<td>字符串对象</td>
</tr>
</tbody>
</table>
<p>数组类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>布尔型数组 unsigned</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>比特型数组 signed</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>字符型数组 unsigned</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>短整型数组 signed</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>整型数组 signed</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>长整型数组 signed</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>浮点型数组</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>双浮点型数组</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>任何对象的数组</td>
</tr>
</tbody>
</table>
<p>数组类型多个Array后缀.  </p>
<p>JNI函数签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello(JNIEnv *, jclass, jstring);</div></pre></td></tr></table></figure></p>
<p>第一个参数: <code>JNIEnv*</code> 是定义任意 <code>native</code> 函数的第一个参数(包括调用 JNI 的 <code>RegisterNatives</code> 函数注册的函数), 指向 JVM 函数表的指针, 函数表中的每一个入口指向一个 JNI 函数, 每个函数用于访问 JVM 中特定的数据结构.<br>第二个参数: 调用 Java 中 native 方法的实例或 Class 对象, 如果这个 <code>native</code> 方法是实例方法, 则该参数是 <code>jobject</code>,如果是静态方法，则是 <code>jclass</code>.<br>第三个参数: Java 对应 JNI 中的数据类型, Java 中 String 类型对应 JNI 的 jstring 类型. (前面已介绍 JAVA 与 JNI 数据类型的映射关系)  </p>
<p>函数签名也可以手动动态映射, 通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static JNINativeMethod gMethods[] = &#123;</div><div class="line">// 这里写映射关系数组</div><div class="line">// &#123;&quot;native函数名&quot;, &quot;参数列表&quot;, 对应的JNI方法&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中参数列表有个缩写映射规则,要用缩写表示Java类型.<br>当参数为引用类型的时候，参数类型的标示的格式为”L完整路径名;”,前面L后面分号.如果是数组就是在成员类型前面加[,有多少层加多少个[.例如String对应的就是<code>(Ljava/lang/String;)</code>  </p>
<table>
<thead>
<tr>
<th>类型标志</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>Ljava/lang/String</td>
<td>String</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>[I</td>
<td>Int[]</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>[Ljava/lang/object</td>
<td>Object[]</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
</tbody>
</table>
<p><code>javap</code>可以生成函数签名. <code>javap -s -p xxx</code>. 参数含义参见help.  </p>
<p>JNI层就相当于是在用C写东西了, 所以语法也是C的语法.<br>对于基本类型, 可以直接强制类型转换成对应长度的C/C++类型(事实上, 查看jni基本类型的定义可以发现, 它们都是c基本类型的<code>typedef</code>).<br>对于数组类型, 需要使用JNIEnv提供的方法, 简单类型的数组会把其指针直接暴露给本地代码. 一系列GetXXXArrayElements函数可以把Java数组作为参数, 返回一个指向对应的本地类型的数组指针.  </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>Java 数组类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetBooleanArrayElements</td>
<td>jbooleanArray</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteArrayElements</td>
<td>jbyteArray</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharArrayElements</td>
<td>jcharArray</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortArrayElements</td>
<td>jshortArray</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntArrayElements</td>
<td>jintArray</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongArrayElements</td>
<td>jlongArray</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatArrayElements</td>
<td>jfloatArray</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleArrayElements</td>
<td>jdoubleArray</td>
<td>jdouble</td>
</tr>
</tbody>
</table>
<p>使用完之后要调用对应的ReleaseXXXArrayElements, 参数是对应的数组和前面GetXXXArrayElements返回的指针. 这个函数会把你对本地数组做的变化复制到Java数组中, 然后释放相关资源.<br>JNIEnv还有一些别的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GetArrayLength</div><div class="line"></div><div class="line">NewXXXArray</div><div class="line"></div><div class="line">GetXXXArrayElements</div><div class="line"></div><div class="line">ReleaseXXXArrayElements</div><div class="line"></div><div class="line">GetXXXArrayRegion</div><div class="line"></div><div class="line">SetXXXArrayRegion</div></pre></td></tr></table></figure></p>
<p>这些方法都是Env预定义的方法, 帮助你在C/C++的Array和Java的Array之间转换.  </p>
<h2 id="NDK用到的C-C-运行库"><a href="#NDK用到的C-C-运行库" class="headerlink" title="NDK用到的C/C++运行库"></a>NDK用到的C/C++运行库</h2><p>你在Android.mk文件中可以指定LOCAL_CPP_EXTENSION来告诉编译器, 把什么后缀的文件当做C++源文件来编译. 对于C和C++会采用不同的编译器. 不过，编译过后的C++程序想要执行，还必须要有C++运行环境（C++ Runtime）的支持。默认情况下，Android NDK会使用一个非常迷你的C++运行环境，称做“libstdc++”。这个运行环境几乎什么都没有，不支持异常和RTTI（RunTime Type Information，即运行时类型识别），甚至连C++标准库也没有。  </p>
<p><style><br>img {<br>  width: 600px;<br>  height: 400px;<br>  margin: auto;<br>}<br></style><br><img src="/images/blogs/c++runtimelibrary.jpg" alt="c++ runtime library">  </p>
<p><code>.a</code>是静态库, <code>.so</code>是动态库, 也叫共享库. 通过<code>Application.mk</code>的<code>APP_STL</code>可以配置想要用什么运行库, 需要注意的是Android源码目录的ndk子目录下面, 就有各个目标平台和架构的运行库, Android 8(Android 2.2)之前, 是只有默认的那个库.  </p>
<p>最后，还有一点需要注意，如果你的JNI功能都是包含在一个模块（也就是程序中只有一个.so文件）中的话，可以考虑用静态库C++运行时库的形式。而如果你的程序中包含了多个模块，请尽量使用动态C++运行时库。  </p>
<p>在用动态C++运行时库的时候，相应的动态库.so文件（默认的C++运行时库除外）会随你的程序一起发布出去，位于apk文件中的lib目录下。  </p>
<p>如果你的目标Android系统是4.3之前，那么你必须要在加载所有你自己的模块之前，显式的加载C++动态运行时库。  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲NDK &amp; JNI基础
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu 16.04 64bit上下载、编译和安装Android源码</title>
    <link href="https://hjhjw1991.github.io/android/2016/08/01/build-android/"/>
    <id>https://hjhjw1991.github.io/android/2016/08/01/build-android/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:05:29.367Z</updated>
    
    <content type="html"><![CDATA[<p>自诩为Android开发者已经很久了然而却没有自己编译安装过Android源码，怎么也说不过去。今天就编译安装，记录下来过程中需要注意的情况。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>如果在中国大陆建议有一个能访问google的网络环境，官方的指导是最可靠最完善的。</li>
<li>Android编译不能在Windows系统上进行，所以你需要一个基于Linux的系统，Mac OS和Ubuntu都行，虚拟机的话需要16GB的swap空间。官方使用的是Ubuntu 14.04，我建议你也用这个版本（我用的是16.04）。  </li>
<li>Android基于Java，最新的基于Java 8， 所以你需要安装JDK 1.8。</li>
<li>Android源码使用Git进行管理，并在外封装了一层叫Repo，所以你还要安装Git客户端。  </li>
<li>安装依赖包。</li>
</ul>
<pre><code>sudo apt-get install git-core gnupg flex bison gperf build-essential \  
zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \  
lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \  
libgl1-mesa-dev libxml2-utils xsltproc unzip  
</code></pre><h2 id="下载Android源码"><a href="#下载Android源码" class="headerlink" title="下载Android源码"></a>下载Android源码</h2><p>Android源码每个分支可能都要占用约22GB空间，官方建议磁盘空间至少25GB.我建议先选定一个版本的源码，进行下载。  </p>
<ol>
<li><p>下载repo工具。执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget https://storage.googleapis.com/git-repo-downloads/repo</div><div class="line">chmod a+x repo</div><div class="line">mkdir ~/bin</div><div class="line">cp repo ~/bin/</div><div class="line">PATH=~/bin:$PATH</div></pre></td></tr></table></figure>
</li>
<li><p>下载源码。执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdidr AndroidSource</div><div class="line">cd AndroidSource</div><div class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.1_r1 # -b是选择分支，不加则下载最新master分支。可以在网页上查看有哪些分支标签</div><div class="line">repo sync</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后就开始下载源码了，视网络状况这个过程可能会很长（我下了两天），中间还可能遇到下载错误，这时候重新执行<code>repo sync</code>就行了。</p>
<h2 id="编译Android源码"><a href="#编译Android源码" class="headerlink" title="编译Android源码"></a>编译Android源码</h2><p>Android用到的Makefile系统来编译源码，所以必要的相关知识会非常有帮助。以后涉及到单独模块的编译需要自己写makefile。<br>在源码根目录下执行<code>make</code>就可以编译源码。默认编译目标是<code>droid</code>，默认输出目录在<code>/out</code>，执行<code>source build/envsetup.sh</code>可以获得更多的编译命令，其中<code>lunch</code>和<code>mmm</code>两个命令特别有用。<br>编译目标中，默认是<code>droid</code>前面已经说过，另外还有几个常用的编译目标，<code>clean</code>清理out目录，<code>sdk</code>编译SDK，<code>clean-sdk</code>清理SDK编译产物，<code>all</code>编译所有内容，<code>snod</code>从已经编译出的包快速重建系统镜像，<code>dump-products</code>显示所有产品的编译配置信息，<code>bootimage</code> <code>recoveryiamge</code> <code>userdataimage</code> <code>cacheimage</code>生成对应的<code>.img</code>。关于Build系统可以看<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#icomments" target="_blank" rel="external">这里</a>  </p>
<p>可能会遇到问题：<br>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">You are using version x.x of make  </div><div class="line">Android can only be built by versions 3.81 and 3.82</div></pre></td></tr></table></figure></p>
<p>make的版本过低或过高，过低升级即可，过高则需要安装指定版本。我先remove了make 4.1，然后在<a href="http://packages.ubuntu.com/trusty/make" target="_blank" rel="external">http://packages.ubuntu.com/trusty/make</a> 下载安装了make 3.81。<br>2.<br><code>You are attempting to build with an unsupported JDK.</code><br>很明显OpenJDK不被支持，需要Oracle JDK。另外，JDK版本也一定要与你要编译的版本相匹配，不能过高，否则提示<code>You are attempting to build with the incorrect version
of java.</code>。比如我编译4.4源码用的JDK 1.8，就提示java版本错误，非常郁闷。<br>安装好JDK 6 之后终于开始了编译步骤。<br>官网上说AOSP光靠它的源码还不能工作，需要一些跟硬件有关的library，在<a href="http://source.android.com/source/requirements.html#binaries" target="_blank" rel="external">http://source.android.com/source/requirements.html#binaries</a> 最下面。另外提供了官方的Nexus系列的驱动在<a href="https://developers.google.com/android/nexus/blobs-preview" target="_blank" rel="external">https://developers.google.com/android/nexus/blobs-preview</a> 和 <a href="https://developers.google.com/android/nexus/drivers" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers</a> 。安装步骤见<a href="http://source.android.com/source/building.html，" target="_blank" rel="external">http://source.android.com/source/building.html，</a> 每个binary是一个自解压文件，在Android源码根目录运行这个自解压文件，然后相应的binary和makefile就会被安装在vendor目录。<br>编译没有错误的话就会生成Android系统了，根据主机配置不同这个过程可能比较久（我开始编译的时候没有注意，用了4小时…），可以在make的时候指定并发job数量来加速编译过程：<code>make -j8</code>。<br>编译完成的out目录下应该有<code>system.img</code> <code>ramdisk.img</code> <code>userdata.img</code>三个文件。<br>接下来进行安装。  </p>
<h2 id="安装编译好的Android到模拟器"><a href="#安装编译好的Android到模拟器" class="headerlink" title="安装编译好的Android到模拟器"></a>安装编译好的Android到模拟器</h2><p>安装有两种选择：刷到设备里和安装到模拟器。其中刷到设备里需要设备和编译目标相匹配，否则可能无法成功启动，且需要用到<code>fastboot</code>工具，见<a href="http://source.android.com/source/running.html#flashing-a-device" target="_blank" rel="external">flashing a device</a>。这里我们选择安装到模拟器。<br>在build完成后把<code>/out/host/linux-x86/bin/emulator</code>添加到环境变量，这里需要执行的是这个<code>emulator</code>。加选项<code>-kernel &lt;PATH&gt;</code> <code>-sysdir &lt;PATH&gt;</code> <code>-system &lt;PATH&gt;</code> <code>-data &lt;PATH&gt;</code> <code>-ramdisk &lt;PATH&gt;</code>可以指定要用到的image文件。模拟器运行需要四个文件，分别是Linux Kernel镜像kernel-qemu（在<code>$ANDROID_SOURCE/prebuilts/qemu-kernel</code>中）、Android镜像<code>system.img</code>、<code>userdata.img</code>和<code>ramdisk.img</code>。<br>需要注意的是即使是模拟器平台也要跟编译目标相匹配，模拟器要求的内核最低版本必须低于所使用的内核版本。<br>今后就可以自己修改某个模块的代码，然后编译这个模块并重新打包到<code>system.img</code>来查看效果啦！<br>甚至可以自己定义新的模块，添加到系统镜像中。Android自带的App存放在<code>out/target/product/generic/system/app</code>，可执行文件存放在<code>out/target/product/generic/system/bin</code>，动态链接库存放在<code>out/target/product/generic/system/lib</code>，硬件抽象层（HAL）接口文件存放在<code>out/target/product/generic/system/lib/hw</code>。  </p>
<p>可能会遇到的问题：</p>
<ol>
<li><p><code>emulator: ERROR: Missing initial data partition file: (null)</code> or 必须要指定一个虚拟机才能运行<code>emulator</code>。遇到这个可能是因为你使用了不合适的<code>emulator</code>，看一看<code>which emulator</code>，是不是使用了Sdk中的<code>emulator</code>。应该使用<code>/out/host/linux-x86/bin/emulator</code>。  </p>
</li>
<li><p><code>qemu: could not load initrd &#39;ramdisk.img&#39;</code>。遇到这个问题可能是模拟器没有读取到正确的<code>ramdisk.img</code>文件。按网上说法使用绝对路径即可，也可以将<code>ramdisk</code>的父目录<code>out/target/product/generic</code>添加到环境变量。  </p>
</li>
<li><p>启动模拟器后一直黑屏。可能是使用了错误的kernel，换一个kernel试试。我换成<code>arm/kernel-qemu-armv7</code>就可以启动了。  </p>
</li>
<li><p><code>emulator: WARNING: system partition size adjusted to match image file (550 MB &gt; 200 MB)</code>。这个WARNING好像不影响模拟器运行，但强迫症还是想弄懂为什么要WARNING，于是查了查。原来是所需空间不足，添加参数<code>emulator -partition-size 1024 # 大于所需尺寸即可</code>。  </p>
</li>
<li><p><code>make: *** No rule to make target &#39;out/target/product/generic/root/file_contexts&#39;, needed by &#39;snod&#39;.  Stop.</code> 或者启动模拟器后一直停留在开机画面，打开monitor发现logcat一直在循环刷错误(最近几天连续出现这个问题，虽然还没搞清楚原因，不过暂时在<code>emulator</code>之前执行<code>lunch full-eng</code>是有效果的，另外如果不执行<code>lunch full-eng</code>的话启动的模拟器默认连皮肤都没有，完全没有按键)。可能是模块编译目标与system.img目标不匹配。在编译模块前<code>lunch full-eng# lunch的combo要和编译系统时lunch的combo一致</code>，在<code>make snod</code>前<code>lunch full-eng</code>，我是这么做的。  </p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文参考了以下文章，排列不分先后：<br><a href="http://blog.csdn.net/luoshengyang/article/details/18928789" target="_blank" rel="external">Android编译系统环境初始化过程分析</a><br><a href="http://blog.csdn.net/innost/article/details/47660387" target="_blank" rel="external">深入理解Android输入系统</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="external">那两年练就的Android内功修养-老罗</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/6559955" target="_blank" rel="external">在Ubuntu上下载、编译和安装Android最新源代码-老罗</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/6566662" target="_blank" rel="external">如何单独编译Android源代码中的模块-老罗</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/#icomments" target="_blank" rel="external">理解Android Build系统</a>  </p>
]]></content>
    
    <summary type="html">
    
      从空系统开始如何下载和编译Android系统源码
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android源码结构</title>
    <link href="https://hjhjw1991.github.io/android/2016/08/01/Android%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>https://hjhjw1991.github.io/android/2016/08/01/Android源码结构/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:18:02.211Z</updated>
    
    <content type="html"><![CDATA[<p>相信各位对于Android系统架构图的三层或四层结构已经了然于胸，迫不及待想要膜拜一下源码，但是可能好不容易下载好源码打开一看就懵逼了：这目录是啥？这又是啥？其实Android源码目录名字已经很浅显地表明了目录的内容和功能，但对于初学者特别是背景知识不够宽宏的初学者而言还是有点摸不着头脑。本文简单介绍Android系统源码目录结构，好让读者对Android源码有一个整体的概念，这样当深入到某一模块研究的时候能够同时心中有全局。<br>首先要了解一个理念：Android源码以什么样的原则来分包和存放。从目录看，Android很自然地将源码分为Core、External和Package三种，其中Core是核心工程，在根目录的各个文件夹中，External是扩展工程，使用其他开源项目扩展的功能，在external文件夹中，Package是提供应用程序和服务的，在package中，平时用到的各种系统应用就是在这里面写就的。<br>以下按层次结构依次标注目录功能（源码版本：android_4.4.1-r1）：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── abi                application binary interface，应用程序二进制接口</div><div class="line">├── art                art虚拟机</div><div class="line">├── bionic             [Build] bionic C运行时支持：libc、libm、libdl、动态linker</div><div class="line">├── bootable           启动引导相关代码</div><div class="line">├── build              [Build]存放系统编译规则及generic等基础开发配置</div><div class="line">├── cts                Android兼容性测试套件标准</div><div class="line">├── dalvik             dalvik虚拟机</div><div class="line">├── developers         开发者相关</div><div class="line">├── development        应用程序开发相关</div><div class="line">├── device             设备相关代码（厂商定制代码就放在这里）</div><div class="line">├── docs               开源相关文档</div><div class="line">├── external           Android使用的开源模块</div><div class="line">├── frameworks         核心框架，包含Java source和C++ source</div><div class="line">├── hardware           主要是硬件适配层HAL</div><div class="line">├── libcore            核心库相关</div><div class="line">├── libnativehelper    动态库，是实现JNI的基础</div><div class="line">├── Makefile           [Build]make的入口点，其内容只有一句话即include build/core/main.mk</div><div class="line">├── ndk                ndk相关代码</div><div class="line">├── out                编译输出文件夹，默认编译完成后的结果输出到此目录</div><div class="line">├── packages           应用程序包</div><div class="line">├── pdk                Plug Development Kit，本地开发套件</div><div class="line">├── prebuilts          预编译的资源（例如Linux-Kernel，分为x86和arm架构）</div><div class="line">├── sdk                sdk及模拟器相关代码</div><div class="line">├── system             文件系统和应用组件，c/c++代码</div><div class="line">├── tools              工具文件夹，如gradle等</div></pre></td></tr></table></figure>
<p>作为开发者根据自己的需要可以对不同部分加以关注，我们主要关注packages和frameworks目录。我们打开frameworks，发现它的目录结构如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div></pre></td><td class="code"><pre><div class="line">./frameworks/</div><div class="line">├── av                      Audio/Video</div><div class="line">│   ├── camera              相机</div><div class="line">│   ├── CleanSpec.mk        本模块的清除步骤，下同</div><div class="line">│   ├── cmds                command目录，包含录屏和stagefright两个子目录</div><div class="line">│   ├── drm                 digital rights management相关</div><div class="line">│   ├── include             头文件</div><div class="line">│   ├── libvideoeditor      视频编辑器库</div><div class="line">│   ├── media               媒体</div><div class="line">│   ├── MODULE_LICENSE_APACHE2    开源协议</div><div class="line">│   ├── NOTICE              声明</div><div class="line">│   ├── services            服务，包含audioflinger，camera和medialog</div><div class="line">│   └── tools               工具</div><div class="line">├── base                    基础定义，我们主要关注这个文件夹下的内容</div><div class="line">│   ├── Android.mk          本模块的编译步骤，下同</div><div class="line">│   ├── api                 当前api定义，如果api有变化这个文件会相应更新</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── cmds</div><div class="line">│   ├── core                framework核心代码，实现了几乎所有底层功能，包含java和c/c++代码，android.xx.xx/com.android.internal.xx/com.android.server的NetworkObserver代码位于这里</div><div class="line">│   ├── data                数据文件夹，包含字体、键盘定义、声音、视频等数据</div><div class="line">│   ├── docs                文档</div><div class="line">│   ├── drm                 版权保护</div><div class="line">│   ├── graphics            图形</div><div class="line">│   ├── include             ...</div><div class="line">│   ├── keystore</div><div class="line">│   ├── libs</div><div class="line">│   ├── location</div><div class="line">│   ├── media</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── native</div><div class="line">│   ├── nfc-extras</div><div class="line">│   ├── NOTICE</div><div class="line">│   ├── obex</div><div class="line">│   ├── opengl</div><div class="line">│   ├── packages</div><div class="line">│   ├── policy</div><div class="line">│   ├── preloaded-classes</div><div class="line">│   ├── samples</div><div class="line">│   ├── sax</div><div class="line">│   ├── services            com.android.server的大部分代码位于这里</div><div class="line">│   ├── telephony</div><div class="line">│   ├── test-runner</div><div class="line">│   ├── tests</div><div class="line">│   ├── tools</div><div class="line">│   └── wifi</div><div class="line">├── compile                 下面的内容不再一一介绍，用到的时候再去详解也不迟</div><div class="line">│   ├── libbcc</div><div class="line">│   ├── mclinker</div><div class="line">│   └── slang</div><div class="line">├── ex</div><div class="line">│   ├── camera2</div><div class="line">│   ├── carousel</div><div class="line">│   ├── chips</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── common</div><div class="line">│   ├── photoviewer</div><div class="line">│   ├── variablespeed</div><div class="line">│   └── widget</div><div class="line">├── mff</div><div class="line">├── ml</div><div class="line">│   ├── Android.mk</div><div class="line">│   └── bordeaux</div><div class="line">├── native</div><div class="line">│   ├── build</div><div class="line">│   ├── cmds</div><div class="line">│   ├── data</div><div class="line">│   ├── include</div><div class="line">│   ├── libs</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── NOTICE</div><div class="line">│   ├── opengl</div><div class="line">│   └── services</div><div class="line">├── opt</div><div class="line">│   ├── calendar</div><div class="line">│   ├── carddav</div><div class="line">│   ├── colorpicker</div><div class="line">│   ├── datetimepicker</div><div class="line">│   ├── emoji</div><div class="line">│   ├── inputmethodcommon</div><div class="line">│   ├── mailcommon</div><div class="line">│   ├── mms</div><div class="line">│   ├── net</div><div class="line">│   ├── photoviewer</div><div class="line">│   ├── telephony</div><div class="line">│   ├── timezonepicker</div><div class="line">│   └── vcard</div><div class="line">├── rs</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── cpp</div><div class="line">│   ├── cpu_ref</div><div class="line">│   ├── driver</div><div class="line">│   ├── java</div><div class="line">│   ├── rsAdapter.cpp</div><div class="line">│   ├── rsAdapter.h</div><div class="line">│   ├── rsAllocation.cpp</div><div class="line">│   ├── rsAllocation.h</div><div class="line">│   ├── rsAnimation.cpp</div><div class="line">│   ├── rsAnimation.h</div><div class="line">│   ├── rsCompatibilityLib.cpp</div><div class="line">│   ├── rsCompatibilityLib.h</div><div class="line">│   ├── rsComponent.cpp</div><div class="line">│   ├── rsComponent.h</div><div class="line">│   ├── rsContext.cpp</div><div class="line">│   ├── rsContext.h</div><div class="line">│   ├── rsCppUtils.cpp</div><div class="line">│   ├── rsCppUtils.h</div><div class="line">│   ├── rsDebugHelper.h</div><div class="line">│   ├── rsDefines.h</div><div class="line">│   ├── rsDevice.cpp</div><div class="line">│   ├── rsDevice.h</div><div class="line">│   ├── rsElement.cpp</div><div class="line">│   ├── rsElement.h</div><div class="line">│   ├── rsEnv.h</div><div class="line">│   ├── rsFBOCache.cpp</div><div class="line">│   ├── rsFBOCache.h</div><div class="line">│   ├── rsFifo.h</div><div class="line">│   ├── rsFifoSocket.cpp</div><div class="line">│   ├── rsFifoSocket.h</div><div class="line">│   ├── rsFileA3D.cpp</div><div class="line">│   ├── rsFileA3D.h</div><div class="line">│   ├── rsFont.cpp</div><div class="line">│   ├── rsFont.h</div><div class="line">│   ├── rsgApi.cpp.rsg</div><div class="line">│   ├── rsgApiFuncDecl.h.rsg</div><div class="line">│   ├── rsgApiReplay.cpp.rsg</div><div class="line">│   ├── rsgApiStructs.h.rsg</div><div class="line">│   ├── rsg_generator.c</div><div class="line">│   ├── rsGrallocConsumer.cpp</div><div class="line">│   ├── rsGrallocConsumer.h</div><div class="line">│   ├── rsg.spec</div><div class="line">│   ├── rs.h</div><div class="line">│   ├── rs_hal.h</div><div class="line">│   ├── rsMatrix2x2.cpp</div><div class="line">│   ├── rsMatrix2x2.h</div><div class="line">│   ├── rsMatrix3x3.cpp</div><div class="line">│   ├── rsMatrix3x3.h</div><div class="line">│   ├── rsMatrix4x4.cpp</div><div class="line">│   ├── rsMatrix4x4.h</div><div class="line">│   ├── rsMesh.cpp</div><div class="line">│   ├── rsMesh.h</div><div class="line">│   ├── rsMutex.cpp</div><div class="line">│   ├── rsMutex.h</div><div class="line">│   ├── rs_native.spec</div><div class="line">│   ├── rsObjectBase.cpp</div><div class="line">│   ├── rsObjectBase.h</div><div class="line">│   ├── rsPath.cpp</div><div class="line">│   ├── rsPath.h</div><div class="line">│   ├── rsProgramBase.h</div><div class="line">│   ├── rsProgram.cpp</div><div class="line">│   ├── rsProgramFragment.cpp</div><div class="line">│   ├── rsProgramFragment.h</div><div class="line">│   ├── rsProgram.h</div><div class="line">│   ├── rsProgramRaster.cpp</div><div class="line">│   ├── rsProgramRaster.h</div><div class="line">│   ├── rsProgramStore.cpp</div><div class="line">│   ├── rsProgramStore.h</div><div class="line">│   ├── rsProgramVertex.cpp</div><div class="line">│   ├── rsProgramVertex.h</div><div class="line">│   ├── rsRuntime.h</div><div class="line">│   ├── rsSampler.cpp</div><div class="line">│   ├── rsSampler.h</div><div class="line">│   ├── rsScriptC.cpp</div><div class="line">│   ├── rsScriptC.h</div><div class="line">│   ├── rsScriptC_Lib.cpp</div><div class="line">│   ├── rsScriptC_LibGL.cpp</div><div class="line">│   ├── rsScript.cpp</div><div class="line">│   ├── rsScriptGroup.cpp</div><div class="line">│   ├── rsScriptGroup.h</div><div class="line">│   ├── rsScript.h</div><div class="line">│   ├── rsScriptIntrinsic.cpp</div><div class="line">│   ├── rsScriptIntrinsic.h</div><div class="line">│   ├── rsSignal.cpp</div><div class="line">│   ├── rsSignal.h</div><div class="line">│   ├── rs.spec</div><div class="line">│   ├── rsStream.cpp</div><div class="line">│   ├── rsStream.h</div><div class="line">│   ├── rsThreadIO.cpp</div><div class="line">│   ├── rsThreadIO.h</div><div class="line">│   ├── rsType.cpp</div><div class="line">│   ├── rsType.h</div><div class="line">│   ├── rsUtils.h</div><div class="line">│   ├── scriptc</div><div class="line">│   ├── server</div><div class="line">│   ├── spec.h</div><div class="line">│   ├── spec.l</div><div class="line">│   └── tests</div><div class="line">├── support</div><div class="line">│   ├── build.gradle</div><div class="line">│   ├── CleanSpec.mk</div><div class="line">│   ├── local.properties</div><div class="line">│   ├── settings.gradle</div><div class="line">│   ├── tests</div><div class="line">│   ├── v13</div><div class="line">│   ├── v4</div><div class="line">│   ├── v7</div><div class="line">│   └── v8</div><div class="line">├── testing</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── androidtestlib</div><div class="line">│   ├── app-tests</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── uiautomator</div><div class="line">│   └── uiautomator_test_libraries</div><div class="line">├── uiautomator</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── api</div><div class="line">│   ├── apicheck_msg_current.txt</div><div class="line">│   ├── apicheck_msg_last.txt</div><div class="line">│   ├── BuildConstants.java.in</div><div class="line">│   ├── cmds</div><div class="line">│   ├── MODULE_LICENSE_APACHE2</div><div class="line">│   ├── samples</div><div class="line">│   ├── src</div><div class="line">│   ├── tests</div><div class="line">│   └── utils</div><div class="line">├── volley</div><div class="line">│   ├── AndroidManifest.xml</div><div class="line">│   ├── Android.mk</div><div class="line">│   ├── build.gradle</div><div class="line">│   ├── build.xml</div><div class="line">│   ├── custom_rules.xml</div><div class="line">│   ├── proguard.cfg</div><div class="line">│   ├── proguard-project.txt</div><div class="line">│   ├── project.properties</div><div class="line">│   ├── src</div><div class="line">│   └── tests</div><div class="line">├── webview</div><div class="line">│   ├── Android.mk</div><div class="line">│   └── chromium</div><div class="line">└── wilhelm</div><div class="line">    ├── doc</div><div class="line">    ├── include</div><div class="line">    ├── src</div><div class="line">    ├── tests</div><div class="line">    └── tools</div></pre></td></tr></table></figure>
<p>以上可以看出android系统的源码是非常庞大而复杂的，源码研究是一项艰苦而持久的任务。世上无难事, 只要肯放弃, 下面我们看点轻松的好理解的内容：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">./packages/</div><div class="line">├── apps                    应用程序库</div><div class="line">├── experimental            实验性的库（打印服务，bug汇报，通知，RPC等）</div><div class="line">├── inputmethods            输入法</div><div class="line">├── providers               四大组建之一Provider的系统自带模块</div><div class="line">├── screensavers            屏保</div><div class="line">├── services                系统服务（电话服务）</div><div class="line">└── wallpapers              壁纸</div></pre></td></tr></table></figure>
<p>有了以上的准备，阅读起源码来就心里有数，想要找什么代码也有了大致的搜索范围。<br>下面特别指出一些库的位置，有兴趣的可自行阅读：  </p>
<ul>
<li>系统C库 bionic</li>
<li>媒体库  frameworks/av/media</li>
<li>图形显示库  frameworks/native/services/surfaceflinger</li>
<li>网络引擎库  external/webp, external/webrtc</li>
<li>3D图形库  frameworks/native/opengl</li>
<li>SQLite  Java layer framworks/base/core/java/android/database, C++ layer external/sqlite</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲述Android源码中目录的含义, 方便各位按图索骥
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>从源码编译Android SDK</title>
    <link href="https://hjhjw1991.github.io/android/2016/08/01/build-android-sdk/"/>
    <id>https://hjhjw1991.github.io/android/2016/08/01/build-android-sdk/</id>
    <published>2016-07-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:04:30.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Build-Android-SDK"><a href="#Build-Android-SDK" class="headerlink" title="Build Android SDK"></a>Build Android SDK</h2><p>前面已经编译好了系统源码，解决了一些问题，本以为编译SDK会顺顺利利一气呵成，我还是太天真了。<br>上来就遇到<code>bluetooth-health</code>模块找不到。google之后知道这是官方预计删除但还没有删除bluetooth-health的Android.mk所致。解决方式是在<code>make sdk</code>之前先执行<code>lunch sdk-eng</code>。<br>然后遇到<code>tools/base</code>目录找不到，退出，这时候都编译很久了，这不坑爹吗！解决方法是找到<code>sdk/eclipse/scripts/create_all_symlinks.sh</code>把里面所有有关<code>tools/base</code>的命令都注释掉。哦，这个文件在错误提示中有。顺便看了下这个<code>tools/base</code>是干嘛用的，好像跟Gradle构建有关，反正是Eclipse的东西吧，注释就注释了吧，顺便把<code>tools/swt</code>也注释了。<br>再编译，漫长等待之后又遇到问题，<code>base:testutils</code>资源读不到。看了一下好像是测试相关的东西，好像是<code>easymock</code>依赖的东西，想了想果断也注释了。<br>再编译又遇到<code>sdk/build/tools.atree</code>提示<code>couldn&#39;t locate source file</code>，我连<code>Package SDK</code>都看到了，你给我出个这个错误，我都不知道该不该修，感觉SDK已经打包好了……想想还是修吧。看了下路径下确实没有错误中提到的Template文件夹，更别说文件了。摸进<code>tools.atree</code>把载入的地方看了下，看不出来有什么用，也注释掉了。<br>再编译，总算无错误完成。还不知道用起来有没有什么坑。  </p>
]]></content>
    
    <summary type="html">
    
      从源码开始如何编译SDK
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】AIDL入门</title>
    <link href="https://hjhjw1991.github.io/android/2016/04/01/%5BAndroid%E6%95%99%E7%A8%8B%5DAIDL%E5%85%A5%E9%97%A8/"/>
    <id>https://hjhjw1991.github.io/android/2016/04/01/[Android教程]AIDL入门/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2017-02-07T09:01:57.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>AIDL,android interface definition language  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>某天，我问谷歌爸爸，在Android中进程之间如何进行通讯？<br>我以为这很简单，我去找到要通讯的对象进程，然后建立连接，直接通讯。<br>然而谷歌爸爸说，不行，你这么做不安全，你崩掉了可能让人家也崩掉，锅不是这么甩的。<br>我问谷歌爸爸，那怎么办？<br>谷歌爸爸说，我给你工具，我给你通道，你给我间接地来，我保证你们互不影响。<br>工具在哪？叫什么名字？<br>工具在SDK里，有AIDL，Binder，Messenger，Service，需要什么用什么<br>怎么用？<br>自己看文档<br>看不懂怎么办？<br>边看边写<br>写了还不懂怎么办？<br>考虑改行吧<br>哦  </p>
</blockquote>
<p><img src="/images/blogs/aidl-basic.png" alt="aidl">  </p>
<h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><p>在Android中，进程之间是不能直接通讯的，他们也没有公共数据区域，但我们实实在在地需要进程间通讯，怎么办呢？Android为我们提供了四种进程间通讯的方式，正好对应四种基本应用程序组件：Activity, Content Provider, Broadcase, Service.  </p>
<ul>
<li>Activity可以跨进程调用其他的Activity  </li>
<li>Content Provider以形似DBC(database connector)的方式访问其他应用程序的数据  </li>
<li>Broadcast以发送广播的方式唤起对应进程  </li>
<li>Service以AIDL方式访问其他应用程序的数据  </li>
</ul>
<p>AIDL是一种IPC(Inter-Process Communication)方式，是C/S结构，如果接触过Java中RPC框架(例如hessian)，可以很快理解这种方式。  </p>
<p>AIDL可以算是一种DSL(Domain Specific Language)。Android中一个进程不允许直接访问另一个进程的内存数据，他们必须要将数据分解(parcel)成操作系统可以识别的最基本的数据类型之后进行传输。AIDL就负责这一块。  </p>
<p>与所有技术一样，只有在需要的时候才考虑AIDL，因为跨进程通讯是有代价的。那么什么时候用AIDL呢？  </p>
<ul>
<li>如果你<strong>只需要IPC</strong>，不需要多线程，你应该考虑Android提供的<strong>Messenger</strong>机制</li>
<li>如果你还要<strong>多线程</strong>，但是不需要多个应用程序并发进行IPC，你应该考虑Android提供的<strong>Binder</strong>机制(特化的AIDL)</li>
<li>如果你需要<strong>多个应用程序并发IPC</strong>，还需要多线程处理，你应该考虑使用AIDL</li>
</ul>
<p>那么，AIDL怎么写，怎么用？其实一句话懂的人就懂了：AIDL就是RPC中的服务接口。<br>如下图示(绿色虚线框为服务端代码，蓝色虚线框为客户端代码)：<br><img src="/images/blogs/aidl-call.png" alt="aidl-call"></p>
<p>假设我们的应用A需要自己能被别的应用调用和访问，不妨假设调用者为应用B。这样被访问的一方，就是提供服务的一方，即C/S中的S，而访问的一方就是客户端C。<br>我们需要在应用A中和应用B中都定义AIDL，并且在应用A中实现AIDL接口。<br>如果A不实现AIDL，是没法以AIDL的方式被调用的。这很好理解，你想跟别人对话，也要看别人愿不愿意跟你对话，对吧。  </p>
<p>Android SDK中aidl工具会将<code>.aidl</code>文件加入一些东西(比如自动加入抽象静态内部类<strong>Stub</strong>)，转换为同名的<code>.java</code>文件以供使用。<br>Eclipse和Android Studio都可以调用aidl工具将你定义的<code>.aidl</code>文件转换成<code>.java</code>。<br>AIDL文件中可以引用其他AIDL文件定义的接口，但不能直接引用<code>.java</code>中定义的接口。<br>但是！有能力的程序员完全可以自己写<code>.java</code>文件，完全手工完成接口定义。  </p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>继续沿用上一节末尾提到的应用A和应用B，这里为了简化场景，假设A是某个Application中负责远程计算的Service，运行在独立的进程中，B是这同一个Application中负责业务逻辑的模块，需要调用A来进行远程计算。  </p>
<p>在具体使用的时候，需要结合具体情境给出回调方式以获取服务实例，这里以使用Service为例，它自带onBind回调，我们只需要实现这个回调返回给客户端一个实例。  </p>
<p>当获得了服务端的实例之后就可以直接使用这个对象了。  </p>
<p>如下图所示：</p>
<p><img src="/images/blogs/aidl-instance.png" alt="aidl-instance"></p>
<p>由于画图技能没点，该图讲得不好，最好结合自己写的aidl和对应生成的<code>.java</code>文件来看。  </p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>aidl自动生成的文件中，使用抽象类Stub帮助你从外部定义服务端的实现，系统通过Stub和asInterface等存在于该生成文件中的预定义的方法来实现调用。  </p>
<p>打开<code>.java</code>文件，看看它的所有新增的方法和成员，可以帮助深入理解aidl的设计思想和运行原理。它里面有非常神奇的一些用法，例如抽象内部类Stub实现了存在于其外部的接口（它自身！），然后利用Proxy代理使用服务端实现。  </p>
<p>客户端获取到的实际上是远程服务的代理。而实际工作，是在服务端的代理中调用方法，以及代理前后调用onTransact进行序列化和反序列化。  </p>
<p>以下是示意图，写下去涉及的东西就多了，而且我也没有仔细阅读，这里就不误人子弟了，强烈建议大家自己去阅读感兴趣的部分。  </p>
<p><img src="/images/blogs/aidl-axiom.png" alt="aidl-axiom"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先上最重要的结论：<strong>在自带的<code>Binder</code>机制和<code>Messenger</code>机制无法解决你的多线程、多应用间通讯的场景时，使用aidl</strong>  </p>
<p>aidl提供了由系统支持的类RPC的进程间通讯方式。与直接通信的区别在于，系统可以借助aidl的定义来找到实现该aidl的组件，而且看起来好像并没有切换出当前进程环境(事实上是系统帮你把远程服务端运行起来了，aidl的执行都是在服务端，这就是为什么你在使用完毕的时候需要解绑服务端进程以避免内存泄漏)，使得客户端使用较为流畅无痕。隔离客户端和服务端，两者只需要面向接口编程，客户端可以完全不关心服务端的行为。  </p>
<p>aidl的缺点是传输的数据只支持Java内建基本数据类型(而且<code>short</code>除外)、<code>String</code>、<code>CharSequence</code>、只包含以上支持类型的List和Map，以及实现了<code>Parcelable</code>(一个类似于<code>Serializable</code>的接口，但强制要求实现类必须实现反序列化生成器<code>public static final Parcelable.Creator&lt;T&gt; CREATOR</code>和序列化生成器<code>writeToParcel</code>，其中<code>CREATOR</code>虽然是自己写的成员变量，但是名称和修饰词都不能更改)接口的类型。  </p>
<p>在<code>List</code>和<code>Map</code>这种用到泛型的情况下，需要指明List和Map是作为<code>in/out/inout</code>哪种方式使用的。网上某视频说在传输数据的时候会有一个打包和解包的过程，而这个过程代价非常大，说是出于节约资源的考虑才要求指明是作为输入还是作为输出。这或许也是考虑之一，但我更倾向于认为是出于保持里氏代换原则的考虑，毕竟这里如果你没声明的话会报编译错误，而一般来说影响性能的行为只会报警告，而不是错误。而且看到<code>in/out</code>这种词语，我很容易就联想到我的另一篇blog<a href="http://blog.hjhjw1991.net/blog/2016/02/25/Java%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/" target="_blank" rel="external">Java中的协变和逆变</a>  </p>
<p>另外，如果使用<code>Parcelable</code>接口传递自定义的数据对象，由于传递对象的时候序列化之后本质上是二进制流，那实现相应的序列化和反序列化的方法时，成员顺序必须完全一致，而且客户端和服务端都需要有完全一致的该自定义类文件。也是由于底层序列化会把<code>short</code>类型强行提升为<code>int</code>型，所以就直接不支持<code>short</code>类型的序列化 。  </p>
<p>对于aidl来说，它不直接识别java的源文件，所以需要给出自定义类的相应的aidl描述。当然aidl中对于实体的描述比接口描述要简单得多，只需要直接声明实体就行了。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Android开发艺术探索》<br><a href="http://blog.csdn.net/luoshengyang/article/details/6642463" target="_blank" rel="external">Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析</a><br><a href="http://blog.csdn.net/coding_glacier/article/details/7520199" target="_blank" rel="external">Android Binder机制</a><br><a href="http://blog.csdn.net/toyuexinshangwan/article/details/8640709" target="_blank" rel="external">Android跨进程通信的四种方式</a><br><a href="http://blog.csdn.net/thegameisfives/article/details/14000941" target="_blank" rel="external">Android ： 基本空间划分 ＆ IPC框架分析</a><br><a href="http://www.cnblogs.com/a284628487/p/3187320.html" target="_blank" rel="external">Android 内核–Binder架构分析</a><br><a href="http://blog.csdn.net/stonecao/article/details/6425019" target="_blank" rel="external">Android AIDL使用详解</a><br><a href="http://www.cnblogs.com/feike/archive/2013/01/08/2851833.html" target="_blank" rel="external">Binder与AIDL服务</a>  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲AIDL进程间通讯
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="教程" scheme="https://hjhjw1991.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="面试" scheme="https://hjhjw1991.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】3-Longest Substring Without Repeating Characters</title>
    <link href="https://hjhjw1991.github.io/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D3-Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>https://hjhjw1991.github.io/leetcode/2016/03/21/[Leetcode题解]3-Longest Substring Without Repeating Characters/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Hash Table,Two Pointers]  </p>
<p>在字符串中找到最长的无重复字符的子串，返回它的长度。<br>这个题的题设要求非常简单，只要出现重复的字符就不行，所以很容易可以想到Hash Table。<br>HashTable的做法是，从左到右扫描并存储见过的字符，如果遇到该字符已经见过了，则记录当前table容量并与当前最大长度求max，并从左到右删除到该字符为止的已经见过的字符。根据题意可以假设最大长度至少为1，且不会大于26.当原字符串为空时最大长度为0.  </p>
<p>从上面HashTable的解法描述中可以提取Two Pointers解法，即设置同向指针left和right，并初始化boolean数组用以表示是否参与当前最长子串计算，boolean数组下标是字符，其作用可以用HashMap代替。<br>初始left和right指向字符串起点，如果boolean数组right所指向的字符没有参与，则设置为参与并右移，否则计算right-left获得当前长度，并与当前最大长度求max，这之后left左移恢复状态，直到left所指向的字符与right所指向的字符一致。  </p>
<p>Two Pointers解法比HashTable解法好的一点是，用boolean数组代替了HashMap，这在运行性能上会好一些，但理论时间复杂度没变，都是O(N)。考虑到隐性假设字符为ASCII字符，范围可控，使用boolean数组做更合适。如果是任意字符，则应该使用HashTable。  </p>
]]></content>
    
    <summary type="html">
    
      最长无重复字符的子串
    
    </summary>
    
      <category term="leetcode" scheme="https://hjhjw1991.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】2-Add Two Sum</title>
    <link href="https://hjhjw1991.github.io/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D2-Add-Two-Numbers/"/>
    <id>https://hjhjw1991.github.io/leetcode/2016/03/21/[Leetcode题解]2-Add-Two-Numbers/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Math,Linked List]  </p>
<p>两个以链表形式存储的非负整数，每个节点是一个数字，并且按倒序表示，低位在前高位在后，要求返回同样形式表示的和。  </p>
<p>这是一个非常典型的数学基本操作和链表基本操作题，别看它难度不大，多做这样的题可以让你在以后做基本操作的时候得心应手，而且几乎不会出错。  </p>
<p>解题方式和注意点也非常典型。<br>加法器的基本实现思路是从低位到高位按位相加并保持进位。<br>正确性上需要注意对最高位进位的处理，链表上需要对空输入和剩余位处理。  </p>
<p>正文已经结束，我最后啰嗦几句，这个题简单在题设，我们自己可以试着把限制条件一一去掉以接近更真实的情况，例如正序表示，考虑负数，考虑小数。事实上Leetcode上就有变形题。<br>处理链表的时候，除了基本的指针操作以外，特别要注意头节点和尾节点处理，以及空链表和单节点链表这两种特殊情况。<br>指针操作也是一系列涉及指针的问题的基本操作，所以需要熟练掌握，除了单链表以外，还有双向链表，循环链表，十字链表，Dancing链表，数组模拟链表。在树结构处理的时候，经常就会用到多指针链表，例如Btree，Trie。  </p>
]]></content>
    
    <summary type="html">
    
      填坑, 两数求和
    
    </summary>
    
      <category term="leetcode" scheme="https://hjhjw1991.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>【Leetcode题解】1-Two Sum</title>
    <link href="https://hjhjw1991.github.io/leetcode/2016/03/21/%5BLeetcode%E9%A2%98%E8%A7%A3%5D1-Two-Sum/"/>
    <id>https://hjhjw1991.github.io/leetcode/2016/03/21/[Leetcode题解]1-Two-Sum/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列代码见<a href="https://github.com/hjhjw1991/leetcode" target="_blank" rel="external">我的Leetcode仓库</a></p>
</blockquote>
<p>tags: [Array,Hash Table]</p>
<p>填坑第一作，坑在<a href="http://blog.hjhjw1991.net/opinion/2015/10/15/开坑-Leetcode题解/" target="_blank" rel="external">这里</a><br>以后都假设大家都看过题目了，我会大略说一下题意，注意点，解法，但是就不搬运题目了。  </p>
<p>Two Sum是一个经典的数列问题，它可以直指高斯消元法。本题是一个最简单的情况，给定一个数列和一个目标，在数列中找到两个数，使得他们的和等于目标，返回这两个数的序号（从0开始计）。  </p>
<p>虽然是简单的题，但我说话比较啰嗦，就说一下我的想法。此题乃至一般题，首先想到判空，如果数列中不存在目标数怎么处理。因为是在Leetcode上可以无限试，特别是现在开了模拟coding run之后，所以完全可以构造一个用例看看Leetcode对于这种情况他是怎么处理的。然后考虑多个解的情况，怎么处理。我做的时候，他题目中有很强的假设，说有且仅有一个解。如果在面试的过程中遇到这种题，需要向面试官明确以上条件，不但可以简化实现，同时也可以反映出你的思路，一般来说面试时很少遇到这么简单的题，如果遇到那么你在别的方面的表现可能就是你取胜之处。  </p>
<p>考虑了不存在的情况后，考虑正常情况。可以有几种解法：  </p>
<h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>最容易想到暴力解法，固定一个元素，遍历其余元素，找到满足条件的就返回。这种解法最坏情况是N^2时间复杂度。但是这是帮助自己理清思路的好方法，特别是当问题较为复杂的时候，如果有暴力解法能写出来，再在这个基础上优化也是好的。在面试的时候，面试官对于这种优化行为也是较为欣赏。怎么说呢，暴力解法就像是及格线，需要熟练掌握，但是未必需要亮出来。  </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap总体上跟暴力解法相似，但是进行了优化。我们在暴力解法中，事实上有过很多重复计算，如果能把这些计算保存下来必然可以减少复杂度，HashMap就是在这种情况下想到的。  </p>
<p>解法是先预处理，将数组每个元素相对于目标的差值及其对应的下标存入Map，时间O(N)。<br>然后从头开始看每个元素是否都已经存在于Map中，这一步是N*O(1)。如果存在则说明找到解，可以返回序号。<br>需要注意的是判断两个下标是否指向同一个元素，如果是则跳过。<br>总体复杂度是O(2N)  </p>
<h2 id="Two-Pointer"><a href="#Two-Pointer" class="headerlink" title="Two Pointer"></a>Two Pointer</h2><p>有没有更巧妙的方式呢？有，就是Two Pointer。但是Two Pointer的解法依赖于有序数组，而题目中没有这个信息，所以这种算法在这个题不一定是最好的，但是这是一种非常巧妙的思想，可以在一遍扫描就完成求解。  </p>
<p>Two Pointer的基本思路，就是在有序数组上，左右设置指针，对向移动，当指针相遇则算法结束。无比经典的快速排序就是基于Two Pointer和Recursive的方式。  </p>
<p>对于求和，不妨先假设数组升序，那么设置left和right指针，对向移动，看left和right指向的数之和是否等于目标，如果是则返回，如果大了则right指针移动，小了则left指针移动，指针相遇说明无解。这个算法的正确性可以很简单地证明：假设相遇时存在解，那么可以假设至少其中一个指针曾停留在其中一个解上，不妨假设是left指针在较小的解上，此时如果right指针在另一个解左边，则和小于目标，不可能移动right，而right在另一个解的右边时则和大于目标，应当移动right，必然到达另一个解，与假设矛盾。  </p>
<p>至此思路清晰，将数组排序，然后使用双指针跑一遍即可得到解，总体时间复杂度是O(logN+N)，如果原本就有序则可更优。<br>需要注意的是排序前保留序号和数值对应关系，同时注意可能有重复元素，所以需要以链表方式存储。  </p>
<p>Two Pointer算法可以扩展到含有重复元素的数组，可以扩展到双向链表，可以修改为同向指针应用于链表有无环判断，可以扩展到Three Pointers，可以扩展到适用于N Sum问题，可以结合回溯法解最优化问题。可以说是非常简洁有用的算法。  </p>
]]></content>
    
    <summary type="html">
    
      填坑第一作，从简单的开始
    
    </summary>
    
      <category term="leetcode" scheme="https://hjhjw1991.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目</title>
    <link href="https://hjhjw1991.github.io/tips/2016/03/08/%E6%9C%AA%E8%83%BD%E5%90%8C%E6%AD%A5%E8%8B%B9%E6%9E%9C%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8D%E5%86%8D%E8%A2%AB%E6%8E%88%E6%9D%83%E4%BD%BF%E7%94%A8%E5%9C%A8%E6%AD%A4%E8%8B%B9%E6%9E%9C%E4%B8%8A%E8%B4%AD%E4%B9%B0%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>https://hjhjw1991.github.io/tips/2016/03/08/未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>以前用pp助手的时候遇到过这个问题，它破解下载app的方法是用某个别的AppleID购买和下载应用，这样子只能通过它这个软件来更新，无法通过官方App Store更新，而且很大几率出现安装失败、白图标等问题。  </p>
<p>最近手机迁移从旧手机的备份恢复到新手机（别人用过）上，结果又出现部分重叠的app购买ID没有恢复，AppleID不一致的情况，导致无法同步。  </p>
<p>解决方法是卸载这些应用，用一致的AppleID重新购买和下载，但是一直纠结于卸载应用会删除所有数据，搜索是否有保存数据更换ID的方法未果。  </p>
<p>下载itools查看手机应用可以看到每个应用的购买ID，把不一致的卸载再下载重装即可。  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://zhidao.baidu.com/link?url=hapvL1G--ej8gwHRI_e6Zh18d7urfv83UzZapeWqT34VEEkQN8vREF6cVPHjf2jBGG4NPTmBp5O9fxJMSrYBRSjzU-qjj8-SNE641ZxAheC" target="_blank" rel="external">未能同步苹果，因为这台电脑不再被授权使用在此苹果上购买的项目</a>  </p>
]]></content>
    
    <summary type="html">
    
      itunes同步的时候提示未能同步，点击商店-&gt;授权也没用，原因是手机上存在不同的AppleID所购买内容，需要都授权才行
    
    </summary>
    
      <category term="tips" scheme="https://hjhjw1991.github.io/categories/tips/"/>
    
    
      <category term="ios" scheme="https://hjhjw1991.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Git中使用cherry-pick跨分支应用commit</title>
    <link href="https://hjhjw1991.github.io/blog/2016/03/08/Git%E4%B8%AD%E4%BD%BF%E7%94%A8cherry-pick%E8%B7%A8%E5%88%86%E6%94%AF%E5%BA%94%E7%94%A8commit/"/>
    <id>https://hjhjw1991.github.io/blog/2016/03/08/Git中使用cherry-pick跨分支应用commit/</id>
    <published>2016-03-07T16:00:00.000Z</published>
    <updated>2016-08-30T08:03:26.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>git-cherry-pick - Apply the changes introduced by some existing commits    –from git-scm.com</p>
</blockquote>
<p>我们知道在git中对分支操作的命令有<code>merge</code>，<code>rebase</code>和<code>cherry-pick</code>，<code>merge</code>是两条分支直接合并，<code>rebase</code>是追溯到共同祖先之后逐个应用当前分支的commit到所选择的基分支上，可以通过<code>-i</code>选项进行对当前分支的交互式变基，用以修改提交历史，git中建议以<code>rebase</code>方式代替普通的<code>merge</code>。  </p>
<p><code>cherry-pick</code>在英语中是精挑细选的意思，功能也正如名字一样，是<strong>选择一些commit，将其应用到当前分支上</strong>。可以想见，其应用的主要场景是将已经提交的commit进行搬动</p>
<h2 id="场景1-引入某个commit新加入的功能但不改变分支历史"><a href="#场景1-引入某个commit新加入的功能但不改变分支历史" class="headerlink" title="场景1 引入某个commit新加入的功能但不改变分支历史"></a>场景1 引入某个commit新加入的功能但不改变分支历史</h2><p>直接使用<code>cherry-pick</code>即可，这样不会更改被引入分支的历史<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git cherry-pick &lt;commit hash&gt;</div></pre></td></tr></table></figure></p>
<p>默认情况下会创建一个新的提交，类似于<code>merge</code>。可通过选项关闭。  </p>
<h2 id="场景2-保持history清晰的情况下将某些提交完全移动到别的分支上"><a href="#场景2-保持history清晰的情况下将某些提交完全移动到别的分支上" class="headerlink" title="场景2 保持history清晰的情况下将某些提交完全移动到别的分支上"></a>场景2 保持history清晰的情况下将某些提交完全移动到别的分支上</h2><p>例如，我想把以下分支  </p>
<p><table width="200" border="1" cellspacing="1" cellpadding="1"></table></p>
<p><tbody><tr><td></td></tr></tbody></p>
<p><pre style=""><strong><br>A-B  master<br>   \<br>    C-D-E-F-G topic<br></strong></pre><br>中的D，F commit移动到master分支，而保持其他commit不变，就像这样  </p>
<p><table width="200" border="1" cellspacing="1" cellpadding="1"><tbody></tbody></table></p>
<p><tr><td></td></tr></p>
<p><pre style=""><strong><br>A-B-D-F  master<br>       \<br>        C-E-G topic</strong></pre></p>
<p><br>那么，思路是将D，F 用<code>cherry-pick</code>应用到<code>master</code>分支上，然后将<code>topic</code>分支对<code>master</code>分支变基。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout master  </div><div class="line">$ git cherry-pick D  </div><div class="line">$ git cherry-pick F  </div><div class="line">$ git checkout topic  </div><div class="line">$ git rebase master</div></pre></td></tr></table></figure>
<h2 id="EXAMPLES-from-official-guide"><a href="#EXAMPLES-from-official-guide" class="headerlink" title="EXAMPLES from official guide"></a>EXAMPLES from official guide</h2><p><code>git cherry-pick master</code><br>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.  </p>
<p><code>git cherry-pick ..master</code><br><code>git cherry-pick ^HEAD master</code><br>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.  </p>
<p><code>git cherry-pick maint next ^master</code><br><code>git cherry-pick maint master..next</code><br>Apply the changes introduced by all commits that are ancestors of <code>maint</code> or next, but not <code>master</code> or any of its ancestors. Note that the latter does not mean <code>maint</code> and everything between <code>master</code> and <code>next</code>; specifically, <code>maint</code> will not be used if it is included in <code>master</code>.  </p>
<p><code>git cherry-pick master~4 master~2</code><br>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.  </p>
<p><code>git cherry-pick -n master~1 next</code><br>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.  </p>
<p><code>git cherry-pick --ff ..next</code><br>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.  </p>
<p><code>git rev-list --reverse master -- README | git cherry-pick -n --stdin</code><br>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.  </p>
<p>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git cherry-pick topic^             (1)</div><div class="line">$ git diff                           (2)</div><div class="line">$ git reset --merge ORIG_HEAD        (3)</div><div class="line">$ git cherry-pick -Xpatience topic^  (4)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>apply the change that would be shown by <code>git show topic^</code>. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</p>
</li>
<li><p>summarize changes to be reconciled</p>
</li>
<li><p>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</p>
</li>
<li><p>try to apply the change introduced by <code>topic^</code> again, spending extra time to avoid mistakes based on incorrectly matching context lines.</p>
</li>
</ul>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="http://blog.csdn.net/duola_rain/article/details/43408733" target="_blank" rel="external">(转)Git cherry-pick 和 rebase 的混合用法</a><br><a href="http://git-scm.com/docs/git-cherry-pick/" target="_blank" rel="external">官方文档 - git-cherry-pick</a></p>
]]></content>
    
    <summary type="html">
    
      假设我有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们想增加v3.0中某几个commit的功能到v2.0中，这时候cherry-pick就派上用场了
    
    </summary>
    
      <category term="blog" scheme="https://hjhjw1991.github.io/categories/blog/"/>
    
    
      <category term="git" scheme="https://hjhjw1991.github.io/tags/git/"/>
    
  </entry>
  
</feed>
