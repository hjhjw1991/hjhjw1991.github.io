<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hjhjw1991&#39;s blog</title>
  <subtitle>Coder, Learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hjhjw1991.github.io/"/>
  <updated>2018-06-04T10:05:22.635Z</updated>
  <id>https://hjhjw1991.github.io/</id>
  
  <author>
    <name>hjhjw1991</name>
    <email>hjhjw1991@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EventBus--基于订阅模式的事件总线库</title>
    <link href="https://hjhjw1991.github.io/android/2018/06/04/EventBus--%E5%9F%BA%E4%BA%8E%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%BA%93/"/>
    <id>https://hjhjw1991.github.io/android/2018/06/04/EventBus--基于订阅模式的事件总线库/</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-04T10:05:22.635Z</updated>
    
    <content type="html"><![CDATA[<p>本篇讲大名鼎鼎的开源库EventBus.  </p>
<p>它的名字就解释了它的作用: 事件总线. 当事件发生时, 通过它发放到总线上的各个接收者.<br>事件总线(Event Bus)其实只是一种概念或者说一种模式, 而GreenRobot的EventBus项目实现了这种模式. 它不是唯一的实现者.<br>它的开发组织是greenrobot. 这个组织还有个项目挺有名的, 叫greendao.<br>本文基于EventBus 3.0代码.  </p>
<h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>在讲解EventBus之前, 我们重点要了解一下订阅者模式, 又叫做观察者模式. 从名字就可以看出来这种模式很适用于”当一件事情发生时, 所有关注这件事情的人都得到通知”这样的情景. 其实我觉得它就是批量地注册回调.<br>观察者模式在Java中的实现就是Observable接口, 而在EventBus中的实现就是Subscriber.  </p>
<h2 id="EventBus实现原理"><a href="#EventBus实现原理" class="headerlink" title="EventBus实现原理"></a>EventBus实现原理</h2><p>尽管原理非常简单, 接口方面也可以想象, 但具体怎么实现还是有讲究的.<br>我们从接口入手, 看EventBus如何实现事件总线的作用.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">1. 定义事件:</div><div class="line"></div><div class="line">public static class MessageEvent &#123; /* Additional fields if needed */ &#125;</div><div class="line">事件就是一个普通的Java类. 可以是静态的或非静态的.  </div><div class="line"></div><div class="line">2. 准备订阅者. 用注解的方式指定一个订阅者, 其唯一接受的参数是我们所关心的事件. 可以指定其[线程模式](http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/):</div><div class="line"></div><div class="line">@Subscribe(threadMode = ThreadMode.MAIN)  </div><div class="line">public void onMessageEvent(MessageEvent event) &#123;/* Do something */&#125;;</div><div class="line"></div><div class="line">然后可以注册和解除订阅者了. 例如在Android上, 注册和解除的方式如下:</div><div class="line"></div><div class="line"> @Override</div><div class="line"> public void onStart() &#123;</div><div class="line">     super.onStart();</div><div class="line">     EventBus.getDefault().register(this); // 将this这个订阅者注册到EventBus上</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> @Override</div><div class="line"> public void onStop() &#123;</div><div class="line">     super.onStop();</div><div class="line">     EventBus.getDefault().unregister(this); // 从EventBus上解除this这个订阅者</div><div class="line"> &#125;</div><div class="line"></div><div class="line">3. 发布事件:</div><div class="line"></div><div class="line"> EventBus.getDefault().post(new MessageEvent()); // 往EventBus上发布一个新的MessageEvent事件</div></pre></td></tr></table></figure>
<p>通过以上接口, 我们可以有一些大胆的猜测:  </p>
<ol>
<li>事件应当是以Map<eventtype, subscribers=""> 这样的方式存储的, 同时, 事件和订阅者应当是多对多的关系, 所以应当也有以Map<subscriber, eventtypes="">这样的数据结构存在;  </subscriber,></eventtype,></li>
<li>注册和解除订阅者时, 维护以上两个数据结构;  </li>
<li>发布事件时, 查询以上两个数据结构;  </li>
<li>可以添加其他的属性支持: 线程模式, 订阅者优先级, 事件模式.<br>有了以上认知, 其实我们自己也可以实现一套简单的EventBus框架.  </li>
</ol>
<p>下面就来看看EventBus是怎么实现各个特性的.  </p>
<h3 id="subscribe注解"><a href="#subscribe注解" class="headerlink" title="subscribe注解"></a>subscribe注解</h3><p>EventBus的核心就是Subscribe注解. 下面我们来看看它的实现(如果对注解不熟悉请留言告知, 人多的话我考虑出一篇讲Java注解的教程).  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME) // 作用阶段是Runtime</div><div class="line">@Target(&#123;ElementType.METHOD&#125;) // 作用对象是Method</div><div class="line">public @interface Subscribe &#123;</div><div class="line">    ThreadMode threadMode() default ThreadMode.POSTING; // 线程模式. 描述了在什么线程上执行订阅者的订阅方法.</div><div class="line"></div><div class="line">    /**</div><div class="line">     * If true, delivers the most recent sticky event (posted with</div><div class="line">     * &#123;@link EventBus#postSticky(Object)&#125;) to this subscriber (if event available).</div><div class="line">     */</div><div class="line">    boolean sticky() default false; // 是否sticky</div><div class="line"></div><div class="line">    /** Subscriber priority to influence the order of event delivery.</div><div class="line">     * Within the same delivery thread (&#123;@link ThreadMode&#125;), higher priority subscribers will receive events before</div><div class="line">     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of</div><div class="line">     * delivery among subscribers with different &#123;@link ThreadMode&#125;s! */</div><div class="line">    int priority() default 0; // 优先级. 仅影响同一线程中subscriber接收到事件的顺序.</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Each subscriber method has a thread mode, which determines in which thread the method is to be called by EventBus.</div><div class="line"> * EventBus takes care of threading independently from the posting thread.</div><div class="line"> * </div><div class="line"> * @see EventBus#register(Object)</div><div class="line"> * @author Markus</div><div class="line"> */</div><div class="line">public enum ThreadMode &#123;</div><div class="line">    /**</div><div class="line">     * Subscriber will be called directly in the same thread, which is posting the event. This is the default. Event delivery</div><div class="line">     * implies the least overhead because it avoids thread switching completely. Thus this is the recommended mode for</div><div class="line">     * simple tasks that are known to complete in a very short time without requiring the main thread. Event handlers</div><div class="line">     * using this mode must return quickly to avoid blocking the posting thread, which may be the main thread.</div><div class="line">     */</div><div class="line">    POSTING, // 直接抛在当前线程</div><div class="line"></div><div class="line">    /**</div><div class="line">     * On Android, subscriber will be called in Android&apos;s main thread (UI thread). If the posting thread is</div><div class="line">     * the main thread, subscriber methods will be called directly, blocking the posting thread. Otherwise the event</div><div class="line">     * is queued for delivery (non-blocking). Subscribers using this mode must return quickly to avoid blocking the main thread.</div><div class="line">     * If not on Android, behaves the same as &#123;@link #POSTING&#125;.</div><div class="line">     */</div><div class="line">    MAIN, // Android中直接抛给主线程, 非Android中行为与POSTING一样</div><div class="line"></div><div class="line">    /**</div><div class="line">     * On Android, subscriber will be called in Android&apos;s main thread (UI thread). Different from &#123;@link #MAIN&#125;,</div><div class="line">     * the event will always be queued for delivery. This ensures that the post call is non-blocking.</div><div class="line">     */</div><div class="line">    MAIN_ORDERED, // Android上直接抛给主线程, 总是放到队列里进行, 避免调用post方法的线程阻塞.</div><div class="line"></div><div class="line">    /**</div><div class="line">     * On Android, subscriber will be called in a background thread. If posting thread is not the main thread, subscriber methods</div><div class="line">     * will be called directly in the posting thread. If the posting thread is the main thread, EventBus uses a single</div><div class="line">     * background thread, that will deliver all its events sequentially. Subscribers using this mode should try to</div><div class="line">     * return quickly to avoid blocking the background thread. If not on Android, always uses a background thread.</div><div class="line">     */</div><div class="line">    BACKGROUND, // Android上抛给后台线程或者非UI线程的当前线程执行, 非Android总是在后台线程执行.</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Subscriber will be called in a separate thread. This is always independent from the posting thread and the</div><div class="line">     * main thread. Posting events never wait for subscriber methods using this mode. Subscriber methods should</div><div class="line">     * use this mode if their execution might take some time, e.g. for network access. Avoid triggering a large number</div><div class="line">     * of long running asynchronous subscriber methods at the same time to limit the number of concurrent threads. EventBus</div><div class="line">     * uses a thread pool to efficiently reuse threads from completed asynchronous subscriber notifications.</div><div class="line">     */</div><div class="line">    ASYNC // 总是在后台单独的线程执行.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码和注释已经很清楚了. 我们可以用注解, 让指定的方法, 在接收到指定的事件时, 在指定的线程上执行. 这个注解相当于标记了方法信息, 但具体怎么处理这个注解, 还得看其他入口.  </p>
<h3 id="EventBus主类"><a href="#EventBus主类" class="headerlink" title="EventBus主类"></a>EventBus主类</h3><p>EventBus类就是其中一个入口.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div></pre></td><td class="code"><pre><div class="line">具体代码见: https://github.com/greenrobot/EventBus/blob/master/EventBus/src/org/greenrobot/eventbus/EventBus.java</div><div class="line"></div><div class="line">/**</div><div class="line"> * 以下注释解释了EventBus的设计理念</div><div class="line"> * EventBus is a central publish/subscribe event system for Android. Events are posted (&#123;@link #post(Object)&#125;) to the</div><div class="line"> * bus, which delivers it to subscribers that have a matching handler method for the event type. To receive events,</div><div class="line"> * subscribers must register themselves to the bus using &#123;@link #register(Object)&#125;. Once registered, subscribers</div><div class="line"> * receive events until &#123;@link #unregister(Object)&#125; is called. Event handling methods must be annotated by</div><div class="line"> * &#123;@link Subscribe&#125;, must be public, return nothing (void), and have exactly one parameter</div><div class="line"> * (the event).</div><div class="line"> *</div><div class="line"> * @author Markus Junginger, greenrobot</div><div class="line"> */</div><div class="line">public class EventBus &#123;</div><div class="line"></div><div class="line">    /** Log tag, apps may override it. */</div><div class="line">    public static String TAG = &quot;EventBus&quot;;</div><div class="line"></div><div class="line">    static volatile EventBus defaultInstance;</div><div class="line"></div><div class="line">    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); // 建造者模式</div><div class="line">    private static final Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = new HashMap&lt;&gt;(); // 以作为Event的类的class为Key, 缓存class和interface, 包括其祖先</div><div class="line"></div><div class="line">    private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; // 这就是我们期待看到的 Map&lt;EventType, Subscribers&gt;</div><div class="line">    private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; // 这就是我们期待看到的 Map&lt;Subscriber, EventTypes&gt;</div><div class="line">    private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div><div class="line"></div><div class="line">    private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected PostingThreadState initialValue() &#123;</div><div class="line">            return new PostingThreadState();</div><div class="line">        &#125;</div><div class="line">    &#125;; // 线程独立的变量, 用来存储跟线程有关的状态</div><div class="line"></div><div class="line">    // @Nullable</div><div class="line">    private final MainThreadSupport mainThreadSupport;</div><div class="line">    // @Nullable</div><div class="line">    private final Poster mainThreadPoster;</div><div class="line">    private final BackgroundPoster backgroundPoster;</div><div class="line">    private final AsyncPoster asyncPoster;</div><div class="line">    private final SubscriberMethodFinder subscriberMethodFinder;</div><div class="line">    private final ExecutorService executorService;</div><div class="line"></div><div class="line">    private final boolean throwSubscriberException;</div><div class="line">    private final boolean logSubscriberExceptions;</div><div class="line">    private final boolean logNoSubscriberMessages;</div><div class="line">    private final boolean sendSubscriberExceptionEvent;</div><div class="line">    private final boolean sendNoSubscriberEvent;</div><div class="line">    private final boolean eventInheritance;</div><div class="line"></div><div class="line">    private final int indexCount;</div><div class="line">    private final Logger logger;</div><div class="line"></div><div class="line">    /** Convenience singleton for apps using a process-wide EventBus instance. */</div><div class="line">    public static EventBus getDefault() &#123;</div><div class="line">        EventBus instance = defaultInstance;</div><div class="line">        if (instance == null) &#123;</div><div class="line">            synchronized (EventBus.class) &#123;</div><div class="line">                instance = EventBus.defaultInstance;</div><div class="line">                if (instance == null) &#123;</div><div class="line">                    instance = EventBus.defaultInstance = new EventBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static EventBusBuilder builder() &#123;</div><div class="line">        return new EventBusBuilder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** For unit test primarily. */</div><div class="line">    public static void clearCaches() &#123;</div><div class="line">        SubscriberMethodFinder.clearCaches();</div><div class="line">        eventTypesCache.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</div><div class="line">     * central bus, consider &#123;@link #getDefault()&#125;.</div><div class="line">     */</div><div class="line">    public EventBus() &#123;</div><div class="line">        this(DEFAULT_BUILDER);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    EventBus(EventBusBuilder builder) &#123;</div><div class="line">        logger = builder.getLogger();</div><div class="line">        subscriptionsByEventType = new HashMap&lt;&gt;();</div><div class="line">        typesBySubscriber = new HashMap&lt;&gt;();</div><div class="line">        stickyEvents = new ConcurrentHashMap&lt;&gt;();</div><div class="line">        mainThreadSupport = builder.getMainThreadSupport();</div><div class="line">        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;</div><div class="line">        backgroundPoster = new BackgroundPoster(this);</div><div class="line">        asyncPoster = new AsyncPoster(this);</div><div class="line">        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;</div><div class="line">        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">                builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div><div class="line">        logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">        logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">        throwSubscriberException = builder.throwSubscriberException;</div><div class="line">        eventInheritance = builder.eventInheritance;</div><div class="line">        executorService = builder.executorService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they</div><div class="line">     * are no longer interested in receiving events.</div><div class="line">     * &lt;p/&gt;</div><div class="line">     * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;.</div><div class="line">     * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link</div><div class="line">     * ThreadMode&#125; and priority.</div><div class="line">     */</div><div class="line">    public void register(Object subscriber) &#123;</div><div class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</div><div class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); // 在subscriber对象中寻找带Subscribe注解的方法</div><div class="line">        synchronized (this) &#123;</div><div class="line">            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">                subscribe(subscriber, subscriberMethod); // 对Subscribe方法调用subscribe完成注册</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Must be called in synchronized block</div><div class="line">    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; // 为什么不把这个方法直接声明为synchronized?</div><div class="line">        Class&lt;?&gt; eventType = subscriberMethod.eventType; // 获取到方法注册的EventType</div><div class="line">        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); // 先看看这个EventType是不是已经有subscriber了, 如果没有就新建一个List</div><div class="line">        if (subscriptions == null) &#123;</div><div class="line">            subscriptions = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (subscriptions.contains(newSubscription)) &#123; // 如果List中已经有对应的&lt;EventType, Subscriber&gt;关系了, 则抛出异常, 表示重复注册了</div><div class="line">                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;</div><div class="line">                        + eventType);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int size = subscriptions.size();</div><div class="line">        for (int i = 0; i &lt;= size; i++) &#123;</div><div class="line">            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; // 根据优先级插入subscription到列表中</div><div class="line">                subscriptions.add(i, newSubscription);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); // 把当前处理的EventType记录到subscriber所处理的所有EventType的列表中</div><div class="line">        if (subscribedEvents == null) &#123;</div><div class="line">            subscribedEvents = new ArrayList&lt;&gt;();</div><div class="line">            typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">        &#125;</div><div class="line">        subscribedEvents.add(eventType);</div><div class="line"></div><div class="line">        if (subscriberMethod.sticky) &#123; // 处理sticky属性</div><div class="line">            if (eventInheritance) &#123;</div><div class="line">                // Existing sticky events of all subclasses of eventType have to be considered.</div><div class="line">                // Note: Iterating over all events may be inefficient with lots of sticky events,</div><div class="line">                // thus data structure should be changed to allow a more efficient lookup</div><div class="line">                // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</div><div class="line">                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">                    if (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">                        Object stickyEvent = entry.getValue();</div><div class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;</div><div class="line">        if (stickyEvent != null) &#123;</div><div class="line">            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</div><div class="line">            // --&gt; Strange corner case, which we don&apos;t take care of here.</div><div class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Checks if the current thread is running in the main thread.</div><div class="line">     * If there is no main thread support (e.g. non-Android), &quot;true&quot; is always returned. In that case MAIN thread</div><div class="line">     * subscribers are always called in posting thread, and BACKGROUND subscribers are always called from a background</div><div class="line">     * poster.</div><div class="line">     */</div><div class="line">    private boolean isMainThread() &#123;</div><div class="line">        return mainThreadSupport != null ? mainThreadSupport.isMainThread() : true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized boolean isRegistered(Object subscriber) &#123;</div><div class="line">        return typesBySubscriber.containsKey(subscriber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */</div><div class="line">    private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; // 在EventType的所有subscriber中移除指定的subscriber. 这个只维护&lt;EventType, Subscriber&gt;</div><div class="line">        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">        if (subscriptions != null) &#123;</div><div class="line">            int size = subscriptions.size();</div><div class="line">            for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                Subscription subscription = subscriptions.get(i);</div><div class="line">                if (subscription.subscriber == subscriber) &#123;</div><div class="line">                    subscription.active = false;</div><div class="line">                    subscriptions.remove(i);</div><div class="line">                    i--;</div><div class="line">                    size--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Unregisters the given subscriber from all event classes. */</div><div class="line">    public synchronized void unregister(Object subscriber) &#123;</div><div class="line">        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); // 查询指定的subscriber</div><div class="line">        if (subscribedTypes != null) &#123;</div><div class="line">            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">                unsubscribeByEventType(subscriber, eventType); // 对每个被订阅的EventType, 维护Map&lt;EventType, Subscribers&gt;</div><div class="line">            &#125;</div><div class="line">            typesBySubscriber.remove(subscriber); // 从Map&lt;Subscriber, EventTypes&gt;中移除指定的subscriber</div><div class="line">        &#125; else &#123;</div><div class="line">            logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Posts the given event to the event bus. */</div><div class="line">    public void post(Object event) &#123;</div><div class="line">        PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">        List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">        eventQueue.add(event); // 将事件压入队列</div><div class="line"></div><div class="line">        if (!postingState.isPosting) &#123;</div><div class="line">            postingState.isMainThread = isMainThread();</div><div class="line">            postingState.isPosting = true; // 如果当前不在isPosting状态, 则转换为isPosting状态并开始post循环, 处理事件队列</div><div class="line">            if (postingState.canceled) &#123;</div><div class="line">                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                while (!eventQueue.isEmpty()) &#123;</div><div class="line">                    postSingleEvent(eventQueue.remove(0), postingState);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                postingState.isPosting = false;</div><div class="line">                postingState.isMainThread = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Called from a subscriber&apos;s event handling method, further event delivery will be canceled. Subsequent</div><div class="line">     * subscribers</div><div class="line">     * won&apos;t receive the event. Events are usually canceled by higher priority subscribers (see</div><div class="line">     * &#123;@link Subscribe#priority()&#125;). Canceling is restricted to event handling methods running in posting thread</div><div class="line">     * &#123;@link ThreadMode#POSTING&#125;.</div><div class="line">     */</div><div class="line">    public void cancelEventDelivery(Object event) &#123;</div><div class="line">        PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">        if (!postingState.isPosting) &#123;</div><div class="line">            throw new EventBusException(</div><div class="line">                    &quot;This method may only be called from inside event handling methods on the posting thread&quot;);</div><div class="line">        &#125; else if (event == null) &#123;</div><div class="line">            throw new EventBusException(&quot;Event may not be null&quot;);</div><div class="line">        &#125; else if (postingState.event != event) &#123;</div><div class="line">            throw new EventBusException(&quot;Only the currently handled event may be aborted&quot;);</div><div class="line">        &#125; else if (postingState.subscription.subscriberMethod.threadMode != ThreadMode.POSTING) &#123;</div><div class="line">            throw new EventBusException(&quot; event handlers may only abort the incoming event&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        postingState.canceled = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky</div><div class="line">     * event of an event&apos;s type is kept in memory for future access by subscribers using &#123;@link Subscribe#sticky()&#125;.</div><div class="line">     */</div><div class="line">    public void postSticky(Object event) &#123;</div><div class="line">        synchronized (stickyEvents) &#123;</div><div class="line">            stickyEvents.put(event.getClass(), event);</div><div class="line">        &#125;</div><div class="line">        // Should be posted after it is putted, in case the subscriber wants to remove immediately</div><div class="line">        post(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Gets the most recent sticky event for the given type.</div><div class="line">     *</div><div class="line">     * @see #postSticky(Object)</div><div class="line">     */</div><div class="line">    public &lt;T&gt; T getStickyEvent(Class&lt;T&gt; eventType) &#123;</div><div class="line">        synchronized (stickyEvents) &#123;</div><div class="line">            return eventType.cast(stickyEvents.get(eventType));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Remove and gets the recent sticky event for the given event type.</div><div class="line">     *</div><div class="line">     * @see #postSticky(Object)</div><div class="line">     */</div><div class="line">    public &lt;T&gt; T removeStickyEvent(Class&lt;T&gt; eventType) &#123;</div><div class="line">        synchronized (stickyEvents) &#123;</div><div class="line">            return eventType.cast(stickyEvents.remove(eventType));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Removes the sticky event if it equals to the given event.</div><div class="line">     *</div><div class="line">     * @return true if the events matched and the sticky event was removed.</div><div class="line">     */</div><div class="line">    public boolean removeStickyEvent(Object event) &#123;</div><div class="line">        synchronized (stickyEvents) &#123;</div><div class="line">            Class&lt;?&gt; eventType = event.getClass();</div><div class="line">            Object existingEvent = stickyEvents.get(eventType);</div><div class="line">            if (event.equals(existingEvent)) &#123;</div><div class="line">                stickyEvents.remove(eventType);</div><div class="line">                return true;</div><div class="line">            &#125; else &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Removes all sticky events.</div><div class="line">     */</div><div class="line">    public void removeAllStickyEvents() &#123;</div><div class="line">        synchronized (stickyEvents) &#123;</div><div class="line">            stickyEvents.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean hasSubscriberForEvent(Class&lt;?&gt; eventClass) &#123; // 查询指定的事件是否有订阅者</div><div class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">        if (eventTypes != null) &#123;</div><div class="line">            int countTypes = eventTypes.size();</div><div class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</div><div class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">                CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">                synchronized (this) &#123;</div><div class="line">                    subscriptions = subscriptionsByEventType.get(clazz);</div><div class="line">                &#125;</div><div class="line">                if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 发布单个事件</div><div class="line">    private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;</div><div class="line">        Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">        boolean subscriptionFound = false;</div><div class="line">        if (eventInheritance) &#123;</div><div class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); // 查找指定事件相关联的所有事件</div><div class="line">            int countTypes = eventTypes.size();</div><div class="line">            for (int h = 0; h &lt; countTypes; h++) &#123;</div><div class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); // 对每个事件class调用</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">        &#125;</div><div class="line">        if (!subscriptionFound) &#123;</div><div class="line">            if (logNoSubscriberMessages) &#123;</div><div class="line">                logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);</div><div class="line">            &#125;</div><div class="line">            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">                post(new NoSubscriberEvent(this, event)); // 发送&quot;无人订阅该事件&quot;事件</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</div><div class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">        synchronized (this) &#123;</div><div class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">        &#125;</div><div class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">            for (Subscription subscription : subscriptions) &#123;</div><div class="line">                postingState.event = event;</div><div class="line">                postingState.subscription = subscription;</div><div class="line">                boolean aborted = false;</div><div class="line">                try &#123;</div><div class="line">                    postToSubscription(subscription, event, postingState.isMainThread); // 将事件传递给订阅者</div><div class="line">                    aborted = postingState.canceled;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    postingState.event = null;</div><div class="line">                    postingState.subscription = null;</div><div class="line">                    postingState.canceled = false;</div><div class="line">                &#125;</div><div class="line">                if (aborted) &#123; // 如果过程中有任一事件调用了cancel, 则后续订阅者不再接收事件</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将事件根据属性分发到不同线程上</div><div class="line">    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</div><div class="line">        switch (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">            case POSTING: // 直接抛到当前线程执行</div><div class="line">                invokeSubscriber(subscription, event);</div><div class="line">                break;</div><div class="line">            case MAIN:</div><div class="line">                if (isMainThread) &#123; // 如果当前就是主线程则直接调用</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case MAIN_ORDERED:</div><div class="line">                if (mainThreadPoster != null) &#123;</div><div class="line">                    mainThreadPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // temporary: technically not correct as poster not decoupled from subscriber</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case BACKGROUND:</div><div class="line">                if (isMainThread) &#123;</div><div class="line">                    backgroundPoster.enqueue(subscription, event);</div><div class="line">                &#125; else &#123;</div><div class="line">                    invokeSubscriber(subscription, event);</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case ASYNC:</div><div class="line">                asyncPoster.enqueue(subscription, event);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</div><div class="line">    private static List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</div><div class="line">        synchronized (eventTypesCache) &#123;</div><div class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</div><div class="line">            if (eventTypes == null) &#123;</div><div class="line">                eventTypes = new ArrayList&lt;&gt;();</div><div class="line">                Class&lt;?&gt; clazz = eventClass;</div><div class="line">                while (clazz != null) &#123;</div><div class="line">                    eventTypes.add(clazz);</div><div class="line">                    addInterfaces(eventTypes, clazz.getInterfaces());</div><div class="line">                    clazz = clazz.getSuperclass();</div><div class="line">                &#125;</div><div class="line">                eventTypesCache.put(eventClass, eventTypes);</div><div class="line">            &#125;</div><div class="line">            return eventTypes;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** Recurses through super interfaces. */</div><div class="line">    static void addInterfaces(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line">        for (Class&lt;?&gt; interfaceClass : interfaces) &#123;</div><div class="line">            if (!eventTypes.contains(interfaceClass)) &#123;</div><div class="line">                eventTypes.add(interfaceClass);</div><div class="line">                addInterfaces(eventTypes, interfaceClass.getInterfaces());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions</div><div class="line">     * between &#123;@link #unregister(Object)&#125; and event delivery. Otherwise the event might be delivered after the</div><div class="line">     * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the</div><div class="line">     * live cycle of an Activity or Fragment.</div><div class="line">     */</div><div class="line">    void invokeSubscriber(PendingPost pendingPost) &#123;</div><div class="line">        Object event = pendingPost.event;</div><div class="line">        Subscription subscription = pendingPost.subscription;</div><div class="line">        PendingPost.releasePendingPost(pendingPost);</div><div class="line">        if (subscription.active) &#123;</div><div class="line">            invokeSubscriber(subscription, event);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void invokeSubscriber(Subscription subscription, Object event) &#123;</div><div class="line">        try &#123;</div><div class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event); // 通过反射调用订阅者的方法</div><div class="line">        &#125; catch (InvocationTargetException e) &#123;</div><div class="line">            handleSubscriberException(subscription, event, e.getCause());</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleSubscriberException(Subscription subscription, Object event, Throwable cause) &#123;</div><div class="line">        if (event instanceof SubscriberExceptionEvent) &#123;</div><div class="line">            if (logSubscriberExceptions) &#123;</div><div class="line">                // Don&apos;t send another SubscriberExceptionEvent to avoid infinite event recursion, just log</div><div class="line">                logger.log(Level.SEVERE, &quot;SubscriberExceptionEvent subscriber &quot; + subscription.subscriber.getClass()</div><div class="line">                        + &quot; threw an exception&quot;, cause);</div><div class="line">                SubscriberExceptionEvent exEvent = (SubscriberExceptionEvent) event;</div><div class="line">                logger.log(Level.SEVERE, &quot;Initial event &quot; + exEvent.causingEvent + &quot; caused exception in &quot;</div><div class="line">                        + exEvent.causingSubscriber, exEvent.throwable);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (throwSubscriberException) &#123;</div><div class="line">                throw new EventBusException(&quot;Invoking subscriber failed&quot;, cause);</div><div class="line">            &#125;</div><div class="line">            if (logSubscriberExceptions) &#123;</div><div class="line">                logger.log(Level.SEVERE, &quot;Could not dispatch event: &quot; + event.getClass() + &quot; to subscribing class &quot;</div><div class="line">                        + subscription.subscriber.getClass(), cause);</div><div class="line">            &#125;</div><div class="line">            if (sendSubscriberExceptionEvent) &#123;</div><div class="line">                SubscriberExceptionEvent exEvent = new SubscriberExceptionEvent(this, cause, event,</div><div class="line">                        subscription.subscriber);</div><div class="line">                post(exEvent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** For ThreadLocal, much faster to set (and get multiple values). */</div><div class="line">    final static class PostingThreadState &#123;</div><div class="line">        final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();</div><div class="line">        boolean isPosting;</div><div class="line">        boolean isMainThread;</div><div class="line">        Subscription subscription;</div><div class="line">        Object event;</div><div class="line">        boolean canceled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ExecutorService getExecutorService() &#123;</div><div class="line">        return executorService;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * For internal use only.</div><div class="line">     */</div><div class="line">    public Logger getLogger() &#123;</div><div class="line">        return logger;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Just an idea: we could provide a callback to post() to be notified, an alternative would be events, of course...</div><div class="line">    /* public */interface PostCallback &#123;</div><div class="line">        void onPostCompleted(List&lt;SubscriberExceptionEvent&gt; exceptionEvents);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;EventBus[indexCount=&quot; + indexCount + &quot;, eventInheritance=&quot; + eventInheritance + &quot;]&quot;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上述代码加了注释之后, 读者应该能较好地理解EventBus主类的逻辑了. 其他的例如Poster, EventBusBuilder, SubscriberMethod, SubscriberMethodFinder等都是一些具体的实现方法了, 这里不再赘述, 有兴趣的朋友可以深入看一下.<br>以上代码需要注意的是, 事件和订阅者都是注册到具体的EventBus对象上的, 也就是说注册到不同EventBus对象上的事件和订阅者互相不可见. 作者在注释中说, 如果要让EventBus发挥集中式事件总线的作用, 应该用EventBus.getDefault()的方式获取EventBus对象.  </p>
<h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><p>EventBus项目在3.0版本加入了EventBusAnnotationProcessor, 可以在编译期处理注解, 达到性能优化的目的.  </p>
<h2 id="一点疑问"><a href="#一点疑问" class="headerlink" title="一点疑问"></a>一点疑问</h2><p>根据EventBus官方库的文档, 它比otto库快很多, 但是我不太明白它为什么比otto快.<br>可以想到的点是, 它将SubscriberMethod进行了缓存, 从而不必每次都反射调用. 它使用了CopyOnWriteArrayList, 从而不必进行同步操作.  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/yanbober/article/details/45671407" target="_blank" rel="external">EventBus框架库代码走读 工匠若水</a>  </li>
<li><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus源码</a>  </li>
<li><a href="https://github.com/google/guava/wiki/EventBusExplained" target="_blank" rel="external">EventBus Wiki</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      本篇讲大名鼎鼎的开源库EventBus.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Java小知识--引用类型</title>
    <link href="https://hjhjw1991.github.io/blog/2018/06/04/Java%E5%B0%8F%E7%9F%A5%E8%AF%86--%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://hjhjw1991.github.io/blog/2018/06/04/Java小知识--引用类型/</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-04T10:27:34.271Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中, 我们知道对象都是以引用的形式存在于代码中的.<br>Java的自动垃圾回收, 就是基于引用, 如果一个对象再也没有人引用, 就会回收这个对象.<br>但是实际上还会有别的回收程度: 我要使用一个对象, 但是我可以在内存紧张的时候允许回收这个对象, 甚至我允许只要有垃圾回收就把这个对象回收. 换句话说, 我对这个对象的使用并没有”那么强”的要求, 为了内存分配我可以让渡空间.<br>基于上述实际情况, Java中专门创建了新的类来允许上述让渡行为, 即Reference. 针对不同的引用层级, 又分为以下几种引用:  </p>
<ol>
<li>强引用. 即一般的对象引用声明. 拥有强引用的对象, 任何时候都不会被回收.  </li>
<li>软引用. SoftReference. 仅有软引用的对象, 在内存不足时允许回收.  </li>
<li>弱引用. WeakReference. 仅有弱引用的对象, 在下次垃圾回收时允许被回收.  </li>
<li>虚引用. PhantomReference. 虚引用只能作为引用标记, 不影响对象生命周期. 仅有虚引用的对象, 等效于没有引用, 但Java的实现中允许给虚引用添加一个队列, 当引用指向的对象其可触及性发生变化时, 该对象会被添加到指定的引用队列(这其实是抽象类Reference的实现). 例如, 如果我们想要在某个对象确实被回收后, 才创建新的对象, 那么我们可以对这个对象创建一个虚引用, 并监控传入的引用队列, 在队列非空时创建新对象.  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      在Java中, 我们知道对象都是以引用的形式存在于代码中的.
    
    </summary>
    
      <category term="blog" scheme="https://hjhjw1991.github.io/categories/blog/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="Java" scheme="https://hjhjw1991.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Apk安装卸载原理</title>
    <link href="https://hjhjw1991.github.io/android/2018/01/02/Apk%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <id>https://hjhjw1991.github.io/android/2018/01/02/Apk安装卸载原理/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2018-01-02T10:58:28.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>写多了业务逻辑, 咱们来看看系统的”业务逻辑”.  </p>
</blockquote>
<p>本文介绍apk如何安装, 卸载以及更新.<br>众所周知, apk本质上就是一个zip包, 在阅读本文前, 各位同学可以猜测一下安装一个压缩包是个什么流程, 如果有用adb安装过的同学应该会非常熟悉<code>adb install</code>这个命令, 但是可能不太熟悉<code>adb shell am</code>和<code>adb shell pm</code>这两个命令.  </p>
<h2 id="Apk安装"><a href="#Apk安装" class="headerlink" title="Apk安装"></a>Apk安装</h2><p>常见的apk安装方式有三种:  </p>
<ol>
<li>系统自带的应用和厂商预装的应用. 没错, 系统自带的应用其实也是apk, 其安装是在系统首次启动时完成的. 这也就是为什么root后可以卸载系统自带应用.  </li>
<li>通过存储介质安装. 最常见的就是通过sd卡放置apk或者网上下载apk方式安装.  </li>
<li>adb命令安装. 这应该是开发者最熟悉的安装方式了, 包括<code>adb install</code>和<code>adb pm install</code>.  </li>
</ol>
<p>三种安装方式, 在安装apk时最终都是同一套流程, 即处理apk文件的流程. 安装过程可以归结为以下几个步骤:  </p>
<ol>
<li>将apk文件拷贝到指定目录下. 系统应用是在<code>/system/app</code>, 第三方应用在<code>/data/app</code>上.  </li>
<li>解压apk, 拷贝文件. 创建UID, 创建<code>/data/data/${package_name}</code>目录, 设置权限. 这个就是应用的数据目录.  </li>
<li>从apk中提取dex, 放到<code>/data/dalvik-cache</code>目录.  </li>
<li>解析<code>AndroidManifest.xml</code>文件, 提取信息添加到PMS中, 更新PMS中相应的数据结构. 具体是, 将提取到的包信息更新到<code>/data/system/packages.list</code>和<code>/data/system/packages.xml</code>.  </li>
<li>发送广播<code>Intent.ACTION_PACKAGE_ADDED</code>或者<code>Intent.ACTION_PACKAGE_REPLACED</code>. 从名字可以判断分别对应全新安装和覆盖安装.  </li>
</ol>
<p>系统自带的以及厂商预装的app, 在手机首次启动时, 会通过扫描<code>/system/app</code> <code>/system/framework</code> <code>/vendor/app</code>等目录下面的APK文件, 完成安装. 原生系统没有vendor目录.<br>至于通过<code>adb push</code>的方式, 如果root过, 完全可以推送到系统目录, 以系统应用的方式进行安装. 系统应用的好处是系统在启动的时候就会将apk进行解压复制, 坏处是没办法热更新等. 推送到一般目录, 则可以使用系统命令<code>/bin/pm</code>安装apk文件. <code>pm</code>就是一个可执行文件版的<code>PackageManager</code>. 最终调用<code>PackageManager.installPackage() -&gt; PackageManagerService.installPacakge()</code>进行安装. 顺便一提, 具有<code>INSTALL_PACKAGES</code>权限就可以自己调用这个方法进行apk安装.  </p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>启动的时候,     主要是<code>PackageManagerService</code>进行安装包扫描和解析工作. 信息解析完毕后存在特定数据结构中(<code>PackageParser.Package</code>), 此后需要进行信息同步工作. 这是因为, 扫描到的APK可能是已经更名的包/disable的包/需要升级的包/已经安装但签名冲突的包/替换了系统包的非系统包等情况, 需要处理这些情况, 保证最终信息正确.<br>如果包需要进行<code>Rename</code>或者<code>Update</code>, 则需要签名比较.  </p>
<p><code>adb shell pm</code>略有不同, 是由<code>com.android.commands.pm.Pm</code>中的<code>runInstall</code>实现的(<code>adb install</code>最终也是调用的<code>shell pm</code>).  </p>
<h3 id="核心函数scanPackageDirtyLI"><a href="#核心函数scanPackageDirtyLI" class="headerlink" title="核心函数scanPackageDirtyLI"></a>核心函数scanPackageDirtyLI</h3><p>程序最初调用<code>installPackageAsUser</code>检查是否有安装权限, 安装APK的整个过程在<code>PackageHandler</code>中进行, 主要分为 拷贝APK(检查是否有足够空间)-&gt;扫描APK-&gt;安装后处理(主要是发送广播信息), 其中最关键的一步就是扫描APK, 由函数<code>scanPackageLI</code>完成, 该函数里面调用<code>scanPackageDirtyLI</code>.<br>下面就请看该方法的源码(基于Android 7.0)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div></pre></td><td class="code"><pre><div class="line">// 位于frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</div><div class="line">// 该方法相当长, 因此我去掉了调试&amp;&amp;异常处理的代码, 并加上了中文注释, 部分内容以注释代替源码, 如有需要请读者自行阅读源码.  </div><div class="line">private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg,</div><div class="line">        final int policyFlags, final int scanFlags, long currentTime, UserHandle user)</div><div class="line">        throws PackageManagerException &#123;</div><div class="line">    final File scanFile = new File(pkg.codePath);</div><div class="line">    // codePath或resourcePath为空, 抛出异常</div><div class="line">    ...</div><div class="line"></div><div class="line">    // Apply policy</div><div class="line">    if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM) != 0) &#123;</div><div class="line">        // 系统应用, 设置标记</div><div class="line">    &#125; else &#123;</div><div class="line">        // 非系统应用, 设置标记</div><div class="line">    &#125;</div><div class="line">    // 检查其他标记位, 并执行对应操作</div><div class="line"></div><div class="line">    // TODO 知识盲区</div><div class="line">    if (mCustomResolverComponentName != null &amp;&amp;</div><div class="line">            mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) &#123;</div><div class="line">        setUpCustomResolverActivity(pkg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 包名为android, 即系统核心包</div><div class="line">    if (pkg.packageName.equals(&quot;android&quot;)) &#123;</div><div class="line">        synchronized (mPackages) &#123;</div><div class="line">            if (mAndroidApplication != null) &#123;</div><div class="line">                // 核心包重复定义, 抛出异常</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123;</div><div class="line">                // 设置包解析信息</div><div class="line">                // Set up information for our fall-back user intent resolution activity.</div><div class="line">                mPlatformPackage = pkg;</div><div class="line">                pkg.mVersionCode = mSdkVersion;</div><div class="line">                mAndroidApplication = pkg.applicationInfo;</div><div class="line"></div><div class="line">                if (!mResolverReplaced) &#123;</div><div class="line">                    mResolveActivity.applicationInfo = mAndroidApplication;</div><div class="line">                    mResolveActivity.name = ResolverActivity.class.getName();</div><div class="line">                    mResolveActivity.packageName = mAndroidApplication.packageName;</div><div class="line">                    mResolveActivity.processName = &quot;system:ui&quot;;</div><div class="line">                    mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;</div><div class="line">                    mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;</div><div class="line">                    mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;</div><div class="line">                    mResolveActivity.theme = R.style.Theme_Material_Dialog_Alert;</div><div class="line">                    mResolveActivity.exported = true;</div><div class="line">                    mResolveActivity.enabled = true;</div><div class="line">                    mResolveActivity.resizeMode = ActivityInfo.RESIZE_MODE_RESIZEABLE;</div><div class="line">                    mResolveActivity.configChanges = ActivityInfo.CONFIG_SCREEN_SIZE</div><div class="line">                            | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE</div><div class="line">                            | ActivityInfo.CONFIG_SCREEN_LAYOUT</div><div class="line">                            | ActivityInfo.CONFIG_ORIENTATION</div><div class="line">                            | ActivityInfo.CONFIG_KEYBOARD</div><div class="line">                            | ActivityInfo.CONFIG_KEYBOARD_HIDDEN;</div><div class="line">                    mResolveInfo.activityInfo = mResolveActivity;</div><div class="line">                    mResolveInfo.priority = 0;</div><div class="line">                    mResolveInfo.preferredOrder = 0;</div><div class="line">                    mResolveInfo.match = 0;</div><div class="line">                    mResolveComponentName = new ComponentName(</div><div class="line">                            mAndroidApplication.packageName, mResolveActivity.name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        if (mPackages.containsKey(pkg.packageName)</div><div class="line">                || mSharedLibraries.containsKey(pkg.packageName)) &#123;</div><div class="line">            // 包名重复, 抛出异常</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If we&apos;re only installing presumed-existing packages, require that the</div><div class="line">        // scanned APK is both already known and at the path previously established</div><div class="line">        // for it.  Previously unknown packages we pick up normally, but if we have an</div><div class="line">        // a priori expectation about this package&apos;s install presence, enforce it.</div><div class="line">        // With a singular exception for new system packages. When an OTA contains</div><div class="line">        // a new system package, we allow the codepath to change from a system location</div><div class="line">        // to the user-installed location. If we don&apos;t allow this change, any newer,</div><div class="line">        // user-installed version of the application will be ignored.</div><div class="line">        if ((scanFlags &amp; SCAN_REQUIRE_KNOWN) != 0) &#123;</div><div class="line">            if (mExpectingBetter.containsKey(pkg.packageName)) &#123;</div><div class="line">            &#125; else &#123;</div><div class="line">                PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);</div><div class="line">                if (known != null) &#123;</div><div class="line">                    if (!pkg.applicationInfo.getCodePath().equals(known.codePathString)</div><div class="line">                            || !pkg.applicationInfo.getResourcePath().equals(</div><div class="line">                            known.resourcePathString)) &#123;</div><div class="line">                        // 包被修改, 抛出异常</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Initialize package source and resource directories</div><div class="line">    File destCodeFile = new File(pkg.applicationInfo.getCodePath());</div><div class="line">    File destResourceFile = new File(pkg.applicationInfo.getResourcePath());</div><div class="line"></div><div class="line">    SharedUserSetting suid = null;</div><div class="line">    PackageSetting pkgSetting = null;</div><div class="line"></div><div class="line">    if (!isSystemApp(pkg)) &#123;</div><div class="line">        // Only system apps can use these features.</div><div class="line">        pkg.mOriginalPackages = null;</div><div class="line">        pkg.mRealPackage = null;</div><div class="line">        pkg.mAdoptPermissions = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Getting the package setting may have a side-effect, so if we</div><div class="line">    // are only checking if scan would succeed, stash a copy of the</div><div class="line">    // old setting to restore at the end.</div><div class="line">    PackageSetting nonMutatedPs = null;</div><div class="line"></div><div class="line">    // writer</div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        if (pkg.mSharedUserId != null) &#123;</div><div class="line">            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);</div><div class="line">            if (suid == null) &#123;</div><div class="line">                // 存储空间不足</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Check if we are renaming from an original package name.</div><div class="line">        PackageSetting origPackage = null;</div><div class="line">        String realName = null;</div><div class="line">        if (pkg.mOriginalPackages != null) &#123;</div><div class="line">            // 检查包名是否有更改(例如本地化成其他语言), 如果有, 更新包名信息</div><div class="line">            // This package may need to be renamed to a previously</div><div class="line">            // installed name.  Let&apos;s check on that...</div><div class="line">            final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);</div><div class="line">            if (pkg.mOriginalPackages.contains(renamed)) &#123;</div><div class="line">                // This package had originally been installed as the</div><div class="line">                // original name, and we have already taken care of</div><div class="line">                // transitioning to the new one.  Just update the new</div><div class="line">                // one to continue using the old name.</div><div class="line">                realName = pkg.mRealPackage;</div><div class="line">                if (!pkg.packageName.equals(renamed)) &#123;</div><div class="line">                    // Callers into this function may have already taken</div><div class="line">                    // care of renaming the package; only do it here if</div><div class="line">                    // it is not already done.</div><div class="line">                    pkg.setPackageName(renamed);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; else &#123;</div><div class="line">                for (int i=pkg.mOriginalPackages.size()-1; i&gt;=0; i--) &#123;</div><div class="line">                    if ((origPackage = mSettings.peekPackageLPr(</div><div class="line">                            pkg.mOriginalPackages.get(i))) != null) &#123;</div><div class="line">                        // We do have the package already installed under its</div><div class="line">                        // original name...  should we use it?</div><div class="line">                        if (!verifyPackageUpdateLPr(origPackage, pkg)) &#123;</div><div class="line">                            // New package is not compatible with original.</div><div class="line">                            origPackage = null;</div><div class="line">                            continue;</div><div class="line">                        &#125; else if (origPackage.sharedUser != null) &#123;</div><div class="line">                            // Make sure uid is compatible between packages.</div><div class="line">                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) &#123;</div><div class="line">                                origPackage = null;</div><div class="line">                                continue;</div><div class="line">                            &#125;</div><div class="line">                            // TODO: Add case when shared user id is added [b/28144775]</div><div class="line">                        &#125; else &#123;</div><div class="line">                        &#125;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mTransferedPackages.contains(pkg.packageName)) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // See comments in nonMutatedPs declaration</div><div class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</div><div class="line">            PackageSetting foundPs = mSettings.peekPackageLPr(pkg.packageName);</div><div class="line">            if (foundPs != null) &#123;</div><div class="line">                nonMutatedPs = new PackageSetting(foundPs);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Just create the setting, don&apos;t add it yet. For already existing packages</div><div class="line">        // the PkgSetting exists already and doesn&apos;t have to be created.</div><div class="line">        pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,</div><div class="line">                destResourceFile, pkg.applicationInfo.nativeLibraryRootDir,</div><div class="line">                pkg.applicationInfo.primaryCpuAbi,</div><div class="line">                pkg.applicationInfo.secondaryCpuAbi,</div><div class="line">                pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags,</div><div class="line">                user, false);</div><div class="line">        if (pkgSetting == null) &#123;</div><div class="line">            // 空间不足, 抛出异常</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (pkgSetting.origPackage != null) &#123;</div><div class="line">            // If we are first transitioning from an original package,</div><div class="line">            // fix up the new package&apos;s name now.  We need to do this after</div><div class="line">            // looking up the package under its new name, so getPackageLP</div><div class="line">            // can take care of fiddling things correctly.</div><div class="line">            pkg.setPackageName(origPackage.name);</div><div class="line"></div><div class="line">            // File a report about this.</div><div class="line">            String msg = &quot;New package &quot; + pkgSetting.realName</div><div class="line">                    + &quot; renamed to replace old package &quot; + pkgSetting.name;</div><div class="line">            reportSettingsProblem(Log.WARN, msg);</div><div class="line"></div><div class="line">            // Make a note of it.</div><div class="line">            if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123;</div><div class="line">                mTransferedPackages.add(origPackage.name);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // No longer need to retain this.</div><div class="line">            pkgSetting.origPackage = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123;</div><div class="line">            // Make a note of it.</div><div class="line">            mTransferedPackages.add(pkg.packageName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123;</div><div class="line">            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</div><div class="line">            // Check all shared libraries and map to their actual file path.</div><div class="line">            // We only do this here for apps not on a system dir, because those</div><div class="line">            // are the only ones that can fail an install due to this.  We</div><div class="line">            // will take care of the system apps by updating all of their</div><div class="line">            // library paths after the scan is done.</div><div class="line">            updateSharedLibrariesLPw(pkg, null);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mFoundPolicyFile) &#123;</div><div class="line">            SELinuxMMAC.assignSeinfoValue(pkg);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        pkg.applicationInfo.uid = pkgSetting.appId;</div><div class="line">        pkg.mExtras = pkgSetting;</div><div class="line">        if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) &#123;</div><div class="line">            if (checkUpgradeKeySetLP(pkgSetting, pkg)) &#123;</div><div class="line">                // We just determined the app is signed correctly, so bring</div><div class="line">                // over the latest parsed certs.</div><div class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</div><div class="line">            &#125; else &#123;</div><div class="line">                if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</div><div class="line">                    // 非系统目录, 签名不正确, 抛出异常</div><div class="line">                &#125; else &#123;</div><div class="line">                    pkgSetting.signatures.mSignatures = pkg.mSignatures;</div><div class="line">                    String msg = &quot;System package &quot; + pkg.packageName</div><div class="line">                        + &quot; signature changed; retaining data.&quot;;</div><div class="line">                    reportSettingsProblem(Log.WARN, msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            try &#123;</div><div class="line">                verifySignaturesLP(pkgSetting, pkg);</div><div class="line">                // We just determined the app is signed correctly, so bring</div><div class="line">                // over the latest parsed certs.</div><div class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</div><div class="line">            &#125; catch (PackageManagerException e) &#123;</div><div class="line">                if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</div><div class="line">                    // 非系统目录, 检查签名的过程中发生异常, 抛出异常</div><div class="line">                &#125;</div><div class="line">                // The signature has changed, but this package is in the system</div><div class="line">                // image...  let&apos;s recover!</div><div class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</div><div class="line">                // However...  if this package is part of a shared user, but it</div><div class="line">                // doesn&apos;t match the signature of the shared user, let&apos;s fail.</div><div class="line">                // What this means is that you can&apos;t change the signatures</div><div class="line">                // associated with an overall shared user, which doesn&apos;t seem all</div><div class="line">                // that unreasonable.</div><div class="line">                if (pkgSetting.sharedUser != null) &#123;</div><div class="line">                    if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures,</div><div class="line">                                          pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123;</div><div class="line">                    // 签名不一致, 抛出异常</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                // File a report about this.</div><div class="line">                String msg = &quot;System package &quot; + pkg.packageName</div><div class="line">                    + &quot; signature changed; retaining data.&quot;;</div><div class="line">                reportSettingsProblem(Log.WARN, msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Verify that this new package doesn&apos;t have any content providers</div><div class="line">        // that conflict with existing packages.  Only do this if the</div><div class="line">        // package isn&apos;t already installed, since we don&apos;t want to break</div><div class="line">        // things that are installed.</div><div class="line">        if ((scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123;</div><div class="line">            // 全新安装, 检查ContentProvider是否与现有的冲突</div><div class="line">            final int N = pkg.providers.size();</div><div class="line">            int i;</div><div class="line">            for (i=0; i&lt;N; i++) &#123;</div><div class="line">                PackageParser.Provider p = pkg.providers.get(i);</div><div class="line">                if (p.info.authority != null) &#123;</div><div class="line">                    String names[] = p.info.authority.split(&quot;;&quot;);</div><div class="line">                    for (int j = 0; j &lt; names.length; j++) &#123;</div><div class="line">                        if (mProvidersByAuthority.containsKey(names[j])) &#123;</div><div class="line">                            PackageParser.Provider other = mProvidersByAuthority.get(names[j]);</div><div class="line">                            final String otherPackageName =</div><div class="line">                                    ((other != null &amp;&amp; other.getComponentName() != null) ?</div><div class="line">                                            other.getComponentName().getPackageName() : &quot;?&quot;);</div><div class="line">                            // ContentProvider冲突, 抛出异常</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123;</div><div class="line">            // This package wants to adopt ownership of permissions from</div><div class="line">            // another package.</div><div class="line">            // 从其他应用获取权限</div><div class="line">            for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123;</div><div class="line">                final String origName = pkg.mAdoptPermissions.get(i);</div><div class="line">                final PackageSetting orig = mSettings.peekPackageLPr(origName);</div><div class="line">                if (orig != null) &#123;</div><div class="line">                    if (verifyPackageUpdateLPr(orig, pkg)) &#123;</div><div class="line">                        mSettings.transferPermissionsLPw(origName, pkg.packageName);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final String pkgName = pkg.packageName;</div><div class="line"></div><div class="line">    final long scanFileTime = scanFile.lastModified();</div><div class="line">    final boolean forceDex = (scanFlags &amp; SCAN_FORCE_DEX) != 0;</div><div class="line">    pkg.applicationInfo.processName = fixProcessName(</div><div class="line">            pkg.applicationInfo.packageName,</div><div class="line">            pkg.applicationInfo.processName,</div><div class="line">            pkg.applicationInfo.uid);</div><div class="line"></div><div class="line">    if (pkg != mPlatformPackage) &#123;</div><div class="line">        // Get all of our default paths setup</div><div class="line">        pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final String path = scanFile.getPath();</div><div class="line">    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);</div><div class="line"></div><div class="line">    if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) &#123;</div><div class="line">        // 如果不是全新安装, 从包中获取abi信息</div><div class="line">        derivePackageAbi(pkg, scanFile, cpuAbiOverride, true /* extract libs */);</div><div class="line"></div><div class="line">        // Some system apps still use directory structure for native libraries</div><div class="line">        // in which case we might end up not detecting abi solely based on apk</div><div class="line">        // structure. Try to detect abi based on directory structure.</div><div class="line">        if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp;</div><div class="line">                pkg.applicationInfo.primaryCpuAbi == null) &#123;</div><div class="line">            // 系统app, 设置native library路径</div><div class="line">            setBundledAppAbisAndRoots(pkg, pkgSetting);</div><div class="line">            setNativeLibraryPaths(pkg);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        // 全新安装</div><div class="line">        if ((scanFlags &amp; SCAN_MOVE) != 0) &#123;</div><div class="line">            // We haven&apos;t run dex-opt for this move (since we&apos;ve moved the compiled output too)</div><div class="line">            // but we already have this packages package info in the PackageSetting. We just</div><div class="line">            // use that and derive the native library path based on the new codepath.</div><div class="line">            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;</div><div class="line">            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Set native library paths again. For moves, the path will be updated based on the</div><div class="line">        // ABIs we&apos;ve determined above. For non-moves, the path will be updated based on the</div><div class="line">        // ABIs we determined during compilation, but the path will depend on the final</div><div class="line">        // package path (after the rename away from the stage path).</div><div class="line">        setNativeLibraryPaths(pkg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // This is a special case for the &quot;system&quot; package, where the ABI is</div><div class="line">    // dictated by the zygote configuration (and init.rc). We should keep track</div><div class="line">    // of this ABI so that we can deal with &quot;normal&quot; applications that run under</div><div class="line">    // the same UID correctly.</div><div class="line">    // 系统包的abi是从配置文件读取的, 应当保存下来, 在后续处理同一uid下的其他应用时可以使用</div><div class="line">    if (mPlatformPackage == pkg) &#123;</div><div class="line">        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ?</div><div class="line">                Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If there&apos;s a mismatch between the abi-override in the package setting</div><div class="line">    // and the abiOverride specified for the install. Warn about this because we</div><div class="line">    // would&apos;ve already compiled the app without taking the package setting into</div><div class="line">    // account.</div><div class="line">    if ((scanFlags &amp; SCAN_NO_DEX) == 0 &amp;&amp; (scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123;</div><div class="line">        if (cpuAbiOverride == null &amp;&amp; pkgSetting.cpuAbiOverrideString != null) &#123;</div><div class="line">            Slog.w(TAG, &quot;Ignoring persisted ABI override &quot; + cpuAbiOverride +</div><div class="line">                    &quot; for package &quot; + pkg.packageName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;</div><div class="line">    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;</div><div class="line">    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;</div><div class="line"></div><div class="line">    // Copy the derived override back to the parsed package, so that we can</div><div class="line">    // update the package settings accordingly.</div><div class="line">    pkg.cpuAbiOverride = cpuAbiOverride;</div><div class="line"></div><div class="line">    // Push the derived path down into PackageSettings so we know what to</div><div class="line">    // clean up at uninstall time.</div><div class="line">    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;</div><div class="line"></div><div class="line">    if ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; pkgSetting.sharedUser != null) &#123;</div><div class="line">        // 共享用户, 微调abi信息</div><div class="line">        // We don&apos;t do this here during boot because we can do it all</div><div class="line">        // at once after scanning all existing packages.</div><div class="line">        //</div><div class="line">        // We also do this *before* we perform dexopt on this package, so that</div><div class="line">        // we can avoid redundant dexopts, and also to make sure we&apos;ve got the</div><div class="line">        // code and package path correct.</div><div class="line">        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages,</div><div class="line">                pkg, true /* boot complete */);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ArrayList&lt;PackageParser.Package&gt; clientLibPkgs = null;</div><div class="line"></div><div class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</div><div class="line">        // 如果扫描标记含有SCAN_CHECK_ONLY, 那么在此处就结束并返回了</div><div class="line">        if (nonMutatedPs != null) &#123;</div><div class="line">            synchronized (mPackages) &#123;</div><div class="line">                mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return pkg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Only privileged apps and updated privileged apps can add child packages.</div><div class="line">    if (pkg.childPackages != null &amp;&amp; !pkg.childPackages.isEmpty()) &#123;</div><div class="line">        if ((policyFlags &amp; PARSE_IS_PRIVILEGED) == 0) &#123;</div><div class="line">            // 只允许特权包添加子包, 否则抛出异常</div><div class="line">        &#125;</div><div class="line">        final int childCount = pkg.childPackages.size();</div><div class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">            PackageParser.Package childPkg = pkg.childPackages.get(i);</div><div class="line">            if (mSettings.hasOtherDisabledSystemPkgWithChildLPr(pkg.packageName,</div><div class="line">                    childPkg.packageName)) &#123;</div><div class="line">                // 不允许覆盖其他被禁止的系统应用的子包, 否则抛出异常</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // writer</div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        // 系统包, 添加新的共享库</div><div class="line">        if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) != 0) &#123;</div><div class="line">            // Only system apps can add new shared libraries.</div><div class="line">            if (pkg.libraryNames != null) &#123;</div><div class="line">                for (int i=0; i&lt;pkg.libraryNames.size(); i++) &#123;</div><div class="line">                    String name = pkg.libraryNames.get(i);</div><div class="line">                    boolean allowed = false;</div><div class="line">                    if (pkg.isUpdatedSystemApp()) &#123;</div><div class="line">                        // New library entries can only be added through the</div><div class="line">                        // system image.  This is important to get rid of a lot</div><div class="line">                        // of nasty edge cases: for example if we allowed a non-</div><div class="line">                        // system update of the app to add a library, then uninstalling</div><div class="line">                        // the update would make the library go away, and assumptions</div><div class="line">                        // we made such as through app install filtering would now</div><div class="line">                        // have allowed apps on the device which aren&apos;t compatible</div><div class="line">                        // with it.  Better to just have the restriction here, be</div><div class="line">                        // conservative, and create many fewer cases that can negatively</div><div class="line">                        // impact the user experience.</div><div class="line">                        final PackageSetting sysPs = mSettings</div><div class="line">                                .getDisabledSystemPkgLPr(pkg.packageName);</div><div class="line">                        if (sysPs.pkg != null &amp;&amp; sysPs.pkg.libraryNames != null) &#123;</div><div class="line">                            for (int j=0; j&lt;sysPs.pkg.libraryNames.size(); j++) &#123;</div><div class="line">                                if (name.equals(sysPs.pkg.libraryNames.get(j))) &#123;</div><div class="line">                                    allowed = true;</div><div class="line">                                    break;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        allowed = true;</div><div class="line">                    &#125;</div><div class="line">                    if (allowed) &#123;</div><div class="line">                        if (!mSharedLibraries.containsKey(name)) &#123;</div><div class="line">                            mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));</div><div class="line">                        &#125; else if (!name.equals(pkg.packageName)) &#123;</div><div class="line">                            Slog.w(TAG, &quot;Package &quot; + pkg.packageName + &quot; library &quot;</div><div class="line">                                    + name + &quot; already exists; skipping&quot;);</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        Slog.w(TAG, &quot;Package &quot; + pkg.packageName + &quot; declares lib &quot;</div><div class="line">                                + name + &quot; that is not declared on system image; skipping&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if ((scanFlags &amp; SCAN_BOOTING) == 0) &#123;</div><div class="line">                    // If we are not booting, we need to update any applications</div><div class="line">                    // that are clients of our shared library.  If we are booting,</div><div class="line">                    // this will all be done once the scan is complete.</div><div class="line">                    clientLibPkgs = updateAllSharedLibrariesLPw(pkg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ((scanFlags &amp; SCAN_BOOTING) != 0) &#123;</div><div class="line">        // No apps can run during boot scan, so they don&apos;t need to be frozen</div><div class="line">    &#125; else if ((scanFlags &amp; SCAN_DONT_KILL_APP) != 0) &#123;</div><div class="line">        // Caller asked to not kill app, so it&apos;s probably not frozen</div><div class="line">    &#125; else if ((scanFlags &amp; SCAN_IGNORE_FROZEN) != 0) &#123;</div><div class="line">        // Caller asked us to ignore frozen check for some reason; they</div><div class="line">        // probably didn&apos;t know the package name</div><div class="line">    &#125; else &#123;</div><div class="line">        // We&apos;re doing major surgery on this package, so it better be frozen</div><div class="line">        // right now to keep it from launching</div><div class="line">        // 冻结包, 不允许启动</div><div class="line">        checkPackageFrozen(pkgName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Also need to kill any apps that are dependent on the library.</div><div class="line">    // 杀死所有依赖本库的应用</div><div class="line">    if (clientLibPkgs != null) &#123;</div><div class="line">        for (int i=0; i&lt;clientLibPkgs.size(); i++) &#123;</div><div class="line">            PackageParser.Package clientPkg = clientLibPkgs.get(i);</div><div class="line">            killApplication(clientPkg.applicationInfo.packageName,</div><div class="line">                    clientPkg.applicationInfo.uid, &quot;update lib&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Make sure we&apos;re not adding any bogus keyset info</div><div class="line">    KeySetManagerService ksms = mSettings.mKeySetManagerService;</div><div class="line">    ksms.assertScannedPackageValid(pkg);</div><div class="line"></div><div class="line">    // writer</div><div class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;updateSettings&quot;);</div><div class="line"></div><div class="line">    boolean createIdmapFailed = false;</div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        // We don&apos;t expect installation to fail beyond this point</div><div class="line"></div><div class="line">        if (pkgSetting.pkg != null) &#123;</div><div class="line">            // Note that |user| might be null during the initial boot scan. If a codePath</div><div class="line">            // for an app has changed during a boot scan, it&apos;s due to an app update that&apos;s</div><div class="line">            // part of the system partition and marker changes must be applied to all users.</div><div class="line">            maybeRenameForeignDexMarkers(pkgSetting.pkg, pkg,</div><div class="line">                (user != null) ? user : UserHandle.ALL);</div><div class="line">        &#125;</div><div class="line">        // 存下包信息和设置信息</div><div class="line">        // Add the new setting to mSettings</div><div class="line">        mSettings.insertPackageSettingLPw(pkgSetting, pkg);</div><div class="line">        // Add the new setting to mPackages</div><div class="line">        mPackages.put(pkg.applicationInfo.packageName, pkg);</div><div class="line">        // 从mSettings.mPackagesToBeCleaned中移除当前包名,以防被误清除数据</div><div class="line">        // Make sure we don&apos;t accidentally delete its data.</div><div class="line">        final Iterator&lt;PackageCleanItem&gt; iter = mSettings.mPackagesToBeCleaned.iterator();</div><div class="line">        while (iter.hasNext()) &#123;</div><div class="line">            PackageCleanItem item = iter.next();</div><div class="line">            if (pkgName.equals(item.packageName)) &#123;</div><div class="line">                iter.remove();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 记录或更新安装时间戳</div><div class="line">        // Take care of first install / last update times.</div><div class="line">        if (currentTime != 0) &#123;</div><div class="line">            if (pkgSetting.firstInstallTime == 0) &#123;</div><div class="line">                pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;</div><div class="line">            &#125; else if ((scanFlags&amp;SCAN_UPDATE_TIME) != 0) &#123;</div><div class="line">                pkgSetting.lastUpdateTime = currentTime;</div><div class="line">            &#125;</div><div class="line">        &#125; else if (pkgSetting.firstInstallTime == 0) &#123;</div><div class="line">            // We need *something*.  Take time time stamp of the file.</div><div class="line">            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;</div><div class="line">        &#125; else if ((policyFlags&amp;PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123;</div><div class="line">            if (scanFileTime != pkgSetting.timeStamp) &#123;</div><div class="line">                // A package on the system image has changed; consider this</div><div class="line">                // to be an update.</div><div class="line">                pkgSetting.lastUpdateTime = scanFileTime;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Add the package&apos;s KeySets to the global KeySetManagerService</div><div class="line">        ksms.addScannedPackageLPw(pkg);</div><div class="line"></div><div class="line">        // 处理provider</div><div class="line">        int N = pkg.providers.size();</div><div class="line">        // 用来记录安装信息, 以便打log查看过程</div><div class="line">        StringBuilder r = null;</div><div class="line">        int i;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Provider p = pkg.providers.get(i);</div><div class="line">            p.info.processName = fixProcessName(pkg.applicationInfo.processName,</div><div class="line">                    p.info.processName, pkg.applicationInfo.uid);</div><div class="line">            mProviders.addProvider(p);</div><div class="line">            p.syncable = p.info.isSyncable;</div><div class="line">            if (p.info.authority != null) &#123;</div><div class="line">                String names[] = p.info.authority.split(&quot;;&quot;);</div><div class="line">                p.info.authority = null;</div><div class="line">                for (int j = 0; j &lt; names.length; j++) &#123;</div><div class="line">                    if (j == 1 &amp;&amp; p.syncable) &#123;</div><div class="line">                        // We only want the first authority for a provider to possibly be</div><div class="line">                        // syncable, so if we already added this provider using a different</div><div class="line">                        // authority clear the syncable flag. We copy the provider before</div><div class="line">                        // changing it because the mProviders object contains a reference</div><div class="line">                        // to a provider that we don&apos;t want to change.</div><div class="line">                        // Only do this for the second authority since the resulting provider</div><div class="line">                        // object can be the same for all future authorities for this provider.</div><div class="line">                        p = new PackageParser.Provider(p);</div><div class="line">                        p.syncable = false;</div><div class="line">                    &#125;</div><div class="line">                    if (!mProvidersByAuthority.containsKey(names[j])) &#123;</div><div class="line">                        mProvidersByAuthority.put(names[j], p);</div><div class="line">                        if (p.info.authority == null) &#123;</div><div class="line">                            p.info.authority = names[j];</div><div class="line">                        &#125; else &#123;</div><div class="line">                            p.info.authority = p.info.authority + &quot;;&quot; + names[j];</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        PackageParser.Provider other = mProvidersByAuthority.get(names[j]);</div><div class="line">                        Slog.w(TAG, &quot;Skipping provider name &quot; + names[j] +</div><div class="line">                                &quot; (in package &quot; + pkg.applicationInfo.packageName +</div><div class="line">                                &quot;): name already used by &quot;</div><div class="line">                                + ((other != null &amp;&amp; other.getComponentName() != null)</div><div class="line">                                        ? other.getComponentName().getPackageName() : &quot;?&quot;));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(p.info.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理service</div><div class="line">        N = pkg.services.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Service s = pkg.services.get(i);</div><div class="line">            s.info.processName = fixProcessName(pkg.applicationInfo.processName,</div><div class="line">                    s.info.processName, pkg.applicationInfo.uid);</div><div class="line">            mServices.addService(s);</div><div class="line">            if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(s.info.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理receiver</div><div class="line">        N = pkg.receivers.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Activity a = pkg.receivers.get(i);</div><div class="line">            a.info.processName = fixProcessName(pkg.applicationInfo.processName,</div><div class="line">                    a.info.processName, pkg.applicationInfo.uid);</div><div class="line">            mReceivers.addActivity(a, &quot;receiver&quot;);</div><div class="line">            if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(a.info.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理activity</div><div class="line">        N = pkg.activities.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Activity a = pkg.activities.get(i);</div><div class="line">            a.info.processName = fixProcessName(pkg.applicationInfo.processName,</div><div class="line">                    a.info.processName, pkg.applicationInfo.uid);</div><div class="line">            mActivities.addActivity(a, &quot;activity&quot;);</div><div class="line">            if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(a.info.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理permissionGroup权限组</div><div class="line">        N = pkg.permissionGroups.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i);</div><div class="line">            PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name);</div><div class="line">            if (cur == null) &#123;</div><div class="line">                mPermissionGroups.put(pg.info.name, pg);</div><div class="line">                if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                    if (r == null) &#123;</div><div class="line">                        r = new StringBuilder(256);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        r.append(&apos; &apos;);</div><div class="line">                    &#125;</div><div class="line">                    r.append(pg.info.name);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                Slog.w(TAG, &quot;Permission group &quot; + pg.info.name + &quot; from package &quot;</div><div class="line">                        + pg.info.packageName + &quot; ignored: original from &quot;</div><div class="line">                        + cur.info.packageName);</div><div class="line">                if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                    if (r == null) &#123;</div><div class="line">                        r = new StringBuilder(256);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        r.append(&apos; &apos;);</div><div class="line">                    &#125;</div><div class="line">                    r.append(&quot;DUP:&quot;);</div><div class="line">                    r.append(pg.info.name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理permission</div><div class="line">        N = pkg.permissions.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Permission p = pkg.permissions.get(i);</div><div class="line"></div><div class="line">            // Assume by default that we did not install this permission into the system.</div><div class="line">            p.info.flags &amp;= ~PermissionInfo.FLAG_INSTALLED;</div><div class="line"></div><div class="line">            // Now that permission groups have a special meaning, we ignore permission</div><div class="line">            // groups for legacy apps to prevent unexpected behavior. In particular,</div><div class="line">            // permissions for one app being granted to someone just becase they happen</div><div class="line">            // to be in a group defined by another app (before this had no implications).</div><div class="line">            if (pkg.applicationInfo.targetSdkVersion &gt; Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</div><div class="line">                p.group = mPermissionGroups.get(p.info.group);</div><div class="line">                // Warn for a permission in an unknown group.</div><div class="line">                if (p.info.group != null &amp;&amp; p.group == null) &#123;</div><div class="line">                    Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot;</div><div class="line">                            + p.info.packageName + &quot; in an unknown group &quot; + p.info.group);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ArrayMap&lt;String, BasePermission&gt; permissionMap =</div><div class="line">                    p.tree ? mSettings.mPermissionTrees</div><div class="line">                            : mSettings.mPermissions;</div><div class="line">            BasePermission bp = permissionMap.get(p.info.name);</div><div class="line"></div><div class="line">            // Allow system apps to redefine non-system permissions</div><div class="line">            if (bp != null &amp;&amp; !Objects.equals(bp.sourcePackage, p.info.packageName)) &#123;</div><div class="line">                final boolean currentOwnerIsSystem = (bp.perm != null</div><div class="line">                        &amp;&amp; isSystemApp(bp.perm.owner));</div><div class="line">                if (isSystemApp(p.owner)) &#123;</div><div class="line">                    if (bp.type == BasePermission.TYPE_BUILTIN &amp;&amp; bp.perm == null) &#123;</div><div class="line">                        // It&apos;s a built-in permission and no owner, take ownership now</div><div class="line">                        bp.packageSetting = pkgSetting;</div><div class="line">                        bp.perm = p;</div><div class="line">                        bp.uid = pkg.applicationInfo.uid;</div><div class="line">                        bp.sourcePackage = p.info.packageName;</div><div class="line">                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;</div><div class="line">                    &#125; else if (!currentOwnerIsSystem) &#123;</div><div class="line">                        String msg = &quot;New decl &quot; + p.owner + &quot; of permission  &quot;</div><div class="line">                                + p.info.name + &quot; is system; overriding &quot; + bp.sourcePackage;</div><div class="line">                        reportSettingsProblem(Log.WARN, msg);</div><div class="line">                        bp = null;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (bp == null) &#123;</div><div class="line">                bp = new BasePermission(p.info.name, p.info.packageName,</div><div class="line">                        BasePermission.TYPE_NORMAL);</div><div class="line">                permissionMap.put(p.info.name, bp);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (bp.perm == null) &#123;</div><div class="line">                if (bp.sourcePackage == null</div><div class="line">                        || bp.sourcePackage.equals(p.info.packageName)) &#123;</div><div class="line">                    BasePermission tree = findPermissionTreeLP(p.info.name);</div><div class="line">                    if (tree == null</div><div class="line">                            || tree.sourcePackage.equals(p.info.packageName)) &#123;</div><div class="line">                        bp.packageSetting = pkgSetting;</div><div class="line">                        bp.perm = p;</div><div class="line">                        bp.uid = pkg.applicationInfo.uid;</div><div class="line">                        bp.sourcePackage = p.info.packageName;</div><div class="line">                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;</div><div class="line">                        if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                            if (r == null) &#123;</div><div class="line">                                r = new StringBuilder(256);</div><div class="line">                            &#125; else &#123;</div><div class="line">                                r.append(&apos; &apos;);</div><div class="line">                            &#125;</div><div class="line">                            r.append(p.info.name);</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot;</div><div class="line">                                + p.info.packageName + &quot; ignored: base tree &quot;</div><div class="line">                                + tree.name + &quot; is from package &quot;</div><div class="line">                                + tree.sourcePackage);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    Slog.w(TAG, &quot;Permission &quot; + p.info.name + &quot; from package &quot;</div><div class="line">                            + p.info.packageName + &quot; ignored: original from &quot;</div><div class="line">                            + bp.sourcePackage);</div><div class="line">                &#125;</div><div class="line">            &#125; else if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(&quot;DUP:&quot;);</div><div class="line">                r.append(p.info.name);</div><div class="line">            &#125;</div><div class="line">            if (bp.perm == p) &#123;</div><div class="line">                bp.protectionLevel = p.info.protectionLevel;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 处理instrumentation</div><div class="line">        N = pkg.instrumentation.size();</div><div class="line">        r = null;</div><div class="line">        for (i=0; i&lt;N; i++) &#123;</div><div class="line">            PackageParser.Instrumentation a = pkg.instrumentation.get(i);</div><div class="line">            a.info.packageName = pkg.applicationInfo.packageName;</div><div class="line">            a.info.sourceDir = pkg.applicationInfo.sourceDir;</div><div class="line">            a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;</div><div class="line">            a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;</div><div class="line">            a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;</div><div class="line">            a.info.dataDir = pkg.applicationInfo.dataDir;</div><div class="line">            a.info.deviceProtectedDataDir = pkg.applicationInfo.deviceProtectedDataDir;</div><div class="line">            a.info.credentialProtectedDataDir = pkg.applicationInfo.credentialProtectedDataDir;</div><div class="line"></div><div class="line">            a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;</div><div class="line">            a.info.secondaryNativeLibraryDir = pkg.applicationInfo.secondaryNativeLibraryDir;</div><div class="line">            mInstrumentation.put(a.getComponentName(), a);</div><div class="line">            if ((policyFlags&amp;PackageParser.PARSE_CHATTY) != 0) &#123;</div><div class="line">                if (r == null) &#123;</div><div class="line">                    r = new StringBuilder(256);</div><div class="line">                &#125; else &#123;</div><div class="line">                    r.append(&apos; &apos;);</div><div class="line">                &#125;</div><div class="line">                r.append(a.info.name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (pkg.protectedBroadcasts != null) &#123;</div><div class="line">            N = pkg.protectedBroadcasts.size();</div><div class="line">            for (i=0; i&lt;N; i++) &#123;</div><div class="line">                mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 设置时间戳为扫描文件的时间戳</div><div class="line">        pkgSetting.setTimeStamp(scanFileTime);</div><div class="line"></div><div class="line">        // 创建idmap文件</div><div class="line">        // Create idmap files for pairs of (packages, overlay packages).</div><div class="line">        // Note: &quot;android&quot;, ie framework-res.apk, is handled by native layers.</div><div class="line">        if (pkg.mOverlayTarget != null) &#123;</div><div class="line">            // This is an overlay package.</div><div class="line">            if (pkg.mOverlayTarget != null &amp;&amp; !pkg.mOverlayTarget.equals(&quot;android&quot;)) &#123;</div><div class="line">                if (!mOverlays.containsKey(pkg.mOverlayTarget)) &#123;</div><div class="line">                    mOverlays.put(pkg.mOverlayTarget,</div><div class="line">                            new ArrayMap&lt;String, PackageParser.Package&gt;());</div><div class="line">                &#125;</div><div class="line">                ArrayMap&lt;String, PackageParser.Package&gt; map = mOverlays.get(pkg.mOverlayTarget);</div><div class="line">                map.put(pkg.packageName, pkg);</div><div class="line">                PackageParser.Package orig = mPackages.get(pkg.mOverlayTarget);</div><div class="line">                if (orig != null &amp;&amp; !createIdmapForPackagePairLI(orig, pkg)) &#123;</div><div class="line">                    createIdmapFailed = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else if (mOverlays.containsKey(pkg.packageName) &amp;&amp;</div><div class="line">                !pkg.packageName.equals(&quot;android&quot;)) &#123;</div><div class="line">            // This is a regular package, with one or more known overlay packages.</div><div class="line">            createIdmapsForPackageLI(pkg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</div><div class="line"></div><div class="line">    if (createIdmapFailed) &#123;</div><div class="line">        throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE,</div><div class="line">                &quot;scanPackageLI failed to createIdmap&quot;);</div><div class="line">    &#125;</div><div class="line">    return pkg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="安装后目录结构"><a href="#安装后目录结构" class="headerlink" title="安装后目录结构"></a>安装后目录结构</h2><p>安装后目录结构如下:  </p>
<table>
<thead>
<tr>
<th style="text-align:left">目录</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/data/app</td>
<td style="text-align:left">第三方应用apk文件</td>
</tr>
<tr>
<td style="text-align:left">/data/anr</td>
<td style="text-align:left">存放anr信息</td>
</tr>
<tr>
<td style="text-align:left">/data/data</td>
<td style="text-align:left">应用程序数据</td>
</tr>
<tr>
<td style="text-align:left">/data/data/${package_name}</td>
<td style="text-align:left">特定应用程序数据目录</td>
</tr>
<tr>
<td style="text-align:left">cache</td>
<td style="text-align:left">临时文件，系统会自动清理</td>
</tr>
<tr>
<td style="text-align:left">databases</td>
<td style="text-align:left">数据库</td>
</tr>
<tr>
<td style="text-align:left">files</td>
<td style="text-align:left">一般文件</td>
</tr>
<tr>
<td style="text-align:left">shared_pres</td>
<td style="text-align:left">SharedPreference</td>
</tr>
<tr>
<td style="text-align:left">lib</td>
<td style="text-align:left">so文件</td>
</tr>
<tr>
<td style="text-align:left">/data/dalvik-cache</td>
<td style="text-align:left">存放odex文件</td>
</tr>
<tr>
<td style="text-align:left">/data/system/packages.list</td>
<td style="text-align:left">从AndroidManifest.xml提取的信息</td>
</tr>
<tr>
<td style="text-align:left">/data/system/packages.xml</td>
<td style="text-align:left">从AndroidManifest.xml提取的信息</td>
</tr>
<tr>
<td style="text-align:left">/data/user/0</td>
<td style="text-align:left">软链接，指向/data/data</td>
</tr>
<tr>
<td style="text-align:left">/data/user_de/0/${package_name}</td>
<td style="text-align:left">设备存储保护区，在快速启动模式可以访问这个文件夹</td>
</tr>
<tr>
<td style="text-align:left">/proc/cpuinfo</td>
<td style="text-align:left">cpu信息</td>
</tr>
<tr>
<td style="text-align:left">/proc/smaps</td>
<td style="text-align:left">内存占用信息</td>
</tr>
<tr>
<td style="text-align:left">/sdcard</td>
<td style="text-align:left">软链接，最终指向/storage/emulated/0【跟Android版本和ROM版本有关】</td>
</tr>
<tr>
<td style="text-align:left">/storage/emulated/0</td>
<td style="text-align:left">外部存储的根目录</td>
</tr>
<tr>
<td style="text-align:left">/storage/emulated/0/Android/data/${package_name}</td>
<td style="text-align:left">应用的额外数据</td>
</tr>
<tr>
<td style="text-align:left">/system/app</td>
<td style="text-align:left">系统应用apk文件</td>
</tr>
<tr>
<td style="text-align:left">/system/lib</td>
<td style="text-align:left">系统应用so库</td>
</tr>
</tbody>
</table>
<h2 id="Apk卸载"><a href="#Apk卸载" class="headerlink" title="Apk卸载"></a>Apk卸载</h2><p>卸载是安装的逆过程, 所以其实还比较好理解, 无非就是安装了啥就去掉啥, 不留下一片云彩. 它调用的函数是<code>deletePackageAsUser</code>, 同样位于<code>/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>. 代码如下(需要注意, 卸载的源码在7.0以上和7.0以下差别较大, 如前所述, 本文基于7.0源码):  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div></pre></td><td class="code"><pre><div class="line">// 位于frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</div><div class="line"></div><div class="line">public void deletePackageAsUser(String packageName, IPackageDeleteObserver observer, int userId,</div><div class="line">        int flags) &#123;</div><div class="line">    deletePackage(packageName, new LegacyPackageDeleteObserver(observer).getBinder(), userId,</div><div class="line">            flags);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void deletePackage(final String packageName,</div><div class="line">        final IPackageDeleteObserver2 observer, final int userId, final int deleteFlags) &#123;</div><div class="line">    // 检查权限</div><div class="line">    mContext.enforceCallingOrSelfPermission(</div><div class="line">            android.Manifest.permission.DELETE_PACKAGES, null);</div><div class="line">    // 不解释</div><div class="line">    Preconditions.checkNotNull(packageName);</div><div class="line">    Preconditions.checkNotNull(observer);</div><div class="line">    // 用户权限检查</div><div class="line">    final int uid = Binder.getCallingUid();</div><div class="line">    final boolean deleteAllUsers = (deleteFlags &amp; PackageManager.DELETE_ALL_USERS) != 0;</div><div class="line">    final int[] users = deleteAllUsers ? sUserManager.getUserIds() : new int[]&#123; userId &#125;;</div><div class="line">    if (UserHandle.getUserId(uid) != userId || (deleteAllUsers &amp;&amp; users.length &gt; 1)) &#123;</div><div class="line">        mContext.enforceCallingOrSelfPermission(</div><div class="line">                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL,</div><div class="line">                &quot;deletePackage for user &quot; + userId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (isUserRestricted(userId, UserManager.DISALLOW_UNINSTALL_APPS)) &#123;</div><div class="line">        try &#123;</div><div class="line">            observer.onPackageDeleted(packageName,</div><div class="line">                    PackageManager.DELETE_FAILED_USER_RESTRICTED, null);</div><div class="line">        &#125; catch (RemoteException re) &#123;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!deleteAllUsers &amp;&amp; getBlockUninstallForUser(packageName, userId)) &#123;</div><div class="line">        try &#123;</div><div class="line">            observer.onPackageDeleted(packageName,</div><div class="line">                    PackageManager.DELETE_FAILED_OWNER_BLOCKED, null);</div><div class="line">        &#125; catch (RemoteException re) &#123;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Queue up an async operation since the package deletion may take a little while.</div><div class="line">    // 抛入线程处理卸载</div><div class="line">    mHandler.post(new Runnable() &#123;</div><div class="line">        public void run() &#123;</div><div class="line">            mHandler.removeCallbacks(this);</div><div class="line">            int returnCode;</div><div class="line">            if (!deleteAllUsers) &#123;</div><div class="line">                // 按用户来卸载包</div><div class="line">                returnCode = deletePackageX(packageName, userId, deleteFlags);</div><div class="line">            &#125; else &#123;</div><div class="line">                int[] blockUninstallUserIds = getBlockUninstallForUsers(packageName, users);</div><div class="line">                // If nobody is blocking uninstall, proceed with delete for all users</div><div class="line">                if (ArrayUtils.isEmpty(blockUninstallUserIds)) &#123;</div><div class="line">                    returnCode = deletePackageX(packageName, userId, deleteFlags);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Otherwise uninstall individually for users with blockUninstalls=false</div><div class="line">                    // 有部分用户阻止卸载, 只对不阻止的用户执行卸载</div><div class="line">                    final int userFlags = deleteFlags &amp; ~PackageManager.DELETE_ALL_USERS;</div><div class="line">                    for (int userId : users) &#123;</div><div class="line">                        if (!ArrayUtils.contains(blockUninstallUserIds, userId)) &#123;</div><div class="line">                            returnCode = deletePackageX(packageName, userId, userFlags);</div><div class="line">                            if (returnCode != PackageManager.DELETE_SUCCEEDED) &#123;</div><div class="line">                                Slog.w(TAG, &quot;Package delete failed for user &quot; + userId</div><div class="line">                                        + &quot;, returnCode &quot; + returnCode);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // The app has only been marked uninstalled for certain users.</div><div class="line">                    // We still need to report that delete was blocked</div><div class="line">                    returnCode = PackageManager.DELETE_FAILED_OWNER_BLOCKED;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                observer.onPackageDeleted(packageName, returnCode, null);</div><div class="line">            &#125; catch (RemoteException e) &#123;</div><div class="line">                Log.i(TAG, &quot;Observer no longer exists.&quot;);</div><div class="line">            &#125; //end catch</div><div class="line">        &#125; //end run</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private int deletePackageX(String packageName, int userId, int deleteFlags) &#123;</div><div class="line">    final PackageRemovedInfo info = new PackageRemovedInfo();</div><div class="line">    final boolean res;</div><div class="line"></div><div class="line">    final int removeUser = (deleteFlags &amp; PackageManager.DELETE_ALL_USERS) != 0</div><div class="line">            ? UserHandle.USER_ALL : userId;</div><div class="line">    // 有活动的管理员则不允许删除</div><div class="line">    if (isPackageDeviceAdmin(packageName, removeUser)) &#123;</div><div class="line">        Slog.w(TAG, &quot;Not removing package &quot; + packageName + &quot;: has active device admin&quot;);</div><div class="line">        return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PackageSetting uninstalledPs = null;</div><div class="line"></div><div class="line">    // for the uninstall-updates case and restricted profiles, remember the per-</div><div class="line">    // user handle installed state</div><div class="line">    int[] allUsers;</div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        // 在mPackages里面查找对应的PackageSettings</div><div class="line">        uninstalledPs = mSettings.mPackages.get(packageName);</div><div class="line">        if (uninstalledPs == null) &#123;</div><div class="line">            Slog.w(TAG, &quot;Not removing non-existent package &quot; + packageName);</div><div class="line">            return PackageManager.DELETE_FAILED_INTERNAL_ERROR;</div><div class="line">        &#125;</div><div class="line">        allUsers = sUserManager.getUserIds();</div><div class="line">        info.origUsers = uninstalledPs.queryInstalledUsers(allUsers, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 冻结用户</div><div class="line">    final int freezeUser;</div><div class="line">    if (isUpdatedSystemApp(uninstalledPs)</div><div class="line">            &amp;&amp; ((deleteFlags &amp; PackageManager.DELETE_SYSTEM_APP) == 0)) &#123;</div><div class="line">        // We&apos;re downgrading a system app, which will apply to all users, so</div><div class="line">        // freeze them all during the downgrade</div><div class="line">        freezeUser = UserHandle.USER_ALL;</div><div class="line">    &#125; else &#123;</div><div class="line">        freezeUser = removeUser;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (mInstallLock) &#123;</div><div class="line">        try (PackageFreezer freezer = freezePackageForDelete(packageName, freezeUser,</div><div class="line">                deleteFlags, &quot;deletePackageX&quot;)) &#123;</div><div class="line">            res = deletePackageLIF(packageName, UserHandle.of(removeUser), true, allUsers,</div><div class="line">                    deleteFlags | REMOVE_CHATTY, info, true, null);</div><div class="line">        &#125;</div><div class="line">        synchronized (mPackages) &#123;</div><div class="line">            if (res) &#123;</div><div class="line">                mEphemeralApplicationRegistry.onPackageUninstalledLPw(uninstalledPs.pkg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 发送广播</div><div class="line">    if (res) &#123;</div><div class="line">        final boolean killApp = (deleteFlags &amp; PackageManager.DELETE_DONT_KILL_APP) == 0;</div><div class="line">        info.sendPackageRemovedBroadcasts(killApp);</div><div class="line">        info.sendSystemPackageUpdatedBroadcasts();</div><div class="line">        info.sendSystemPackageAppearedBroadcasts();</div><div class="line">    &#125;</div><div class="line">    // Force a gc here.</div><div class="line">    // 强制gc</div><div class="line">    Runtime.getRuntime().gc();</div><div class="line">    // Delete the resources here after sending the broadcast to let</div><div class="line">    // other processes clean up before deleting resources.</div><div class="line">    if (info.args != null) &#123;</div><div class="line">        synchronized (mInstallLock) &#123;</div><div class="line">            info.args.doPostDeleteLI(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean deletePackageLIF(String packageName, UserHandle user,</div><div class="line">        boolean deleteCodeAndResources, int[] allUserHandles, int flags,</div><div class="line">        PackageRemovedInfo outInfo, boolean writeSettings,</div><div class="line">        PackageParser.Package replacingPackage) &#123;</div><div class="line">    if (packageName == null) &#123;</div><div class="line">        Slog.w(TAG, &quot;Attempt to delete null packageName.&quot;);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    PackageSetting ps;</div><div class="line"></div><div class="line">    synchronized (mPackages) &#123;</div><div class="line">        ps = mSettings.mPackages.get(packageName);</div><div class="line">        if (ps == null) &#123;</div><div class="line">            Slog.w(TAG, &quot;Package named &apos;&quot; + packageName + &quot;&apos; doesn&apos;t exist.&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 删除非系统子包</div><div class="line">        if (ps.parentPackageName != null &amp;&amp; (!isSystemApp(ps)</div><div class="line">                || (flags &amp; PackageManager.DELETE_SYSTEM_APP) != 0)) &#123;</div><div class="line">            final int removedUserId = (user != null) ? user.getIdentifier()</div><div class="line">                    : UserHandle.USER_ALL;</div><div class="line">            if (!clearPackageStateForUserLIF(ps, removedUserId, outInfo)) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            markPackageUninstalledForUserLPw(ps, user);</div><div class="line">            scheduleWritePackageRestrictionsLocked(user);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 对特定用户删除非系统包</div><div class="line">    if (((!isSystemApp(ps) || (flags&amp;PackageManager.DELETE_SYSTEM_APP) != 0) &amp;&amp; user != null</div><div class="line">            &amp;&amp; user.getIdentifier() != UserHandle.USER_ALL)) &#123;</div><div class="line">        // The caller is asking that the package only be deleted for a single</div><div class="line">        // user.  To do this, we just mark its uninstalled state and delete</div><div class="line">        // its data. If this is a system app, we only allow this to happen if</div><div class="line">        // they have set the special DELETE_SYSTEM_APP which requests different</div><div class="line">        // semantics than normal for uninstalling system apps.</div><div class="line">        markPackageUninstalledForUserLPw(ps, user);</div><div class="line"></div><div class="line">        if (!isSystemApp(ps)) &#123;</div><div class="line">            // 非系统包</div><div class="line">            // Do not uninstall the APK if an app should be cached</div><div class="line">            boolean keepUninstalledPackage = shouldKeepUninstalledPackageLPr(packageName);</div><div class="line">            if (ps.isAnyInstalled(sUserManager.getUserIds()) || keepUninstalledPackage) &#123;</div><div class="line">                // 有用户安装或者需要保存已卸载的包</div><div class="line">                // Other user still have this package installed, so all</div><div class="line">                // we need to do is clear this user&apos;s data and save that</div><div class="line">                // it is uninstalled.</div><div class="line">                // 清除数据, 将&quot;该包已被该用户卸载&quot;的信息记录下来.</div><div class="line">                if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123;</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line">                scheduleWritePackageRestrictionsLocked(user);</div><div class="line">                return true;</div><div class="line">            &#125; else &#123;</div><div class="line">                // We need to set it back to &apos;installed&apos; so the uninstall</div><div class="line">                // broadcasts will be sent correctly.</div><div class="line">                ps.setInstalled(true, user.getIdentifier());</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            // This is a system app, so we assume that the</div><div class="line">            // other users still have this package installed, so all</div><div class="line">            // we need to do is clear this user&apos;s data and save that</div><div class="line">            // it is uninstalled.</div><div class="line">            if (DEBUG_REMOVE) Slog.d(TAG, &quot;Deleting system app&quot;);</div><div class="line">            if (!clearPackageStateForUserLIF(ps, user.getIdentifier(), outInfo)) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            scheduleWritePackageRestrictionsLocked(user);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 处理子包问题</div><div class="line">    // If we are deleting a composite package for all users, keep track</div><div class="line">    // of result for each child.</div><div class="line">    if (ps.childPackageNames != null &amp;&amp; outInfo != null) &#123;</div><div class="line">        synchronized (mPackages) &#123;</div><div class="line">            final int childCount = ps.childPackageNames.size();</div><div class="line">            outInfo.removedChildPackages = new ArrayMap&lt;&gt;(childCount);</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                String childPackageName = ps.childPackageNames.get(i);</div><div class="line">                PackageRemovedInfo childInfo = new PackageRemovedInfo();</div><div class="line">                childInfo.removedPackage = childPackageName;</div><div class="line">                outInfo.removedChildPackages.put(childPackageName, childInfo);</div><div class="line">                PackageSetting childPs = mSettings.peekPackageLPr(childPackageName);</div><div class="line">                if (childPs != null) &#123;</div><div class="line">                    childInfo.origUsers = childPs.queryInstalledUsers(allUserHandles, true);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean ret = false;</div><div class="line">    if (isSystemApp(ps)) &#123;</div><div class="line">        // 系统应用的卸载实际上是清除数据并回退到系统自带的版本</div><div class="line">        // When an updated system application is deleted we delete the existing resources</div><div class="line">        // as well and fall back to existing code in system partition</div><div class="line">        ret = deleteSystemPackageLIF(ps.pkg, ps, allUserHandles, flags, outInfo, writeSettings);</div><div class="line">    &#125; else &#123;</div><div class="line">        ret = deleteInstalledPackageLIF(ps, deleteCodeAndResources, flags, allUserHandles,</div><div class="line">                outInfo, writeSettings, replacingPackage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Take a note whether we deleted the package for all users</div><div class="line">    if (outInfo != null) &#123;</div><div class="line">        outInfo.removedForAllUsers = mPackages.get(ps.name) == null;</div><div class="line">        if (outInfo.removedChildPackages != null) &#123;</div><div class="line">            synchronized (mPackages) &#123;</div><div class="line">                final int childCount = outInfo.removedChildPackages.size();</div><div class="line">                for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                    PackageRemovedInfo childInfo = outInfo.removedChildPackages.valueAt(i);</div><div class="line">                    if (childInfo != null) &#123;</div><div class="line">                        childInfo.removedForAllUsers = mPackages.get(</div><div class="line">                                childInfo.removedPackage) == null;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // If we uninstalled an update to a system app there may be some</div><div class="line">        // child packages that appeared as they are declared in the system</div><div class="line">        // app but were not declared in the update.</div><div class="line">        if (isSystemApp(ps)) &#123;</div><div class="line">            synchronized (mPackages) &#123;</div><div class="line">                PackageSetting updatedPs = mSettings.peekPackageLPr(ps.name);</div><div class="line">                final int childCount = (updatedPs.childPackageNames != null)</div><div class="line">                        ? updatedPs.childPackageNames.size() : 0;</div><div class="line">                for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                    String childPackageName = updatedPs.childPackageNames.get(i);</div><div class="line">                    if (outInfo.removedChildPackages == null</div><div class="line">                            || outInfo.removedChildPackages.indexOfKey(childPackageName) &lt; 0) &#123;</div><div class="line">                        PackageSetting childPs = mSettings.peekPackageLPr(childPackageName);</div><div class="line">                        if (childPs == null) &#123;</div><div class="line">                            continue;</div><div class="line">                        &#125;</div><div class="line">                        PackageInstalledInfo installRes = new PackageInstalledInfo();</div><div class="line">                        installRes.name = childPackageName;</div><div class="line">                        installRes.newUsers = childPs.queryInstalledUsers(allUserHandles, true);</div><div class="line">                        installRes.pkg = mPackages.get(childPackageName);</div><div class="line">                        installRes.uid = childPs.pkg.applicationInfo.uid;</div><div class="line">                        if (outInfo.appearedChildPackages == null) &#123;</div><div class="line">                            outInfo.appearedChildPackages = new ArrayMap&lt;&gt;();</div><div class="line">                        &#125;</div><div class="line">                        outInfo.appearedChildPackages.put(childPackageName, installRes);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://chaman.gitbooks.io/techblog/Android/apk-install-uninstall/apk-install-uninstall.html" target="_blank" rel="external">Android APK安装与卸载机制</a><br><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java" target="_blank" rel="external">Android PackageManagerService源码</a>  </p>
]]></content>
    
    <summary type="html">
    
      写多了业务逻辑, 咱们来看看系统的&quot;业务逻辑&quot;.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>消息机制之select-poll-epoll-兼谈同步异步&amp;阻塞非阻塞</title>
    <link href="https://hjhjw1991.github.io/android/2017/08/03/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E4%B9%8Bselect-poll-epoll-%E5%85%BC%E8%B0%88%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5&amp;%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://hjhjw1991.github.io/android/2017/08/03/消息机制之select-poll-epoll-兼谈同步异步&amp;阻塞非阻塞/</id>
    <published>2017-08-02T16:00:00.000Z</published>
    <updated>2017-08-03T09:15:07.239Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是我今年4月28号的工作周记, 我偷懒就直接拿过来了.  </p>
<h2 id="20170428周记"><a href="#20170428周记" class="headerlink" title="20170428周记"></a>20170428周记</h2><p>在极困的状态下学习了同步/异步, 阻塞/非阻塞的概念, 以及select/poll/epoll的概念. 复习了一下Binder机制中数据传输的原理.  </p>
<p>同步/异步, 阻塞/非阻塞容易混淆的原因就在于两者都涉及一个等待/非等待的状态.<br>先来讲何为同步/异步.<br>这对术语描述的是<strong>通信的方式</strong>, 即通信的一方在发送下一次消息前, 是否等待另一方返回消息, 等待则为同步, 不等待则为异步.<br>举个例子, 你打电话给携程问后天是否有到某地的特价机票, 携程客服说”你稍等我查一下”, 这期间你们俩都没挂电话, 等他查好了(可能几分钟也可能几天)告诉你结果. 这是同步.<br>客服说”我查一下, 查好了回你电话”然后他就挂电话了, 等查好了他就主动打给你. 这是异步.<br>注意, 所谓”等待”并不一定是什么都不做的”空等”.  </p>
<p>阻塞/非阻塞关注的是在等待结果的时候<strong>程序的状态</strong>. 如果结果返回前, 程序被挂起, 则是阻塞, 否则非阻塞.<br>还是上面的例子, 如果你是阻塞式打电话, 无论客服是不是异步给你结果, 你都会在电话旁一直等着, 直到客服给你结果, 这期间你什么都不能做. 如果你是非阻塞式的, 那你打完电话(发起调用)之后, 如果客服没有立即给你结果, 你可以自己爱做啥做啥, 只需要时不时回来检查一下客服是不是给你结果了或者他是不是回电了.<br>所以其实阻塞/非阻塞, 跟异步/同步是两个完全无关的概念. 但是由于异步这个概念指的就是程序不等待返回结果, 所以异步一定是非阻塞的(当然, 你也可以把它”实现为阻塞”, 只不过这样做就失去了选择异步的意义, 从表现上跟”同步阻塞”无异).  </p>
<p>好了, 下面来说select/poll/epoll.<br>这三个操作是linux系统的系统命令, 他们都属于I/O多路复用的实现. 他们都是同步I/O.<br>同步I/O操作, 指的是该操作会导致请求进程阻塞, 直到I/O操作完成. 异步I/O操作不导致请求进程阻塞. 我觉得这两个概念也是造成混淆的原因之一, 其实只要明白这里所说的阻塞/非阻塞, 跟编程语言层次(Java NIO)所说的阻塞/非阻塞, 所描述的不是同一个现象. 在NIO中, 也存在阻塞的过程(Selector.select()).<br>I/O多路复用的意思是, 用多个文件描述符同时服务多个I/O过程, 有任一一个处于就绪状态时就触发对应I/O过程继续执行, 整个过程用同一个进程来管理, 而不是每个I/O都自己新建一个进程.<br>区分同步/异步的方式很简单, 由于异步是注册一个回调, 让系统自动调用回调函数处理, 所以请求进程在发起请求后几乎不需要参与后续工作. 所以相对来说, 如果发起请求后, 请求进程需要通过某种方式(死循环轮询, 停下来等待, 抑或在子线程中做类似操作)去获知是否有返回结果并<strong>主动处理返回结果</strong>, 那就不是异步, 而是同步.  </p>
<p>select, 就是在轮询所有注册的文件描述符, 直到有描述符就绪或操作超时, 才会返回. 由于它需要轮询所有文件描述符, 所以性能随文件描述符增多呈线性负相关.<br>poll定义了一个不同的数据结构用来表示I/O时的文件描述符, 等待的事件和实际返回的事件. 其余过程本质上和select相同, 也是轮询所有文件描述符来获得就绪状态的描述符.<br>epoll是在2.6的linux内核中加入的, 它不再是轮询所有文件描述符, 而是以回调的方式, 在文件描述符处于就绪状态后, <code>epoll_ctl</code>回调事先注册好的处理函数, 将就绪的文件描述符加入到就绪队列中, 并发出就绪通知, 而<code>epoll_wait</code>调用时会在参数中指明需要等待哪个文件描述符上的什么事件, 它去检查就绪队列并返回需要处理的事件数量, 所以整个过程的效率只与活跃的文件描述符数量有关, 在高并发的情况下优于select和poll. 同时, 它使用mmap让用户空间可以直接访问到内核空间写入的数据区域, 因此少了一次内核空间到用户空间的拷贝.  </p>
<p>binder的底层调用的是epoll.  </p>
]]></content>
    
    <summary type="html">
    
      这篇是我今年4月28号的工作周记, 我偷懒就直接拿过来了.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="linux" scheme="https://hjhjw1991.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IntentService什么鬼</title>
    <link href="https://hjhjw1991.github.io/android/2017/08/03/IntentService%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <id>https://hjhjw1991.github.io/android/2017/08/03/IntentService什么鬼/</id>
    <published>2017-08-02T16:00:00.000Z</published>
    <updated>2017-08-03T04:09:41.479Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇进不了花样劝退系列, 因为非常浅显, 就是一个为特定的常用场景而诞生的类.  </p>
<p>我们常常会有这样的需求: 需要执行一个任务, 而这个任务可能跟我们主线程要做的事情无关, 完全可以异步执行, 并且它还有可能很耗时而不能在主线程做.<br>这种情况非常常见, 例如开始一个下载任务, 或者开启一个定时任务. 我们自己来做的话会怎么做呢? 通常是自行实现一个工作线程<code>WorkerThread</code>(当然你可以用<code>ExecutorService</code>生成一个线程池来帮你构造线程), 然后将任务扔给这个线程的工作队列, 这个线程则永不知疲倦地处理扔给它的所有任务.<br>显然这是个具有固定结构的编程模式, 意味着它完全可以提取出来成为公共库. 事实上线程池就是这么一个公共库, 但是在<code>Android</code>中可以更简单, 因为<code>Android</code>中有一个用于传递数据信息的数据结构<code>Intent</code>, 这意味着你不需要太过操心怎么传递数据. <code>IntentService</code>就是这么一个”工作线程”, 它依托于<code>Service</code>的基本结构, 使用<code>Intent</code>作为传递任务的信使.<br>顺便一提, 如果你只是临时想要执行一个任务, 那么<code>AsyncTask</code>可能会更合适.  </p>
<h2 id="IntentService用法"><a href="#IntentService用法" class="headerlink" title="IntentService用法"></a>IntentService用法</h2><p>用法非常简单, 它是一个抽象类, 所以你只需要实现自己的子类, 实现下面列表中的抽象方法即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 队列中每个Intent在处理时会调用本方法进行处理, 该方法运行在一个独立的工作线程上. 如果这个方法运行时间过长, 它会阻塞同个IntentService的后续请求. 所有队列中的请求处理完毕后, IntentService会自行停止, 所以无需再调用stopSelf</div><div class="line">// Intent是通过startService(Intent)传进来到请求队列的</div><div class="line">protected abstract void onHandleIntent(Intent intent);</div></pre></td></tr></table></figure></p>
<p>然后你就可以使用<code>startService</code>或者<code>bindService</code>来启动或绑定服务.  </p>
<p><code>IntentService</code>的开始和普通<code>Service</code>相同, <code>IntentService</code>自己会处理好<code>Service</code>何时停止, 具体来说工作线程无任务时服务就会停止.  </p>
<h2 id="IntentService工作原理"><a href="#IntentService工作原理" class="headerlink" title="IntentService工作原理"></a>IntentService工作原理</h2><p>如上文所述, <code>IntentService</code>就是把”异步任务处理器”这种模型以<code>Service</code>的形式实现的一个类. 从源码类的注释我们可以知道, 它自己实现了一个工作队列, 用的是<code>Handler</code>机制.<br>具体来说, 它为自己创建了一个<code>HandlerThread</code>线程, 这个线程里面会准备好自己的<code>Looper</code>队列. 它为自己创建了一个<code>ServiceHandler</code>内部类实例, 传入线程的<code>Looper</code>作为消息队列.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// in android/app/IntentService.java</div><div class="line">@Override</div><div class="line">public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ServiceHandler</code>是个<code>final</code>类, 在<code>handleMessage</code>中调用<code>onHandleIntent</code>来处理<code>Intent</code>, 消息处理完后立即调用<code>stopSelf</code>看是否需要停止服务. 它也在<code>onStart</code>中将传入的<code>Intent</code>发送到消息队列.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// in android/app/IntentService.java</div><div class="line">private final class ServiceHandler extends Handler &#123;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        onHandleIntent((Intent)msg.obj); // 回调接口</div><div class="line">        stopSelf(msg.arg1); // 尝试停止服务</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void onStart(Intent intent, int startId) &#123;</div><div class="line">    Message msg = mServiceHandler.obtainMessage();</div><div class="line">    msg.arg1 = startId; // 记录Id</div><div class="line">    msg.obj = intent; // 传递Intent</div><div class="line">    mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到<code>IntentService</code>提供了默认实现来处理<code>Service</code>停止的生命周期, 工作线程和队列的创建和消息传递. 因此在扩展实现<code>IntentService</code>的时候, 如果不想自己处理这些过程, 最好在重写方法时调用超类同名方法(<code>onBind</code>和<code>onHandleIntent</code>除外).  </p>
<p>这个类的分析到这里就没了, 实在是庞大Android源码库中一股清流.  </p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://code.tutsplus.com/tutorials/android-fundamentals-intentservice-basics--mobile-6183" target="_blank" rel="external">Android Fundamentals: IntentService Basics</a><br><a href="http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/app/IntentService.java" target="_blank" rel="external">source code</a>  </p>
]]></content>
    
    <summary type="html">
    
      今天这篇进不了花样劝退系列, 因为非常浅显, 就是一个为特定的常用场景而...
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Executor框架</title>
    <link href="https://hjhjw1991.github.io/blog/2017/08/02/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>https://hjhjw1991.github.io/blog/2017/08/02/Executor框架/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2018-06-04T10:26:45.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>concurrent包是java提供的并发编程工具，从Java 5开始引入了Executor框架辅助实现并发编程，通过它控制线程的启动、执行和关闭，通常比使用Thread的start方法好。<br>Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。<br>使用它而不是Thread的好处是，它已经实现了一个线程池，可以以更节省资源的方式使用线程，它设计的接口可以较方便地管理线程。<br>Executor接口之中只定义了一个方法，即<code>void execute(Runnable command)</code>方法，大量注释用于描述它存在的意义和设计思想。ExecutorService继承自它，提供了更丰富的多线程接口，例如提供了关闭自己的方法<code>shutdown</code>，调用它可以平滑地关闭ExecutorService，所谓平滑就是调用方法后ExecutorService不再接受新的任务，并等待已经提交的任务（正在执行的和尚未开始的）完成，然后关闭ExecutorService。一般使用这个接口来实现和管理多线程。  </p>
<p>ExecutorService的生命周期包括三种状态：运行，关闭，终止。创建后就进入运行状态，除非调用shutdown方法否则一直会处于运行状态。在调用shutdown方法之后会进入关闭状态，此时不再接受新任务，当已经提交的任务完成后就进入终止状态。Executors是一个工厂方法和工具方法集合，提供了创建线程池的工厂方法，可以返回实现了ExecutorSerivce接口的线程池，具体见<code>Executors.java</code>代码。下面介绍四个典型类型的线程池：</p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads)
// 创建固定线程数目的线程池

public static ExecutorService newCachedThreadPool()
// 创建可缓存的线程池。调用execute方法时会重用以前构造的可用的线程，如果没有则创建新的并加入线程池中，同时终止并移除线程池中60秒没有使用的线程

public static ExecutorService newSingleThreadExecutor()
// 创建一个单线程化的Executor，等同于newFixedThreadPool(1)

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
// 创建一个支持定时和周期性执行任务的线程池，多数情况下可以替代Timer类
</code></pre><p>先看CachedThreadPool，在缓存型线程池中，使用时先看池中有没有以前建立的线程，如果有就reuse，否则创建一个新的线程并加入池中。它通常用来执行一些生存期很短的异步任务，是Executor的首选。但不适宜面向连接的daemon型Server。<br>能reuse的线程必须要是 timeout IDLE (空闲超时)内的池中线程，缺省 timeout是60s(创建时keepAliveTime为60s)，IDLE超过这个时长，线程实例会被终止并移出线程池。因此不必担心它是否会结束，它会自动结束。  </p>
<p>FixedThreadPool和缓存型差不多，在任务数超过固定线程数后能reuse的会reuse，不同在于不能随时创建新的线程，任一时间点最多只能有固定数目的活动线程存在，如果此时要创建新的线程，只能在队列中等待直到当前池中某个线程终止被移出。它没有IDLE机制(创建时keepAliveTime为0)，所以适用于有稳定且固定数量并发任务的场景，如服务器。  </p>
<p>SingleThreadExecutor是线程池版单例模式，实现和CachedThreadPool、FixedThreadPool一样。  </p>
<p>ScheduledThreadPool里的线程可以按schedule依次delay执行，或周期执行。  </p>
<p>从上面分析知道，CachedThreadPool的设计会尽量让创建的线程数目与需要的相同，而且它会回收旧线程重用，因此理论上是大多数需要用到线程池的场景时的首选。《Thinking in Java》中说只有当这种方式存在问题时，比如需要大量长时间面向连接的线程时，才需要考虑用FixedThreadPool。  </p>
<p>Executors还有一些别的工厂方法，可以看源码。调用工厂方法创建了ExecutorService的实例后，就可以调用实例的execute接口传入Runnable。该方法自动在某个线程上执行Runnable。<br>ExecutorService还可以执行Callable，通过调用<code>submit(Callable task)</code>，它与Runnable不同的地方在于Runnable没有返回值，而Callable有返回值。调用submit方法后会返回一个Future类型的对象表示任务等待完成。Future的get()方法会获取返回值，它会阻塞直到任务完成。<br>shutdown和shutdownNow都能关闭线程池，不同的是前者会设置状态为SHUTDOWN，中断所有没有在执行任务的线程，等待已提交任务完成，后者会设置状态为STOP，中断所有没有在执行任务的线程并试图中断正在执行任务或暂停任务的线程，返回等待执行的任务列表。在SHUTDOWN状态下线程池可能还没有挂壁，只有当处于TERMINATED状态才说明线程池关闭成功。  </p>
<p><img src="/images/blogs/threadpool.jpg" alt="img">  </p>
<p>上面介绍了Executors提供的工厂方法和特点，源码可以看到底层都是同样的数据结构来实现的，那么是什么样的数据结构，现在就来看看。创建线程池最终都是调用的ThreadPoolExecutor类的构造方法<code>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, threadFactory, handler)</code>，依次是线程池基本大小、线程池最大大小、线程池中线程活动时间限制、时间单位、任务队列、线程工厂、饱和回调。<br>提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使此时有其他基本线程可用，当提交的任务数大于线程池基本大小时不再创建而是尝试复用已有线程。newCachedThreadPool指定的这个基本大小是0，即始终尝试复用线程，而FixedThreadPool中这个值与maximumPoolSize相等，即优先考虑创建新线程。如果调用了prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。任意时间线程池内的活动线程数目不超过maximumPoolSize。<br>任务队列是用来保存等待执行的任务的阻塞队列(BlockingQueue<runnable>)，可以从以下几种中选择，理论上应该也可以自己实现：</runnable></p>
<ul>
<li>ArrayBlockingQueue:基于数组结构的有界阻塞队列，元素顺序FIFO。</li>
<li>LinkedBlockingQueue:基于链表的阻塞队列，FIFO，吞吐量通常高于ArrayBlockingQueue，在newFixedThreadPool中就会用这个队列。</li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到前一个移除操作完成，否则插入操作一直处于阻塞状态。吞吐量通常要高于LinkedBlockingQueue，newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue:具有优先级的无阻塞队列，按优先级排序。  </li>
</ul>
<p>线程工厂用来创建线程，给线程命名等，可以通过实现自己的线程工厂来给线程设置更有意义的名字。<br>RejectedExecutionHandler饱和策略，当线程池和队列都处于饱和状态时必须采取一种策略处理新提交的任务，这个策略默认情况下是AbortPolicy，它会直接抛出RejectedExecutionException异常。Java提供了以下几种策略，你也可以自己实现RejectedExectionHandler：</p>
<ul>
<li>AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：使用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy：抛弃队列里最老的一个任务并执行当前任务</li>
<li>DiscardPolicy：直接丢弃</li>
</ul>
<p>线程活动时间指的是工作线程空闲后的存活时间。如果任务多并且每个任务执行时间短，可以调大这个时间提高线程利用率。时间单位在TimeUnit里有定义，从天到纳秒。  </p>
<p>线程池的存在和其实现原理提示了我们它的使用场景，可以从以下几个角度考虑：</p>
<ol>
<li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li>
<li>任务的优先级：高，中和低。</li>
<li>任务的执行时间：长，中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ol>
<p>线程池提供了beforeExecute和afterExecute接口用于在线程执行前后进行别的操作，例如Profile。<br><img src="/images/blogs/executorframework.png" alt="executorframework"><br>看了线程池对于Android有什么帮助呢？首先当然是我们知道有这么个东西，以后遇到并发任务的时候可以考虑用Executor来做，其次实际上Android有一个东西叫做AsyncTask，它也有execute方法，看看它的源码就会发现它就是用的ThreadPool，不谈它的实现的演变，它里面有一个Executor用来创建线程池和线程，默认使用LinkedBlockingQueue作为任务队列，固定了线程池基本线程、最大线程数量和空闲超时。<br>在Java里面有个注解<code>GuardedBy</code>，它与锁有关，事实上正是它让我想要看Java并发这一块内容的。  </p>
]]></content>
    
    <summary type="html">
    
      concurrent包是java提供的并发编程工具，从Java 5开始引入了Executor框架辅助实现...
    
    </summary>
    
      <category term="blog" scheme="https://hjhjw1991.github.io/categories/blog/"/>
    
    
      <category term="Java" scheme="https://hjhjw1991.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 6-7-8 更新小记</title>
    <link href="https://hjhjw1991.github.io/android/2017/08/01/Android-6-7-8-%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/"/>
    <id>https://hjhjw1991.github.io/android/2017/08/01/Android-6-7-8-更新小记/</id>
    <published>2017-07-31T16:00:00.000Z</published>
    <updated>2017-08-01T08:57:37.162Z</updated>
    
    <content type="html"><![CDATA[<p>如今Android 已经出到了O (Android 8.0, API Leve 26), 多个版本累加起来变化颇多, 记录一下.<br>从新增/改变/删除角度记录, 主要搬运官网.  </p>
<h2 id="Android-6-0-API-Level-23"><a href="#Android-6-0-API-Level-23" class="headerlink" title="Android 6.0 API Level 23"></a>Android 6.0 API Level 23</h2><p>以前写过一篇<a href="http://hjhjw1991.github.io/android/2015/08/25/Android-6.0-%E5%B0%8F%E8%AE%B0/">Android 6.0小记</a>, 这回新瓶装旧酒, 换种组织方式再写一下.  </p>
<h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><ul>
<li>运行时请求应用权限. 这是一种新的权限请求方式, 它允许应用通过<code>requestPermissions()</code>来实时请求权限. 需要注意, 在Android 6.0的操作系统环境下, 应用的所有权限都可以随时被取消, 所以即便你在App中注册了权限, 你运行时也应该检查一下是不是已经获得了权限. 一种典型的情况是, 你注册了权限, 也成功运行了App并获取了权限, 但用户出于某些缘故把你申请的权限取消了, 此时哪怕你仍然在运行, 也应该在执行需要权限的操作前检查自身权限. 检查权限可调用<code>checkSelfPermission()</code>方法.  </li>
<li>应用待机模式. 系统通过一段时间是否触摸屏幕判定是否进入待机模式, 并根据是否连接电源采取不同的处理策略, 以延长待机时间. 主要是限制被判定为待机模式的应用的网络访问, 同步, 闹钟等功能. 应用可申请加入白名单, 以保留网络访问, 但其他方面仍受限制.  </li>
<li>低耗电模式. 系统在未插入电源且屏幕关闭后静止一定时间, 会进入低耗电模式. 该模式下会推迟Activity活动, 网络访问, 同步, 闹铃, 并定期退出低耗电模式统一完成这些操作.  </li>
<li><p>文本选择时新增浮动工具栏. 交互方式与在单个视图中启用上下文操作模式类似.  </p>
</li>
<li><p>指纹验证<code>FingerpringManager</code>类及权限.  </p>
</li>
<li>确认凭据, 通过上次解锁与本次解锁的时间间隔来验证身份, 结合你应用自身的公钥或私钥, 完成身份验证. 通过<code>createConfirmDeviceCredentialIntent()</code>发起新验证, 通过<code>setUserAuthenticationValidityDurationSeconds()</code>设置同一密钥的有效期.  </li>
<li>应用链接(App Linking). 可令应用与某个特定Web域关联, 系统处理特定Web域的时候就会默认使用该应用, 而无需用户选择.  </li>
<li>自动备份应用. 目标平台在23以上的应用, 系统会通过Google账户为其自动执行完整的数据备份或恢复.  </li>
<li>直接共享. 提供<code>ChooserTargetService</code>类以供扩展, 可以直接发起一次共享调起其他应用的特定<code>Activity</code>. 可以指定某个<code>Activity</code>为可供直接共享的公开<code>Activity</code>. 有点类似于<code>ContentProvider</code>.  </li>
<li>新的语音交互API.  </li>
<li>助手程序. 用户在手动开启助手功能后, 可以通过长按”首页”按钮在任何应用内召唤助手.  </li>
<li>可采用的存储设备(adoptable storage device).  </li>
<li>在Nexus 6和Nexus 9上添加了对Hotspot 2.0的支持.  </li>
<li>新增4K显示模式. 新增<code>Display.Mode</code>API.  </li>
<li>ColorStateList现在也可以使用主题属性.  </li>
</ul>
<h3 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h3><ul>
<li>SSL库从OpenSSL迁移到BoringSSL. 主要影响使用加密库的项目, 如果使用NDK编译, 不要链接到非NDK API组成部分的加密库, 例如<code>libcrypto.so</code>, <code>libssl.so</code>, 因为并非公共API, 所以在不同版本的系统或设备上可能会引起故障或行为变化, 且存在安全漏洞. 如果要用, 应当静态链接.  </li>
<li>修改直接获取硬件标识符的API. 对于使用WLAN API和Bluetooth API的应用, 从前可通过<code>WifiInfo.getMacAddress()</code>和<code>BluetoothAdapter.getAddress()</code>方法拿到硬件Mac值, 现在这两个接口返回常量值<code>02:00:00:00:00:00</code>. 想要获取Mac值, 需要<code>ACCESS_FINE_LOCATION</code>或<code>ACCESS_COARSE_LOCATION</code>权限.  </li>
<li><code>Notification.setLatestEventInfo()</code>移除, 改为<code>Notification.Builder</code>构建通知. <code>adb shell dumpsys notification --noredact</code>打印<code>notification</code>对象中的文本.  </li>
<li>不再通过<code>AudioManager</code>直接修改音量, 弃用<code>setStreamSolo()</code>, <code>setStreamMute()</code>, 应当分别改为调用<code>requestAudioFocus()</code>, <code>adjustStreamVolume</code>(传入方向值<code>ADJUST_MUTE ADJUST_UNMUTE</code>).  </li>
<li>Android密钥库不再支持DSA, 仍支持ECDSA.  </li>
<li>WLAN和网络连接变更. 现在应用只能修改自己创建的<code>WifiConfiguration</code>对象状态.  </li>
<li>相机服务变更. 相机服务中共享资源的访问模式由”先到先得”改为”高优先级进程优先访问”. 低优先级进程可能会被驱逐, 导致回调断开相机服务的函数. 活动的相机客户端仅属于当前账户, 切换账户会导致客户端断开.  </li>
<li>运行时. 正确实现了<code>newInstance()</code>访问规则检查. 更新了动态链接程序的行为, 可识别<code>soname</code>与其路径之间的差异, 并能按<code>soname</code>搜索. 正确实现<code>dlopen(3) RTLD_LOCAL</code>标记. 在目标SDK高于23时, 直接加载包含文本重定位信息的共享库会被拒绝, 可以通过检查<code>dlopen(3)</code>失败日志并通过<code>dlerror(3)</code>获得调用返回的问题描述文本来确定库加载是否成功.  </li>
<li>更严格的APK验证. 如果清单中声明的文件在APK中不存在, 该APK会被视为已损坏.  </li>
<li>USB连接. 默认情况下USB连接设置为仅充电, 需要手动显式授予权限给数据访问等其他交互方式.  </li>
<li>改善对蓝牙触控笔的支持.  </li>
<li>改进蓝牙低功耗扫描.  </li>
<li>增强音频功能. 添加了对MIDI的支持.  </li>
<li>增强视频功能. 新增<code>MediaSync</code>类帮助应用同步渲染音频流和视频流.  </li>
<li>增强相机功能. 新提供Flashlight API和Reprocessing API系列接口.  </li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>不再支持Apache HTTP客户端. 应当改用<code>HttpURLConnection</code>.  </li>
<li>移除对全局书签的支持. 移除<code>android.provider.Browser.getAllBookmarks()</code> <code>android.provider.Browser.saveBookmark()</code>方法和<code>READ_HISTORY_BOOKMARKS</code> <code>WRITE_HISTORY_BOOKMARKS</code>权限.  </li>
</ul>
<h2 id="Android-7-0-API-Level-24-25"><a href="#Android-7-0-API-Level-24-25" class="headerlink" title="Android 7.0 API Level 24 25"></a>Android 7.0 API Level 24 25</h2><h3 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h3><h3 id="改变-1"><a href="#改变-1" class="headerlink" title="改变"></a>改变</h3><ul>
<li>低耗电模式在手机不处于静止状态时也适用.  </li>
<li>面向Android 7.0及以上版本的应用, 私有目录被限制访问(0700).<br>这将导致几个副作用: <ol>
<li>自主扩大访问权限的行为受到影响, 例如使用<code>MODE_WORLD_READABLE</code>或<code>MODE_WORLD_WRITEABLE</code>将引发<code>SecurityException</code>(但使用原生API或File API修改权限仍然不被限制, 尽管官方强烈反对);  </li>
<li>尝试传递<code>file://URI</code>会触发<code>FileUriExposedException</code>, 推荐使用<code>FileProvider</code>分享私有文件内容;  </li>
<li><code>DownloadManager</code>不再按文件名分享私人存储的文件. 面向Android 7.0或更高版本的应用在尝试访问<code>COLUMN_LOCAL_FILENAME</code>时会触发<code>SecurityException</code>, 除非<code>DownloadManager</code>设置为将文件存放在公共位置, 但官方强烈反对这种使用方法. 首选访问方式是使用<code>ContentResolver.openFileDescriptor()</code>.  </li>
</ol>
</li>
<li>面向Android 7.0的应用, <code>StrictMode</code> API禁止在应用外公开<code>file://URI</code>, 如果包含文件URI的intent发送超出你应用的范围, 则引起<code>FileUriExposedException</code>异常, 应当使用<code>content://URI</code>并授予URI临时访问权限, 以在应用间共享文件. 例如使用<code>FileProvider</code>进行授权.  </li>
<li>无障碍改进. 支持用户设置显示尺寸, 设备密度会因此改变, 面向API 23及以下的应用会被终止后台进程, 面向Android 7.0的应用所有进程都会收到有关配置变更的通知; 设置向导中增加视觉设置.  </li>
<li>NDK应用链接至平台库. 从Android 7.0开始, 系统阻止应用动态链接到非公开NDK库. 需要注意您的应用中的第三方静态库可能会这么做, 因此应当检查确保应用不会在Android 7.0崩溃. 如果要使用原声代码, 只能使用公开的<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="external">NDK API</a>. 要使用私有库, 就需要将其添加到应用中. Android 7.0 SDK带有工具<code>readelf</code>, 使用以下命令可以生成给定的<code>.so</code>文件的所有动态链接的共享库列表: <code>aarch64-linux-android-readelf -dW libMyLibrary.so</code>.  </li>
</ul>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除三个隐式广播: <code>CONNECTIVITY_ACTION</code> <code>ACTION_NEW_PICTURE</code> <code>ACTION_NEW_VIDEO</code>. 移动设备会经历频繁的连接变更, 其他应用例如相机可能会发送隐式广播<code>ACTION_NEW_PICTURE</code>和<code>ACTION_NEW_VIDEO</code>, 这三种广播的发送都非常频繁, 导致所有注册了的接收者都会被唤醒. 删除后, 面向Android 7.0开发的应用不再收到<code>CONNECTIVITY_ACTION</code>广播, 即使它声明接收, 除非它在前台运行并使用<code>BroadcastReceiver</code>请求接收通知. 所有应用都将无法发送或接收<code>ACTION_NEW_PICTURE</code> <code>ACTION_NEW_VIDEO</code>广播.  </li>
</ul>
<h3 id="API-23-gt-API-24"><a href="#API-23-gt-API-24" class="headerlink" title="API 23 -&gt; API 24"></a>API 23 -&gt; API 24</h3><p>见<a href="https://developer.android.com/sdk/api_diff/24/changes.html" target="_blank" rel="external">网页端</a>  </p>
<h2 id="Android-8-0"><a href="#Android-8-0" class="headerlink" title="Android 8.0"></a><a href="https://developer.android.com/preview/behavior-changes.html?hl=zh-cn" target="_blank" rel="external">Android 8.0</a></h2><h3 id="面向开发者的新功能"><a href="#面向开发者的新功能" class="headerlink" title="面向开发者的新功能"></a>面向开发者的新功能</h3><p>本文摘录一部分, 完整版见<a href="https://developer.android.com/preview/api-overview.html?hl=zh-cn" target="_blank" rel="external">官网</a>.  </p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>重新设计通知, 使管理通知行为和设置更加轻松和统一.</p>
<ul>
<li>通知渠道. 允许为要显示的每种通知类型创建用户可自定义的渠道. 用户界面将通知渠道称为通知类别.  </li>
<li>休眠. 用户可以将通知置于休眠状态, 稍后重新显示. 应用可以移除或更新已休眠的通知, 但更新不会使它重新显示.  </li>
<li>通知超时. 使用<code>Notification.Builder.setTimeout()</code>可以设置超时, 在指定的持续时间之后取消通知, 也可以提前取消通知.  </li>
<li>通知清除. 系统现在可以区分用户清除和应用清除. 在<code>NotificationListenerService.onNotificationRemoved()</code>方法中可以得知.  </li>
<li>背景颜色. 为通知设置背景颜色.  </li>
<li>消息样式. <code>MessagingStyle</code>可以在通知的折叠形式中显示更多内容.  </li>
</ul>
<h4 id="自动填充框架"><a href="#自动填充框架" class="headerlink" title="自动填充框架"></a>自动填充框架</h4><p>Android O 引入自动填充框架, 新老应用都可以用此简化登陆和表单填写等工作.  </p>
<h4 id="画中画-PictureInPicture-PIP-模式"><a href="#画中画-PictureInPicture-PIP-模式" class="headerlink" title="画中画(PictureInPicture,PIP)模式"></a>画中画(PictureInPicture,PIP)模式</h4><p>PIP模式是一种特殊的多窗口模式, 在Android TV中最早出现, 现在可应用于搭载 Android O的其他设备. Activity处于PIP模式时, 它会处于暂停状态, 但仍继续显示内容. 因此, 假如是一个支持PIP模式的视频播放Activity, 应该在<code>onPause</code>中继续播放, 而在<code>onStop</code>中才暂停播放, 并在<code>onStart</code>中继续播放. 其需要注意的除了跟多窗口模式一样以外, 但区别于多窗口模式, 只需要在清单中将<code>android:supportsPictureInPicture</code>设置为<code>true</code>, 无需将<code>android:resizeableActivity</code>设置为<code>true</code>, 后者仅在需要支持其他多窗口模式时才需要.<br>为了完成PIP模式, Android O引入了一个新对象<code>android.app.PictureInPictureArgs</code>, 可以将该对象传递给PIP方法, 用以指定某个Activity在其处于PIP模式时的行为. <a href="https://developer.android.com/training/tv/playback/picture-in-picture.html?hl=zh-cn" target="_blank" rel="external">点击查看如何添加画中画</a>.  </p>
<h4 id="处理字体"><a href="#处理字体" class="headerlink" title="处理字体"></a>处理字体</h4><p>XML中允许使用字体作为资源. 字体可以不再以资产的形式存放, 并可通过R文件访问. Android O提供机制用于检索与系统字体有关的信息并提供文件描述符, 详情参见<a href="https://developer.android.com/preview/features/working-with-fonts.html?hl=zh-cn" target="_blank" rel="external">处理字体</a>.  </p>
<h4 id="接听权限ANSWER-PHONE-CALLS"><a href="#接听权限ANSWER-PHONE-CALLS" class="headerlink" title="接听权限ANSWER_PHONE_CALLS"></a>接听权限ANSWER_PHONE_CALLS</h4><p>Android O引入权限<code>android.permission.ANSWER_PHONE_CALLS</code>, 应用可按照设定的方式接听拨入的电话.  </p>
<h4 id="内容提供程序分页"><a href="#内容提供程序分页" class="headerlink" title="内容提供程序分页"></a>内容提供程序分页</h4><p>更新了内容提供程序(ContentProvider), 以支持大型数据集, 每次加载一页. 客户端和提供程序都必须实现分页.  </p>
<h4 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h4><p>Android O提供以下功能, 支持应用创建自己的无障碍服务.  </p>
<ul>
<li>语言检测. 使用<code>TextClassificaationManager.detectLanguages()</code>检测”TTS”工具在某个文本范围内识别的语言.  </li>
<li>无障碍功能按钮. 可以通过设置标志请求系统在导航区域显示你的无障碍服务的功能按钮, 并调用你自己注册的按钮回调.  </li>
<li>指纹手势. 现在指纹传感器支持指纹手势, 如上下左右滑动, 但你的服务仅能在指纹传感器不用于身份验证时才可使用它.  </li>
<li>字词级突出显示.  </li>
<li>提示文本. 可以通过<code>AccessibilityNodeInfo.getHintText()</code>获取<code>EditText</code>的提示文本, 即便它当前并未显示提示文本.  </li>
<li>连续的手势分派. 可以使用<code>GestureDescription.StrokeDescription</code>构造函数的最后一个参数指定属于同一设定手势的笔划的顺序.  </li>
</ul>
<h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><ul>
<li>自适应启动器图标. 可以在不同设备型号上显示不同形状的图标.  </li>
<li>颜色管理. 现在可以支持广色域彩色显示的新设备, 需要在Activity中启用一个标志.  </li>
<li>WLAN感知. 基于周边感知联网(NAN)规范, 在具有相应感应器的设备上, 应用可以与之通过WLAN进行搜索和通信, 无需依赖互联网接入点.  </li>
<li>配套设备配对, Android O允许自定义配对请求对话框.  </li>
<li>WebView API. 提供多种API以增强应用的稳定性和安全性. 见<a href="https://developer.android.com/preview/features/managing-webview.html?hl=zh-cn" target="_blank" rel="external">管理WebView</a>  </li>
<li>固定快捷方式和小部件.  </li>
<li>媒体功能增强.  </li>
<li>多显示器支持.  </li>
<li>新的帐号访问和Discovery API  </li>
<li><code>AnimatorSet</code>支持寻道和倒播.  </li>
<li>自动调整<code>TextView</code>大小.  </li>
<li>应用可以声明它们所属的类别, 这将用于分类呈现给用户.  </li>
<li>应用可获得一定的磁盘空间配额用于缓存数据, 在系统需要释放磁盘空间时会优先释放超过配额最多的应用的缓存文件, 应用可以针对每个目录设定两种行为, 以控制系统如何释放该数据: 1. 将指定的目录作为不可分割的整体进行删除; 2. 指示不应该删除某个文件, 而是将它截断为0字节.  </li>
<li>有关企业版Android(Android for Work)的更新.  </li>
<li>更新了Java编程语言支持.  </li>
</ul>
<h3 id="改变-2"><a href="#改变-2" class="headerlink" title="改变"></a>改变</h3><ul>
<li>后台执行限制. 当应用进入已缓存状态时, 如果没有活动的组件, 系统将解除应用具有的所有唤醒锁.  </li>
<li>降低了后台应用接收位置更新的频率.  </li>
<li>蓝牙<code>ScanRecord.getBytes()</code>不再对所接收的字节数做任何假定. 返回的字节数可能会超过之前最大60字节的限制, 也可能小于.  </li>
<li>无障碍服务现在可识别<code>TextView</code>内部的所有<code>ClickableSpan</code>实例.  </li>
<li>安全性增强. 不再支持<code>SSLv3</code>; 使用<code>HttpsURLConnection</code>建立HTTPS连接时, 如果服务器未正确实现TLS协议版本, 不再采取回退到之前的TLS协议版本的权宜之计; Android O将使用安全计算过滤器过滤所有应用, 系统调用仅允许通过bionic公开的系统调用; WebView在多进程模式下运行, 网页内容在独立的进程, 与应用进程相隔离; APK不能假设驻留在名称以-1或-2结尾的目录中, 应用应当使用<a href="https://developer.android.com/reference/android/content/pm/ApplicationInfo.html?hl=zh-cn#sourceDir" target="_blank" rel="external">sourceDir</a>获取目录; 增强<a href="https://developer.android.com/preview/behavior-changes.html?hl=zh-cn#nl" target="_blank" rel="external">原生库</a>安全性.  </li>
<li>隐私性. 改变了标识符处理方式, 现在通过应用而不是用户来确定<code>ANDROID_ID</code>的值范围. 对于同一包名和签名的应用, 卸载或重新安装时<code>ANDROID_ID</code>值不变, 如果软件包签名密钥因为系统更新而改变, <code>ANDROID_ID</code>值也不变; 查询<code>net.hostname</code>系统属性, 返回为空.  </li>
<li>记录未捕获的异常. 如果异常未被移交给默认的<code>Thread.UncaughtExceptionHandler</code>, 系统将会记录异常堆栈跟踪情况. 建议自定义<code>Thread.UncaughtExceptionHandler</code>的实现始终移交给默认处理程序处理.  </li>
<li>联系人提供程序 使用情况统计方法变更. 应用请求<code>READ_CONTACTS</code>权限, 使用情况数据查询会返回近似值, 此前是返回精确值.  </li>
<li>集合的处理. <code>AbstractCollection.removeAll()</code> 和 <code>AbstractCollection.retainAll()</code> 始终引发 <code>NullPointerException</code>, 以符合文档要求.  </li>
</ul>
<h3 id="针对Android-O的应用"><a href="#针对Android-O的应用" class="headerlink" title="针对Android O的应用"></a>针对Android O的应用</h3><p>那些<code>compileSdkVersion</code>或<code>targetSdkVersion</code>在Android O及以上的应用, 开发者需要按如下指导修改以正确支持相应行为.  </p>
<ul>
<li>提醒窗口. 使用<code>SYSTEM_ALERT_WINDOW</code>权限的应用必须使用新的<code>TYPE_APPLICATION_OVERLAY</code>窗口类型来在其他应用和系统窗口上方显示提醒窗口, 以前的多个窗口类型不可用. 该新窗口类型具有以下特性: 始终显示在状态栏和输入法等关键系统窗口下面; 系统可以移动该窗口或调整其大小, 以改善屏幕显示效果; 用户可以打开通知栏设置阻止应用使用该类型的提示窗口.  </li>
<li>内容变更通知. <code>ContentResolver.notifyChange()</code> 和 <code>registerContentObserver(Uri, boolean, ContentObserver)</code>接口需要在URI中定义一个有效的<code>ContentProvider</code>, 这可以防范来自恶意应用的内容变更.  </li>
<li>View焦点. 现在View默认也可以成为焦点.  </li>
<li>安全性. 网络安全性配置设置为不允许明文流量的话, <code>WebView</code>将无法通过HTTP访问网站.  </li>
<li>权限. 此前, 应用在运行时请求权限并且被授予该权限, 那么在清单中注册的同一组的其他权限也将被一起授予. 现在, 这些同组权限不会在此时被授予, 但如果请求的某一权限被授予, 则后续对同组其他权限的请求将会立即被授予.  </li>
<li>集合处理. 此前, <code>List.sort()</code>的默认实现会调用<code>Collections.sort()</code>, 在Android O中则恰好相反. 但此时有以下限制: <code>List.sort()</code>的实现不能调用<code>Collections.sort()</code>, 显然因为循环调用; 重写<code>sort</code>的时候也要异常小心, 区分API级别来调用不同的默认实现或者调用与<code>sort</code>不存在依赖关系的方法来实现; 此前, 在<code>List</code>迭代过程中<code>Collections.sort()</code>对<code>List</code>进行排序不会引发异常, 此项变更使得该方式也抛出<code>ConcurrentModificationException</code>异常.  </li>
<li>类加载行为. 不支持多个类加载器加载同一个<code>DexFile</code>对象来定义类, 否则引发<code>InternalError</code>错误. <code>DexFile API</code>现已弃用. 所有类加载器都被视为支持并行运行. 多个线程用同一个类加载器加载相同的类时, 第一个完成操作的线程胜出, 操作结果可以用于其他线程.  </li>
</ul>
<h3 id="功能和API"><a href="#功能和API" class="headerlink" title="功能和API"></a>功能和API</h3><ul>
<li>后台执行限制. Android O对应用在后台运行时可以执行的操作施加了限制. 应用在后台服务和广播两方面存在限制, 在多数情况下应用可以使用<code>JobScheduler</code>作业克服这些限制. Android O对<code>JobScheduler</code>提供了多个改进.  </li>
<li>对于后台应用, 位置检索行为将受到限制, 频率降低.  </li>
<li>Notification Badges. 前面介绍过, 类似于3D Touch的快捷方式.  </li>
<li>以O为目标的应用, 显示通知需要实现一个或多个通知渠道(channel), 优先级(重要性)由以前的为单个通知指定变更为适用于整个通知渠道.  </li>
<li>Autofill Framework. 全新的自动填充框架, 提供一个服务, 应用可以利用该服务使用自动填充.  </li>
<li>Unknown App Install Permission. 这是一个权限, 允许App安装其他的未知App, 用户可以选择哪些应用具有这种权限. App需要在清单中声明, 在运行时申请该权限.  </li>
<li>Pointer Capture. 这是鼠标动作捕捉机制. 在类似游戏/远程桌面/虚拟客户端等场景下, 控制鼠标点击很有用处. 该机制下, 获得焦点的View可以捕捉MotionEvent, 在回调中自行处理所有捕捉到的事件.  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      如今Android 已经出到了O (Android 8.0, API Leve 26), 多个版本累加起来变化颇多, 记...
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Animation详解</title>
    <link href="https://hjhjw1991.github.io/android/2017/05/11/Animation%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/05/11/Animation详解/</id>
    <published>2017-05-10T16:00:00.000Z</published>
    <updated>2017-05-11T08:22:10.985Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧, 接触Android这么久可UI和Animation一直是涉足未深的盲点, 今天就来解决Animation这个盲点.  </p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇应该会涉及很多demo图片. 在Android开发中经常会碰到各种各样的动画, 有的是为了辅助实现功能, 例如进度条动画和Loading界面, 有的是为了帮助用户理解功能逻辑, 提升用户体验, 例如切入切出动画, 滑动效果, 而有的是纯粹为了看起来酷炫, 比如各种游戏特效. 一图胜千言, 一个动画有时候能起到的作用是用Toast所达不到的, 如果能用好动画, 则无论是开发过程还是成品都能够得到质的提升(没有动画的世界是多么乏味!).  </p>
<p>众所周知, Android对界面的绘制速度是有要求的, 正常屏幕刷新频率是60Hz, 也就是60 frame/s, 故每一帧需要在1000ms/60即约16ms内完成, 否则就会造成能够感知到的掉帧, 俗称卡顿, 所以我们在做动画的时候也一定要考虑性能问题, 由动画引起严重卡顿就得不偿失了, 为了Android早就被黑得体无完肤的卡顿问题, 我们还要多多磨练自己的技术.  </p>
<p>先抛出几个优秀的动画效果:<br><a href="https://github.com/daimajia/AndroidViewAnimations" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/c41223966bdfed2260dbbabbcbae648e5db542c6/687474703a2f2f7777332e73696e61696d672e636e2f6d773639302f3631306463303334677731656a37356d69327737376732306333306a623471722e676966" alt="AndroidAnimations"></a>  </p>
<p><a href="https://github.com/hujiaweibujidao/FabDialogMorph" target="_blank" rel="external"><img src="https://raw.githubusercontent.com/hujiaweibujidao/FabDialogMorph/master/fabdialog.gif" alt="FabDialogMorph"></a>  </p>
<p><a href="https://github.com/hujiaweibujidao/wava" target="_blank" rel="external"><img src="https://github.com/hujiaweibujidao/wava/raw/master/wava.gif" alt="wava"></a>  </p>
<p><a href="https://github.com/hujiaweibujidao/yava" target="_blank" rel="external"><img src="https://github.com/hujiaweibujidao/yava/raw/master/yava.gif" alt="yava"></a>  </p>
<p><a href="https://github.com/yanbober/SlideLayout" target="_blank" rel="external"><img src="https://github.com/yanbober/SlideLayout/raw/master/art/demo.gif" alt="slidelayout"></a>  </p>
<p>感谢<a href="http://blog.csdn.net/yanbober" target="_blank" rel="external">工匠若水</a> <a href="https://daimajia.com/" target="_blank" rel="external">代码家</a>和<a href="https://hujiaweibujidao.github.io/" target="_blank" rel="external">潇涧</a><br>特别感谢代码家的个人感悟博文, 让我知道用心运营一个产品也许没有想象中那样乏味, 我之所以不去做只是不愿意面对可能的失败, 是完全的不自信.  </p>
<p>如果不满足于使用动画库, 想像他们一样为开源世界做出贡献, 那么了解代码背后的代码就十分必要. 以上开源库为我们提供了一个很好的切入点, 读者可以挑选一个感兴趣的效果深入探究.<br>当然也可以跟我一起(在Android动画方面, 我是一个完全的入门者), 跟这篇文章一起, 从底层, 从原理一步一步地走上来.<br>本文基于<strong>Android6.0源码</strong>, 从问题出发, 打算用一篇长文解决所有问题, 所以会在小节标题尽量提示本节内容.  </p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>不同于理论研究, 程序开发的一切功能都是为实际需求而生的, 我们先来看需求:<br>最简单的情况, 我想让一段文本横向缓缓移动, 就像跑马灯一样的效果.<br>再进一步, 一段文本或者图片我希望把它放大和缩小, 但是不能是那种一点没有过渡的一步到位.<br>抑或我想让一个百变怪的图像变形成皮卡丘.<br>…<br>所有这些都是动画要解决的问题. 光凭直觉我们也能分辨出动画是有类别之分的, 比如形变/位移/镜像, 显然动画可以跟数学描述紧密结合. 可以这么说, 任何动画, 只要我们在有限维空间能够找到表达式来表达映射关系, 就可以实现, 这是动画背后坚实的数学基础.  </p>
<p>先不扯数学(后面再扯), 来看看一个简单的位移动画, 我们在最上层怎么实现. 最先想到的当然是去找官方文档(以及顺手创建一个示例工程). 在<a href="https://developer.android.com/guide/topics/graphics/index.html" target="_blank" rel="external">Android官方文档</a>中, 把动画分为两个系统: 属性动画(property anima)和视图动画(view anima). 为了备忘和无网时回顾, 我这里对官方文档做一个简单翻译, 建议大家看原文.  </p>
<p>Android系统框架提供以上两种动画系统, 都可以用, 但是一般来说属性动画比较好用, 因为它更灵活功能也更多. 除了这两种动画以外, 还有一种 Drawable Anima(有叫帧动画Frame Anima的, 我不翻译), 它允许你载入一堆drawable资源, 并一帧一帧挨个显示他们.  </p>
<p>我们分别来看看这三种动画都是什么东西, 怎么用, 然后来看看我们要实现的效果怎么实现.<br>以下内容主要参考官方文档.  </p>
<h3 id="View-Anima-Tween-Anima"><a href="#View-Anima-Tween-Anima" class="headerlink" title="View Anima / Tween Anima"></a>View Anima / Tween Anima</h3><p><a href="https://developer.android.com/guide/topics/graphics/view-animation.html" target="_blank" rel="external">视图动画(也叫补间动画)</a>允许在一个视图容器里执行一系列简单变换, 它只能用于视图. 顾名思义, 它是以整个视图为对象, 将帧与帧”之间”的过渡给”补齐”的动画. 它通过动画的起点/终点/尺寸/旋转以及其他常见方面来计算动画. 我们可以用一系列的动画指令(anima instruction)来定义补间动画, XML或者Android代码都可以. 官方推荐XML方式定义, 如果要以代码方式定义, 官方建议参考 <code>android.view.animation.AnimationSet</code>及其他的<code>android.view.animation.Animation</code>子类.  </p>
<p>本质上, 补间动画就是给出两个关键帧, 通过一些方法计算中间过程, 并按顺序展示中间过程. 补间动画有<code>AlphaAnimation, RotateAnimation, ScaleAnimation, TranslateAnimation</code>这几种, 看名字大概也知道对应的效果了.<br>我们来看看怎么用. 先看XML官方示例:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 以下代码用于拉伸和旋转一个View对象 --&gt;</div><div class="line">&lt;set android:shareInterpolator=&quot;false&quot;&gt;</div><div class="line">    &lt;scale</div><div class="line">        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</div><div class="line">        android:fromXScale=&quot;1.0&quot;</div><div class="line">        android:toXScale=&quot;1.4&quot;</div><div class="line">        android:fromYScale=&quot;1.0&quot;</div><div class="line">        android:toYScale=&quot;0.6&quot;</div><div class="line">        android:pivotX=&quot;50%&quot;</div><div class="line">        android:pivotY=&quot;50%&quot;</div><div class="line">        android:fillAfter=&quot;false&quot;</div><div class="line">        android:duration=&quot;700&quot; /&gt;</div><div class="line">    &lt;set android:interpolator=&quot;@android:anim/decelerate_interpolator&quot;&gt;</div><div class="line">        &lt;scale</div><div class="line">           android:fromXScale=&quot;1.4&quot;</div><div class="line">           android:toXScale=&quot;0.0&quot;</div><div class="line">           android:fromYScale=&quot;0.6&quot;</div><div class="line">           android:toYScale=&quot;0.0&quot;</div><div class="line">           android:pivotX=&quot;50%&quot;</div><div class="line">           android:pivotY=&quot;50%&quot;</div><div class="line">           android:startOffset=&quot;700&quot;</div><div class="line">           android:duration=&quot;400&quot;</div><div class="line">           android:fillBefore=&quot;false&quot; /&gt;</div><div class="line">        &lt;rotate</div><div class="line">           android:fromDegrees=&quot;0&quot;</div><div class="line">           android:toDegrees=&quot;-45&quot;</div><div class="line">           android:toYScale=&quot;0.0&quot;</div><div class="line">           android:pivotX=&quot;50%&quot;</div><div class="line">           android:pivotY=&quot;50%&quot;</div><div class="line">           android:startOffset=&quot;700&quot;</div><div class="line">           android:duration=&quot;400&quot; /&gt;</div><div class="line">    &lt;/set&gt;</div><div class="line">&lt;/set&gt;</div></pre></td></tr></table></figure>
<p>看标签名不难理解每个动画元素都做了什么以及相互之间的关系.<br>XML中除了指定关键帧的属性以外, 有一个重要的属性<code>android:interpolator</code>, 该属性绑定一个<code>Interpolator</code>(有译”插值器”), 由它来控制动画转换过程如何完成, 例如<code>AccelerateInterpolator</code>就指示以越来越快的速度来展示动画. 每个<code>Interpolator</code>类都可以被配置在XML中.<br>特别要指出的是<code>android:pivotX</code>这类属性, 它的值指定的是一个百分比, 但是有带”%”符号和不带符号, 其含义是不同的: 带”%”符号, 表示相对于View自身, 而不带则表示相对于View的父元素.<br>假设以上XML以<code>hyperspace_jump.xml</code>的名字存在<code>res/anim/</code>目录下, 在代码中可以这样使用:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ImageView spaceshipImage = (ImageView) findViewById(R.id.spaceshipImage); // 要应用动画的View对象</div><div class="line">Animation hyperspaceJumpAnimation = AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump); // 使用AnimationUtils载入并实例化动画</div><div class="line">spaceshipImage.startAnimation(hyperspaceJumpAnimation); // startAnimation是View提供的方法, 你也可以用View.setAnimation()指定一个已通过Animation.setStartTime()设定了开始时间的定时动画</div></pre></td></tr></table></figure>
<p>我们再来看代码如何定义一个动画:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private TranslateAnimation mTranslateAnimation; // 一个位移动画</div><div class="line">//这四个参数含义分别是当前View x起点坐标、x终点坐标、y起点坐标、y终点坐标</div><div class="line">mTranslateAnimation = new TranslateAnimation(0, 200, 0, 0);</div><div class="line">//动画持续时间</div><div class="line">mTranslateAnimation.setDuration(2000);</div><div class="line">//重复次数</div><div class="line">mTranslateAnimation.setRepeatCount(1);</div><div class="line">//动画执行模式</div><div class="line">mTranslateAnimation.setRepeatMode(Animation.REVERSE);</div><div class="line">... // 后面就跟上文XML方式动画实例化之后一样了</div></pre></td></tr></table></figure>
<p>四种补间动画的定义和使用都大同小异, 而且可以设置监听器<code>Animation.AnimationListener()</code>, 这里就不赘述.<br>需要注意的是两点: 1. 动画播放完成后, View会怎么样; 2. 动画指定的边界和View及View的父容器指定的边界发生冲突时, 例如动画放大到超出View父容器的边界, 会怎样.<br><!-- 这里可以直接给出答案: 1. 通过setFillAfter/setFillBefore/setFillEnabled可以控制动画播放完成后是保持最后的状态还是回到开始的状态; 2. 如果动画放大到超出View父容器边界, 那View会被裁减为只显示父容器范围内的部分. --></p>
<h3 id="Drawable-Anima-Frame-Anima"><a href="#Drawable-Anima-Frame-Anima" class="headerlink" title="Drawable Anima/Frame Anima"></a>Drawable Anima/Frame Anima</h3><p>这种动画我不知道怎么翻译, 主要是Drawable不好翻译. 正如前文所述, 这种动画就是把一个个Drawable或者说Frame按顺序播放, 跟放电影一样. 它的定义和使用也特别简单:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private AnimationDrawable mAnimationDrawable; // 定义帧动画对象</div><div class="line">mAnimationDrawable = new AnimationDrawable();</div><div class="line">// 添加帧及播放时间</div><div class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.australia), 500);</div><div class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.austria), 500);</div><div class="line">mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.china), 500);</div><div class="line">mAnimationDrawable.start(); // 开始动画</div></pre></td></tr></table></figure>
<p>以下是XML的定义  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 等效XML --&gt;</div><div class="line">&lt;animation-list</div><div class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:oneshot=&quot;false&quot;&gt;</div><div class="line"></div><div class="line">    &lt;item android:drawable=&quot;@drawable/australia&quot; android:duration=&quot;500&quot;/&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/austria&quot; android:duration=&quot;500&quot;/&gt;</div><div class="line">    &lt;item android:drawable=&quot;@drawable/china&quot; android:duration=&quot;500&quot;/&gt;</div><div class="line">&lt;/animation-list&gt;</div><div class="line">&lt;!-- XML中设置 --&gt;</div><div class="line">&lt;ImageView</div><div class="line">        android:id=&quot;@+id/frame_iv&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:background=&quot;@anim/frame&quot;/&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// java中调用</div><div class="line">private ImageView mFrameIv;</div><div class="line">private AnimationDrawable mAnimationDrawable;</div><div class="line">mFrameIv = (ImageView) findViewById(R.id.frame_iv);</div><div class="line">mAnimationDrawable = (AnimationDrawable) mFrameIv.getBackground();</div><div class="line">mAnimationDrawable.start();</div></pre></td></tr></table></figure>
<p>这种动画本身就是在播放Drawable, 所以不能通过<code>setAnimation</code>或者类似的方式应用在别的对象上, 只能以普通图像的方式使用, 例如设置为背景图, 有点类似于gif.  </p>
<h3 id="Property-Anima"><a href="#Property-Anima" class="headerlink" title="Property Anima"></a>Property Anima</h3><p><a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="external">属性动画</a>可以说是系统提供的最强大的动画框架了, 它可以改变<strong>任意对象</strong>的属性, 只要对象符合一定条件. 难怪官网说它几乎可以动画化一切(allows you to animate almost anything). 它是Android 3.0 (API 11)新加入的成员.<br>起先, 补间动画和帧动画似乎足够, 然而补间动画只能操作View, 而且不会改边View的属性, 帧动画又太过简单, 要实现复杂的动画效果需要大量的帧, 他们俩似乎并不足以撑起Android的动画天下, 于是谷歌增加了属性动画.  </p>
<p>利用属性动画, 你可以指定对象所具有的某项属性随时间的变化情况, 比如, 你可以指定某个对象在300ms内从位置A移动到位置B, 其间分别位于位置AB1,AB2,AB3.<br>在属性动画中, 你可以指定动画持续时间(Duration), 属性值与执行时间的函数关系(Time interpolation), 重复模式和重复次数, 动画集合, 帧刷新频率等.  </p>
<p>Property Anima有两个类可以使用: ValueAnimator, ObjectAnimator, 他们的共同祖先都是Animator.<br>以ObjectAnimator为例, 一个对象的属性动画可以这样定义:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private ObjectAnimator mObjectAnimator;</div><div class="line">//设置不透明度从1到0变化</div><div class="line">mObjectAnimator = ObjectAnimator</div><div class="line">                .ofFloat(mObjectAnimatorIv, &quot;alpha&quot;, 1, 0) // 以 mObjectAnimatorIv对象的float型alpha属性为动画对象, 值从1变到0. &quot;alpha&quot;必须是对象具有getter/setter的属性的名字, 否则无效果</div><div class="line">                .setDuration(1000); // 持续时间1000ms</div><div class="line">//设置插值器，先加速后减速</div><div class="line">mObjectAnimator.setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">//动画重复执行一次</div><div class="line">mObjectAnimator.setRepeatCount(1);</div><div class="line">//设置执行模式</div><div class="line">mObjectAnimator.setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">//设置在插值器所指定的每个动画更新时点的监听器</div><div class="line">mObjectAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">        //获取当前的动画值</div><div class="line">        float cVal = (Float) animation.getAnimatedValue();</div><div class="line">        //根据动画值缩放当前View</div><div class="line">        mObjectAnimatorIv.setScaleX(cVal);</div><div class="line">        mObjectAnimatorIv.setScaleY(cVal);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的效果是让对象的alpha属性值按一定规律从1变到0, 即逐渐透明, 并通过监听器让对象同时缩小. 其中该目标属性alpha每个时点的具体值是通过TypeEvaluator根据插值器和初末值计算得到的. 不设置TypeEvaluator的情况下Property Animation会有一个默认的TypeEvaluator. 你可以自定义TypeEvaluator.  </p>
<p>ValueAnimator与ObjectAnimator类似, 只是它不能直接指定目标属性和更新属性值, 需要在监听器中去设置.<br><img src="/images/blogs/valueanimator.png" alt="valueanimator">  </p>
<p>属性动画也可以通过XML来定义, 这里不再贴代码了.  </p>
<p>AnimationSet可以将多个动画组合到一起, 还可以设置集合中动画的播放顺序, 这在实现复杂的动画效果时很有用.  </p>
<p>至此, 对属性动画的使用就只缺了解其XML属性集合/API这样繁琐而简单的操作.  </p>
<p>扩展阅读: <a href="https://developer.android.com/guide/topics/graphics/prop-animation.html#keyframes" target="_blank" rel="external">Keyframe</a>与<a href="https://developer.android.com/reference/android/animation/PropertyValuesHolder.html" target="_blank" rel="external">PropertyValuesHolder</a>  </p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>回顾一下本节开头提出的需求:  </p>
<ul>
<li>想让一段文本横向缓缓移动, 就像跑马灯一样的效果.  </li>
<li>一段文本或者图片我希望把它放大和缩小, 但是不能是那种一点没有过渡的一步到位.  </li>
<li>想让一个百变怪的图像变形成皮卡丘.  </li>
</ul>
<p>对以上问题我们应该可以给出解决方案了: 1. 位移动画TranslateAnimation; 2. ScaleAnimation; 3. DrawableAnimation.  </p>
<p>以上几种动画效果, 我做了一个演示图片:  </p>
<p><img src="/images/blogs/animation_demo.gif" alt="animation_demo">  </p>
<h3 id="其他动画"><a href="#其他动画" class="headerlink" title="其他动画"></a>其他动画</h3><p>我们还可以为Layout和Activity指定使用的动画资源, 例如Layout可以定义LayoutAnimation, 它类似AnimationSet. Activity可以调用overridePendingTransition指定进入和退出时使用的动画资源.<br>自从Lollipop之后, Android加入了很多酷炫的动画效果, 例如水滴, 波纹等, 这一部分还有待扩展了解.<br>看到这里, 想必读者看见上面那些开源动画中”XXXAnimator”这样的名字, 心里也会对它背后的实现有所猜测了. 事实上打开源码一看, 果然如此, 这些开源项目终于看起来没那么神秘了. 我有一个大胆的想法…</p>
<h2 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h2><p>咱们忽略简单的补间动画和帧动画, 直奔属性动画. 属性动画这么神奇, 它的内部是怎么实现的呢?<br>再看上文的示例代码:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mObjectAnimator = ObjectAnimator</div><div class="line">                .ofFloat(mObjectAnimatorIv, &quot;alpha&quot;, 1, 0)</div><div class="line">                .setDuration(1000);</div><div class="line">                .setInterpolator(new AccelerateDecelerateInterpolator());</div><div class="line">                .setRepeatCount(1);</div><div class="line">                .setRepeatMode(ValueAnimator.REVERSE);</div><div class="line">                .addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                                float cVal = (Float) animation.getAnimatedValue();</div><div class="line">                                mObjectAnimatorIv.setScaleX(cVal);</div><div class="line">                                mObjectAnimatorIv.setScaleY(cVal);</div><div class="line">                        &#125;</div><div class="line">                &#125;)</div><div class="line">                .start();</div></pre></td></tr></table></figure>
<p>这段代码做了什么事情很好理解. 我们考虑一下, 如果是让我们来实现这个ObjectAnimator类, 怎么做?<br>首先利用建造者模式设置各种属性/插值器/估值器/监听器. 在<code>start()</code>之后, 开启一个计时器线程, 每过一段特定的时间(该时间由插值器计算出), 就让插值器计算当前目标属性应该是什么值, 计算好后通过反射把值赋给目标属性, 然后检查生命周期并调用回调函数. 大致上应该就是这么个思路, 相信源码即便会复杂些, 基本原则也一样.  </p>
<h3 id="分步解析ObjectAnimator"><a href="#分步解析ObjectAnimator" class="headerlink" title="分步解析ObjectAnimator"></a>分步解析ObjectAnimator</h3><p>源码是<code>android.animation.ObjectAnimator.java</code>我们就不贴大段代码了, 仅贴关键内容.  </p>
<p>首先是<code>ofFloat</code>, 用前两个参数实例化<code>ObjectAnimator</code>并用第三个参数调用<code>setFloatValues()</code>, 最后返回实例化的<code>ObjectAnimator</code>. <code>setFloatValues</code>时, 如果mValues为空, 实际是调用<code>PropertyValuesHolder.ofFloat()</code>来得到值. 看<code>PropertyValuesHolder</code>源码得知它用来保存动画期间关键帧及各帧的值, 这好理解, 刚开始的时候初末帧就是关键帧, 初末值就是对应帧的值, 有了这两个再加上插值器就可以计算有多少个帧, 当然目前还只有两个.<br>一句话总结就是, <code>ofFloat</code>记录了要实施动画的对象及属性, 其中属性, 属性类型及关键帧集合都被封装到一个<code>PropertyValuesHolder</code>对象中, <code>ObjectAnimator</code>的<code>mValues</code>数组保存这个对象.  </p>
<p>接着是<code>setDuration(),setRepeatCount(),setRepeatMode()</code>我觉得这三个应该差不多就一起看了. 果不其然, 里面直接调用的它的父类<code>ValueAnimator</code>的同名方法, 保存对应的值, 没什么好说的.  </p>
<p>接着是<code>setInterpolator</code>. 调用的父类<code>ValueAnimator</code>的函数保存插值器, 默认是<code>LinearInterpolator</code>, 没什么好说的.<br>我们这里没有设置估值器, 但也一并看了吧. <code>setEvaluator</code>同样调用的父类方法, 往<code>mValues</code>数组第一个元素设置估值器, 调用<code>PropertyValuesHolder.setEvaluator</code>, 保存了估值器.  </p>
<p>接着是<code>addUpdateListener</code>, 同样是父类方法, 添加监听器到成员变量<code>ArrayList&lt;&gt; mUpdateListeners</code>中, 类型是<code>AnimatorUpdateListener</code>. 可以料想后面某处会遍历这个列表, 逐个回调.  </p>
<p>最后是<code>start</code>. 深呼吸一下, 这个方法显然是重头戏.<br>贴上完整代码以示尊重:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">// in ObjectAnimator</div><div class="line">@Override</div><div class="line">public void start() &#123;</div><div class="line">    // See if any of the current active/pending animators need to be canceled</div><div class="line">    AnimationHandler handler = sAnimationHandler.get(); // AnimationHandler是ValueAnimator的隐藏私有静态内部类, 5.0曾一度实现Runnable, 后来改用Runnable匿名内部类, 稍后我们会看它的源码. 在4.0版本它不是隐藏的, 并且是继承自Handler类, 这解释了它的名字. sAnimationHandler类型为 ThreadLocal&lt;AnimationHandler&gt;</div><div class="line">    if (handler != null) &#123;</div><div class="line">        int numAnims = handler.mAnimations.size();</div><div class="line">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class="line">                ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i);</div><div class="line">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class="line">                    anim.cancel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        numAnims = handler.mPendingAnimations.size();</div><div class="line">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123;</div><div class="line">                ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i);</div><div class="line">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class="line">                    anim.cancel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        numAnims = handler.mDelayedAnims.size();</div><div class="line">        for (int i = numAnims - 1; i &gt;= 0; i--) &#123;</div><div class="line">            if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123;</div><div class="line">                ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i);</div><div class="line">                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123;</div><div class="line">                    anim.cancel();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; // 以上用于判断队列中是否有需要取消的动画, 以下是真正的执行函数</div><div class="line">    ... // debug code</div><div class="line">    super.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// in ValueAnimator</div><div class="line">@Override</div><div class="line">public void start() &#123;</div><div class="line">    start(false); // ObjectAnimator调用start()时, 均是以正向方式播放动画</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Start the animation playing. This version of start() takes a boolean flag that indicates</div><div class="line"> * whether the animation should play in reverse. The flag is usually false, but may be set</div><div class="line"> * to true if called from the reverse() method.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;The animation started by calling this method will be run on the thread that called</div><div class="line"> * this method. This thread should have a Looper on it (a runtime exception will be thrown if</div><div class="line"> * this is not the case). Also, if the animation will animate</div><div class="line"> * properties of objects in the view hierarchy, then the calling thread should be the UI</div><div class="line"> * thread for that view hierarchy.&lt;/p&gt;</div><div class="line"> *</div><div class="line"> * @param playBackwards Whether the ValueAnimator should start playing in reverse.</div><div class="line"> */</div><div class="line">private void start(boolean playBackwards) &#123;</div><div class="line">    if (Looper.myLooper() == null) &#123;</div><div class="line">        throw new AndroidRuntimeException(&quot;Animators may only be run on Looper threads&quot;);</div><div class="line">    &#125;</div><div class="line">    mReversing = playBackwards;</div><div class="line">    mPlayingBackwards = playBackwards;</div><div class="line">    // 倒放时更新mSeekFraction</div><div class="line">    if (playBackwards &amp;&amp; mSeekFraction != -1) &#123;</div><div class="line">        if (mSeekFraction == 0 &amp;&amp; mCurrentIteration == 0) &#123;</div><div class="line">            // special case: reversing from seek-to-0 should act as if not seeked at all</div><div class="line">            mSeekFraction = 0;</div><div class="line">        &#125; else if (mRepeatCount == INFINITE) &#123;</div><div class="line">            mSeekFraction = 1 - (mSeekFraction % 1);</div><div class="line">        &#125; else &#123;</div><div class="line">            mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);</div><div class="line">        &#125;</div><div class="line">        mCurrentIteration = (int) mSeekFraction;</div><div class="line">        mSeekFraction = mSeekFraction % 1;</div><div class="line">    &#125;</div><div class="line">    // 判断当前播放方向</div><div class="line">    if (mCurrentIteration &gt; 0 &amp;&amp; mRepeatMode == REVERSE &amp;&amp;</div><div class="line">            (mCurrentIteration &lt; (mRepeatCount + 1) || mRepeatCount == INFINITE)) &#123;</div><div class="line">        // if we were seeked to some other iteration in a reversing animator,</div><div class="line">        // figure out the correct direction to start playing based on the iteration</div><div class="line">        if (playBackwards) &#123;</div><div class="line">            mPlayingBackwards = (mCurrentIteration % 2) == 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            mPlayingBackwards = (mCurrentIteration % 2) != 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 更新播放状态</div><div class="line">    int prevPlayingState = mPlayingState; // 保存上一个状态</div><div class="line">    mPlayingState = STOPPED;</div><div class="line">    mStarted = true;</div><div class="line">    mStartedDelay = false;</div><div class="line">    mPaused = false;</div><div class="line">    updateScaledDuration(); // in case the scale factor has changed since creation time</div><div class="line">    AnimationHandler animationHandler = getOrCreateAnimationHandler();</div><div class="line">    animationHandler.mPendingAnimations.add(this); // 当前动画添加进AnimationHandler等待队列</div><div class="line">    if (mStartDelay == 0) &#123; // 未设置时默认mStartDelay为0</div><div class="line">        // This sets the initial value of the animation, prior to actually starting it running</div><div class="line">        if (prevPlayingState != SEEKED) &#123;</div><div class="line">            setCurrentPlayTime(0); // 见下文解释</div><div class="line">        &#125;</div><div class="line">        mPlayingState = STOPPED;</div><div class="line">        mRunning = true;</div><div class="line">        notifyStartListeners(); // 通知监听器, 回调AnimatorListener.onAnimationStart方法. 注意, 早于动画真正开始</div><div class="line">    &#125;</div><div class="line">    animationHandler.start(); // 最终调用AnimationHandler.start()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上有一些地方需要解释一下: <code>mCurrentIteration</code>指当前是第几次播放动画; <code>getOrCreateAnimationHandler</code>顾名思义是尝试从<code>ThreadLocal</code>中获取Handler, 为空的话就创建一个; <code>setCurrentPlayTime()</code>顾名思义是设置当前播放时间, 该时间必须在0到持续时间之间. 其内部调用<code>setCurrentFraction(fraction)</code>设置当前播放的片段, 比如<code>fraction==1.3</code>就表示当前在播放第2次的0.3这部分. 在上述代码中此时<code>fraction==0</code>. 内部最后再调用<code>animateValue</code>将片段动画化, 这个函数稍后我们还会看到. 该函数首先调用<code>fraction = mInterpolator.getInterpolation(fraction)</code>使用插值器获取计算后的当前<code>fraction</code>值, 然后遍历<code>mValues</code>调用<code>calculateValue(fraction)</code>(内部使用<code>mAnimatedValue = mKeyframeSet.getValue(fraction)</code>获取各帧的当前属性值, 估值器就是在这个<code>getValue</code>函数里调用的), 显然这就是在<strong>计算此时的属性值</strong>了, 紧接着通过<code>PropertyValuesHolder.setAnimatedValue(Object target)</code>以反射的方式把值写回目标属性. 再遍历<code>mUpdateListeners</code>调用<code>onAnimationUpdate(this)</code>.  </p>
<p>最后来看<code>AnimationHandler.start()</code>.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div></pre></td><td class="code"><pre><div class="line">// in ValueAnimator</div><div class="line">    final boolean doAnimationFrame(long frameTime) &#123;</div><div class="line">        // 更新动画状态</div><div class="line">        if (mPlayingState == STOPPED) &#123;</div><div class="line">            mPlayingState = RUNNING;</div><div class="line">            if (mSeekFraction &lt; 0) &#123;</div><div class="line">                mStartTime = frameTime;</div><div class="line">            &#125; else &#123;</div><div class="line">                long seekTime = (long) (mDuration * mSeekFraction);</div><div class="line">                mStartTime = frameTime - seekTime;</div><div class="line">                mSeekFraction = -1;</div><div class="line">            &#125;</div><div class="line">            mStartTimeCommitted = false; // allow start time to be compensated for jank</div><div class="line">        &#125;</div><div class="line">        if (mPaused) &#123;</div><div class="line">            if (mPauseTime &lt; 0) &#123;</div><div class="line">                mPauseTime = frameTime;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125; else if (mResumed) &#123;</div><div class="line">            mResumed = false;</div><div class="line">            if (mPauseTime &gt; 0) &#123;</div><div class="line">                // Offset by the duration that the animation was paused</div><div class="line">                mStartTime += (frameTime - mPauseTime);</div><div class="line">                mStartTimeCommitted = false; // allow start time to be compensated for jank</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // The frame time might be before the start time during the first frame of</div><div class="line">        // an animation.  The &quot;current time&quot; must always be on or after the start</div><div class="line">        // time to avoid animating frames at negative time intervals.  In practice, this</div><div class="line">        // is very rare and only happens when seeking backwards.</div><div class="line">        final long currentTime = Math.max(frameTime, mStartTime);</div><div class="line">        return animationFrame(currentTime); // 真正的动画处理函数</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    boolean animationFrame(long currentTime) &#123; // 真正的动画处理函数</div><div class="line">        boolean done = false;</div><div class="line">        switch (mPlayingState) &#123;</div><div class="line">        case RUNNING:</div><div class="line">        case SEEKED:</div><div class="line">            // 计算当前fraction</div><div class="line">            float fraction = mDuration &gt; 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;</div><div class="line">            if (mDuration == 0 &amp;&amp; mRepeatCount != INFINITE) &#123;</div><div class="line">                // Skip to the end</div><div class="line">                mCurrentIteration = mRepeatCount;</div><div class="line">                if (!mReversing) &#123;</div><div class="line">                    mPlayingBackwards = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (fraction &gt;= 1f) &#123;</div><div class="line">                if (mCurrentIteration &lt; mRepeatCount || mRepeatCount == INFINITE) &#123;</div><div class="line">                    // Time to repeat</div><div class="line">                    if (mListeners != null) &#123;</div><div class="line">                        int numListeners = mListeners.size();</div><div class="line">                        for (int i = 0; i &lt; numListeners; ++i) &#123;</div><div class="line">                            mListeners.get(i).onAnimationRepeat(this); // 回调监听器的onAnimationRepeat()</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    if (mRepeatMode == REVERSE) &#123;</div><div class="line">                        mPlayingBackwards = !mPlayingBackwards;</div><div class="line">                    &#125;</div><div class="line">                    mCurrentIteration += (int) fraction;</div><div class="line">                    fraction = fraction % 1f;</div><div class="line">                    mStartTime += mDuration;</div><div class="line">                    // Note: We do not need to update the value of mStartTimeCommitted here</div><div class="line">                    // since we just added a duration offset.</div><div class="line">                &#125; else &#123;</div><div class="line">                    done = true;</div><div class="line">                    fraction = Math.min(fraction, 1.0f);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (mPlayingBackwards) &#123;</div><div class="line">                fraction = 1f - fraction;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 根据当前fraction将目标属性值动画化, 该函数的分析见上一段落.</div><div class="line">            animateValue(fraction);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return done;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * This custom, static handler handles the timing pulse that is shared by</div><div class="line">     * all active animations. This approach ensures that the setting of animation</div><div class="line">     * values will happen on the UI thread and that all animations will share</div><div class="line">     * the same times for calculating their values, which makes synchronizing</div><div class="line">     * animations possible.</div><div class="line">     *</div><div class="line">     * The handler uses the Choreographer for executing periodic callbacks.</div><div class="line">     *</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    protected static class AnimationHandler &#123;</div><div class="line">        // The per-thread list of all active animations</div><div class="line">        /** @hide */</div><div class="line">        protected final ArrayList&lt;ValueAnimator&gt; mAnimations = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line"></div><div class="line">        // Used in doAnimationFrame() to avoid concurrent modifications of mAnimations</div><div class="line">        private final ArrayList&lt;ValueAnimator&gt; mTmpAnimations = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line"></div><div class="line">        // The per-thread set of animations to be started on the next animation frame</div><div class="line">        /** @hide */</div><div class="line">        protected final ArrayList&lt;ValueAnimator&gt; mPendingAnimations = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Internal per-thread collections used to avoid set collisions as animations start and end</div><div class="line">         * while being processed.</div><div class="line">         * @hide</div><div class="line">         */</div><div class="line">        protected final ArrayList&lt;ValueAnimator&gt; mDelayedAnims = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line">        private final ArrayList&lt;ValueAnimator&gt; mEndingAnims = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line">        private final ArrayList&lt;ValueAnimator&gt; mReadyAnims = new ArrayList&lt;ValueAnimator&gt;();</div><div class="line"></div><div class="line">        private final Choreographer mChoreographer;</div><div class="line">        private boolean mAnimationScheduled;</div><div class="line">        private long mLastFrameTime;</div><div class="line"></div><div class="line">        private AnimationHandler() &#123;</div><div class="line">            mChoreographer = Choreographer.getInstance();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Start animating on the next frame.</div><div class="line">         */</div><div class="line">        public void start() &#123;</div><div class="line">            scheduleAnimation(); // 入口函数</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        void doAnimationFrame(long frameTime) &#123;</div><div class="line">            mLastFrameTime = frameTime;</div><div class="line"></div><div class="line">            // mPendingAnimations holds any animations that have requested to be started</div><div class="line">            // We&apos;re going to clear mPendingAnimations, but starting animation may</div><div class="line">            // cause more to be added to the pending list (for example, if one animation</div><div class="line">            // starting triggers another starting). So we loop until mPendingAnimations</div><div class="line">            // is empty.</div><div class="line">            while (mPendingAnimations.size() &gt; 0) &#123; // 是一个宽度优先遍历动画队列</div><div class="line">                ArrayList&lt;ValueAnimator&gt; pendingCopy =</div><div class="line">                        (ArrayList&lt;ValueAnimator&gt;) mPendingAnimations.clone(); // 拷贝队列</div><div class="line">                mPendingAnimations.clear(); // 清空原队列</div><div class="line">                int count = pendingCopy.size();</div><div class="line">                for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                    ValueAnimator anim = pendingCopy.get(i);</div><div class="line">                    // If the animation has a startDelay, place it on the delayed list</div><div class="line">                    if (anim.mStartDelay == 0) &#123;</div><div class="line">                        anim.startAnimation(this); // 调用ValueAnimator.startAnimation开始动画, 可能会导致向原等待队列添加动画</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mDelayedAnims.add(anim); // 添加到延迟动画队列</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Next, process animations currently sitting on the delayed queue, adding</div><div class="line">            // them to the active animations if they are ready</div><div class="line">            int numDelayedAnims = mDelayedAnims.size();</div><div class="line">            for (int i = 0; i &lt; numDelayedAnims; ++i) &#123; // 遍历延迟动画队列, 将已到达时点的动画添加进就绪动画队列(注意没有从延迟队列移除)</div><div class="line">                ValueAnimator anim = mDelayedAnims.get(i);</div><div class="line">                if (anim.delayedAnimationFrame(frameTime)) &#123;</div><div class="line">                    mReadyAnims.add(anim);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            int numReadyAnims = mReadyAnims.size();</div><div class="line">            if (numReadyAnims &gt; 0) &#123; // 遍历就绪动画队列, 调用ValueAnimator.startAnimation开始动画, 并从延迟动画队列中移除</div><div class="line">                for (int i = 0; i &lt; numReadyAnims; ++i) &#123;</div><div class="line">                    ValueAnimator anim = mReadyAnims.get(i);</div><div class="line">                    anim.startAnimation(this);</div><div class="line">                    anim.mRunning = true;</div><div class="line">                    mDelayedAnims.remove(anim);</div><div class="line">                &#125;</div><div class="line">                mReadyAnims.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Now process all active animations. The return value from animationFrame()</div><div class="line">            // tells the handler whether it should now be ended</div><div class="line">            int numAnims = mAnimations.size();</div><div class="line">            for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class="line">                mTmpAnimations.add(mAnimations.get(i));</div><div class="line">            &#125;</div><div class="line">            for (int i = 0; i &lt; numAnims; ++i) &#123; // 遍历动画队列, 调用ValueAnimator.doAnimationFrame, 如动画已结束则添加进结束动画队列</div><div class="line">                ValueAnimator anim = mTmpAnimations.get(i);</div><div class="line">                if (mAnimations.contains(anim) &amp;&amp; anim.doAnimationFrame(frameTime)) &#123;</div><div class="line">                    mEndingAnims.add(anim);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            mTmpAnimations.clear();</div><div class="line">            if (mEndingAnims.size() &gt; 0) &#123; // 遍历结束动画队列, 回调endAnimation, 然后清空队列.</div><div class="line">                for (int i = 0; i &lt; mEndingAnims.size(); ++i) &#123;</div><div class="line">                    mEndingAnims.get(i).endAnimation(this);</div><div class="line">                &#125;</div><div class="line">                mEndingAnims.clear();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Schedule final commit for the frame.</div><div class="line">            mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, mCommit, null); // 发送mCommit回调. mCommit的定义见下面</div><div class="line"></div><div class="line">            // If there are still active or delayed animations, schedule a future call to</div><div class="line">            // onAnimate to process the next frame of the animations.</div><div class="line">            // 为还没有处理完的动画和延迟动画安排新一次的处理</div><div class="line">            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) &#123;</div><div class="line">                scheduleAnimation();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        void commitAnimationFrame(long frameTime) &#123; // 结束本帧</div><div class="line">            final long adjustment = frameTime - mLastFrameTime;</div><div class="line">            final int numAnims = mAnimations.size();</div><div class="line">            for (int i = 0; i &lt; numAnims; ++i) &#123;</div><div class="line">                mAnimations.get(i).commitAnimationFrame(adjustment);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private void scheduleAnimation() &#123;</div><div class="line">            if (!mAnimationScheduled) &#123;</div><div class="line">                mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, mAnimate, null);</div><div class="line">                mAnimationScheduled = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Called by the Choreographer.</div><div class="line">        final Runnable mAnimate = new Runnable() &#123; // 匿名内部类, 调用真正的动画函数</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                mAnimationScheduled = false;</div><div class="line">                doAnimationFrame(mChoreographer.getFrameTime()); // 这里调用的是AnimationHandler.doAnimationFrame</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        // Called by the Choreographer.</div><div class="line">        final Runnable mCommit = new Runnable() &#123; // 匿名内部类, 结束本帧动画后调用</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                commitAnimationFrame(mChoreographer.getFrameTime());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用路径: <code>start -&gt; scheduleAnimation -&gt; Choreographer.postCallback(Choreographer.CALLBACK_ANIMATION, mAnimate, null) -&gt; run -&gt; doAnimationFrame</code>, 中间大概能猜到是一些消息发送和处理机制, 暂时我们按下不看, 细看<code>doAnimationFrame</code>. 传入的参数是<code>mChoreographer.getFrameTime()</code>, 也就是当前帧时间. 在该方法中, 依次处理了 立即执行动画/延迟动画/就绪动画/正在处理的动画/结束动画 这种情况的动画或动画列表, 最后对于还没处理完的动画则发起新的<code>scheduleAnimation</code>调用, 开始新一轮循环.  </p>
<p>到此, 整个动画的执行过程就清清楚楚了. 回想一下, 是不是跟我们预先设想的其实差不多?  </p>
<p>总结一下, <code>ObjectAnimator</code>动画的工作流程大致如下:  </p>
<ol>
<li>通过<code>ofXXX</code>实例化一个<code>ObjectAnimator</code>对象, 设置它的目标/属性名/mValues: PropertyValuesHolder[], 设置持续时间和插值器/估值器. PropertyValuesHolder用于保存动画过程每一帧的信息.  </li>
<li>在调用<code>start()</code>开始动画之后, 首先更新当前动画状态, 根据当前执行时间/总持续时间, 得到当前执行的比例(fraction), 把这个fraction交给插值器得到新的fraction, 再给估值器, 计算目标属性的当前值, 并通过反射把这个值赋给目标属性.  </li>
<li>完成赋值之后, 调用<code>AnimationHandler.start</code>开始更新动画. 利用<code>Choreographer</code>发送任务, 在执行任务时对于立即执行的动画, 调用<code>ValueAnimator.doAnimationFrame</code>完成真正的动画操作, 对于延迟动画/就绪动画/已结束动画则更新它们的状态. 如此反复直到所有动画处理完毕.  </li>
</ol>
<h3 id="动画的灵魂-数学"><a href="#动画的灵魂-数学" class="headerlink" title="动画的灵魂: 数学"></a>动画的灵魂: 数学</h3><p>这里我们讲解动画另一方面重要的内容: 数学.  </p>
<p>诚然, 即便我们对数学不是那么精通, 也能够在知道效果的情况下反推出实现效果需要的数学运算, 这应该也是大多数工程师的第一反应. 然而在数学或者说算法基础扎实的情况下, 我们往往能够很快找到更快更好的实现方式, 也能更容易去理解别人代码中的本质和嗅到可以优化的地方. 有时候一些复杂的动画效果, 我们也可以通过数学方法将之分解为简单的部分从而让问题迎刃而解.<br>(为什么我们这里没有说”算法”? 因为动画是非常具体的形象, 它需要的往往不止”算法”, 还要借用”几何”甚至”数论”的思想和工具, 而这些都可以算在数学的范畴内.)  </p>
<p>为了让模拟真实世界的动画效果显得更真实, 我们需要知道真实世界中的运动规律. 众多数学家和物理学家, 已经为我们总结出了很多宏观世界的运动规律, 我们这些麻瓜只要活学活用就好.  </p>
<p>举个例子, 弹跳效果. 不考虑介质阻力的情况下, 弹跳轨迹与初速度/质量/落点高度/重力加速度等相关, 所以我们如果要让动画中的弹球像真实世界一样弹跳, 就需要定义它的各项属性按照真实世界中弹跳的过程来变化, 而这个变化规律就需要数学描述.<br>于是我们只要描述各个属性值的时间函数, 就可以知道在任一时点各个属性的值. 这个描述是不是很耳熟? 没错, 这就是插值器<code>Interpolator</code>做的事.<br>事实上, 插值器也可以看做是对”时间”这一维度做了映射, 前面说过在不设置<code>TypeEvaluator</code>的情况下, 就会直接按照比例分配属性的值了, 相当于是一个”线性映射”: <code>x_new = x + x_total_delta * (time_now - time_start) / time_duration</code>. 这么个函数别看简单, 其实是<code>TypeEvaluator(Interpolator())</code>两个函数的复合函数呢.<br>回到弹跳效果. 我们可以定义一个<code>BounceInterpolator</code>和一个<code>BounceEvaluator</code>, 分别完成对弹球过程中各个时点和各时点下的位移值的描述, 这样就能够实现弹球动画了. 事实上, <code>Android</code>源码中已经为我们预定义了弹跳插值器, 诶, 名字还就叫<code>BounceInterpolator</code>, 感兴趣的同学可以打开源码看看它里面定义的函数.  </p>
<p><strong>插值器和估值器, 两个函数复合成一个动画函数, 这就是属性动画的数学本质.</strong> 以我们对数学的理解, 当然知道在某些情况下, 这个复合函数可以退化成一个简单函数, 什么情况呢? 插值器或估值器其中一个是完全线性映射, 也就是说, 什么都不做, 喂什么吐什么. 在简单函数时, 从效果上来说, 无论我们用插值器还是估值器, 都可以将描述函数转化为动画效果, 他们两个是等价的. 只是从逻辑上我还是希望大家能将这两种概念分清楚, 这样有助于理解源码中所定义的那些插值器和估值器.  </p>
<p>关于从数学角度理解动画, 以及更多的跟动画有关的函数, <a href="https://hujiaweibujidao.github.io/blog/2016/05/28/when-math-meets-android-animation-3/" target="_blank" rel="external">潇湘同学的博客</a>有详细阐述.  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用动画时要特别注意动画的生命周期处理, 播放完成的动画应及时<code>clear</code>, 否则容易引起OOM/内存泄漏/视图显示和事件响应不按预计的方式进行等问题.  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://developer.android.com/guide/topics/graphics/index.html" target="_blank" rel="external">官网 Animation Guide</a>  </li>
<li><a href="http://www.jianshu.com/p/b7aa2a4a9787" target="_blank" rel="external">Android动画，一篇就够</a>  </li>
<li><a href="http://blog.csdn.net/yanbober/article/details/46481171" target="_blank" rel="external">Android应用开发之所有动画使用详解</a>  </li>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/17841165" target="_blank" rel="external">Android属性动画深入分析：让你成为动画牛人</a>  </li>
<li><p><a href="http://androidxref.com" target="_blank" rel="external">AndroidXRef</a>  </p>
</li>
<li><p><a href="https://github.com/daimajia/AndroidViewAnimations" target="_blank" rel="external">github/daimajia/AndroidViewAnimations</a>  </p>
</li>
<li><a href="https://github.com/hujiaweibujidao/FabDialogMorph" target="_blank" rel="external">github/hujiaweibujidao/FabDialogMorph</a>  </li>
<li><a href="https://github.com/hujiaweibujidao/wava" target="_blank" rel="external">github/hujiaweibujidao/wava</a>  </li>
<li><a href="https://github.com/hujiaweibujidao/yava" target="_blank" rel="external">github/hujiaweibujidao/yava</a>  </li>
<li><a href="https://github.com/yanbober/SlideLayout" target="_blank" rel="external">github/yanbober/SlideLayout</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      说来惭愧, 接触Android这么久可UI和Animation一直是涉足未深的盲点, 今天就来解...
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>初涉mmap</title>
    <link href="https://hjhjw1991.github.io/android/2017/05/02/%E5%88%9D%E6%B6%89mmap/"/>
    <id>https://hjhjw1991.github.io/android/2017/05/02/初涉mmap/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2017-05-02T06:59:27.044Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在Native开发中遇到mmap, 于是有了这篇文章.  </p>
</blockquote>
<p>目录:  </p>
<ul>
<li>是什么  </li>
<li>为什么  </li>
<li>怎么用  </li>
</ul>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>mmap: Memory-map. 可翻译成内存映射, 这是一种文件I/O操作, 它将文件(linux世界中, 设备也是文件)映射到内存中, 用户可以像操作内存一样操作文件.<br>mmap以及相关系统调用包含在Unix的BSD(Berkeley Software Distribution)4.2版本的设计中, 然而最先实现mmap接口的是Sun公司, BSD开发者向Sun要代码没要到, 最后BSD上的实现是基于虚拟内存系统Mach中的版本.  </p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h3 id="mmap原理"><a href="#mmap原理" class="headerlink" title="mmap原理"></a>mmap原理</h3><p>mmap将文件映射到连续的内存区域, 使进程的地址空间中某一段与被映射的文件(或共享内存)的地址一一对应.<br>无论内核态还是用户态都只是进程所处的一种状态, 进程拥有自己的虚拟地址空间, 但是物理区块是只有一份的, 只是这一份物理区块在不同进程中的地址不同而已. 基于这个事实, 我们只要让自己进程的一段虚拟地址, 指向我们想要载入的物理文件所在的位置, 那么对这段虚拟地址的操作, 就可以直接反映在物理文件上, 看起来就像我们已经载入(从内核空间拷贝内容到用户空间内存)了文件一样.<br>具体来说, 可以分为三个阶段:  </p>
<ol>
<li>在用户空间调用mmap函数, 分配一块连续的满足要求的虚拟地址空间, 并将代表该空间的数据结构初始化后插入进程的虚拟地址区域链表中.  </li>
<li>根据mmap参数, 找到待映射文件的文件描述符, 标记为已打开, 调用内核mmap函数, 定位到文件磁盘物理地址, 建立页表实现文件地址和虚拟地址区域的映射关系. 至此地址映射完成, 但尚未拷贝数据到内存.  </li>
<li>进程访问虚拟地址空间中该文件所在地址, 引发缺页异常使文件拷贝到主存, 然后就可以对这片区域进行读写操作了.<br>虽然原理很简单, 但实际实现的时候有许多问题需要注意, 比如多个进程访问同一个文件的时候, 如果有进程写文件怎么处理. 根据参数的不同, 可能有不同的处理方式. 例如共享内存<code>MAP_SHARED</code>方式下, 写操作会立即对其他进程可见, 但实际将脏数据写回到文件却是经过一定时间或在msync系统调用之后. 而如果是<code>MAP_PRIVATE</code>方式, 则任何写操作都会引起第二次内存拷贝, 文件数据被拷贝到进程内存空间, 对其他进程不可见, 并且也不会写回文件.  </li>
</ol>
<h3 id="mmap与文件操作的区别"><a href="#mmap与文件操作的区别" class="headerlink" title="mmap与文件操作的区别"></a>mmap与文件操作的区别</h3><p>linux还有一套文件操作的系统调用, 即<code>open read write</code>, mmap与他们区别在哪儿呢?<br>最大的区别就在于, 普通文件读写操作, 需要借助处于内核空间的页缓存作为中转, 将数据载入主存, 而mmap却是逻辑映射到物理文件, 直接载入数据到主存.<br>前者总是向页缓存索取数据, 内核通过查找页缓存来判断能否立即返回数据, 在未缓存的情况下, 先从物理磁盘拷贝数据到页缓存, 再从页缓存拷贝数据到用户空间中, 写回时也是同样, 需要先将用户空间的文件缓存拷贝到内核空间, 再由内核写回到磁盘, 都需要经过<strong>两次拷贝</strong>.<br>后者则是在发现需要载入数据时, 通过事先建立的页表映射关系, 直接由内核将数据拷贝到用户空间, <strong>一次拷贝</strong>.<br>因此, mmap理论上来说效率更高.  </p>
<h3 id="mmap优势"><a href="#mmap优势" class="headerlink" title="mmap优势"></a>mmap优势</h3><ol>
<li>不使用页缓存机制, 减少一次拷贝.  </li>
<li>用户空间和内核空间对同一片区域的修改都可以直接反映在对方映射区域内, 提高了交互效率.  </li>
<li>为共享内存和IPC通信提供一种方式.  </li>
</ol>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>mmap尽管有些优势, 但并不是万能药, 例如如果你要处理的文件大到很难为之分配一个连续的虚拟地址空间, 或者你想要访问的地址的偏移量不是物理页大小(page_size)的整数倍(此时你需要自己解决偏移量问题), 甚至有些情况下, read/write是与目标文件交互的唯一方式, 见<a href="http://stackoverflow.com/a/258097/3996521" target="_blank" rel="external">SOF: when-should-use-mmap</a>.<br>mmap可以用于实现共享内存, 如上问所述.<br>Binder的底层使用mmap, 所以Binder才能做到只拷贝一次数据.<br>在使用mmap时有些要点需要注意:  </p>
<ol>
<li>由于mmap的映射是基于页大小的, 所以它一定会映射整数个页面, 哪怕你用不到那么多. 比如5000 byte数据需要2*4k(2个页)空间, 但5000~8191读写不报错但不会反映到文件中, 读为0, 写丢失.  </li>
<li>无论你声明要使用多大空间, mmap都只会映射刚好够用的页面数量, 所以访问已映射的页面之外的地址, 会报错. 比如原始文件大小5000 byte, 声明要映射15000 byte, 那么仅前5000 byte可正常读写, 5000~8191同上, 不报错但读为0写丢失. 8192~14999无法读写, 报SIGBUS错误. 15000及以上无法读写, 报SIGSEGV错误. 如果确实需要写5000以上的位置, 那么需要在写之前增加文件大小.  </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="external">wikipedia-mmap</a>  </li>
<li><a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用</a>  </li>
<li><a href="http://stackoverflow.com/a/258097/3996521" target="_blank" rel="external">SOF: when-should-use-mmap</a>  </li>
<li><a href="http://blog.csdn.net/yusiguyuan/article/details/23388771" target="_blank" rel="external">linux内存映射mmap原理分析</a>  </li>
<li><a href="http://blog.csdn.net/yinjiabin/article/details/7575653" target="_blank" rel="external">linux中mmap系统调用原理分析与实现</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      在Native开发中遇到mmap, 于是有了这篇文章.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity中launchMode的理解</title>
    <link href="https://hjhjw1991.github.io/android/2017/04/28/Activity%E4%B8%ADlaunchMode%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/04/28/Activity中launchMode的理解/</id>
    <published>2017-04-27T16:00:00.000Z</published>
    <updated>2017-05-02T02:20:44.491Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道, <code>Activity</code>需要配置在<code>AndroidManifest.xml</code>中才能正常启动, 其原因是launcher需要它来判断应当从哪个Apk中启动哪个Class. 在配置<code>Activity</code>的时候, 有一个属性叫做<code>launchMode</code>, 它对<code>Activity</code>的启动和退出影响颇大, 今天我们就来深入了解一下这个属性以及其背后的逻辑.  </p>
<h2 id="launchMode属性"><a href="#launchMode属性" class="headerlink" title="launchMode属性"></a>launchMode属性</h2><blockquote>
<p>本节内容可自行写demo验证理解</p>
</blockquote>
<p>翻阅各种参考, 我们知道(截至本文成文之日)<code>launchMode</code>一共可以指定四种属性值, 分别是<code>standard singleTop singleTask singleInstance</code>, 其中<code>standard</code>也是默认的属性值. 那么他们分别具有怎样的作用呢?<br>总的来说, <code>launchMode</code>属性影响的是<code>Activity</code>的回退栈, 因此我们有必要先理解回退栈这一概念.<br>在<code>Activity</code>启动的时候, 我们需要考虑当它退出的时候, 下一个要展示的<code>Activity</code>是什么, 为此, <code>android</code>中维护一个<code>Task</code>, 称为任务栈, 以栈的数据结构存储启动的<code>Activity</code>. 当我们退出一个<code>Activity</code>的时候, 展示上一个启动的<code>Activity</code>, 于是在<code>Task</code>中, 只要让当前展示的<code>Activity</code>位于栈顶, 在退出时让它出栈, 就可以自然完成这样的回退逻辑. 例如从A启动B, 当我们退出B的时候, 就展示A. 以上就是最简单朴素的回退栈. 但是这里有一个问题, 就是当我们从桌面启动A时, 回退栈中似乎只有一个A, 这时候退出A, 栈就空了, 怎么办呢? 当然我们大家都知道, 这时候其实是回到了桌面的. 原因就在于, <code>Task</code>有两层概念, 第一层是, 任一应用(作为一个process)拥有自身的回退栈, 第二层是, 系统维护跨应用的全部回退栈. 于是在退出A的时候, 我们实际上是退出了当前应用的回退栈, 交由系统决定下一个要展示的回退栈, 这里就是<code>launcher</code>这个系统应用的回退栈了. 而在<code>launcher</code>中, 由于重写了<code>Back</code> <code>Home</code>按键的响应, 所以不会再退出这个应用.<br>可以用图表示如下:  </p>
<p><img src="/images/blogs/back_stack.png" alt="回退栈示意图">  </p>
<p>有了回退栈我们就知道了如何处理”退出一个Activity”这件事情. 与此相对的, “启动一个Activity”这件事情就意味着需要将<code>Activity</code>放到某个回退栈中. 如果我们完全按照以上的基本逻辑, 即每个应用拥有自身的回退栈, 并且每启动一个<code>Activity</code>就将它放到栈顶, 这就是<code>launchMode</code>的默认属性<code>standard</code>的行为. 对于<code>standard</code>的<code>Activity</code>来说, 它的实例会被放到启动它的<code>Activity</code>所在的<code>Task</code>中.  </p>
<p>很可惜现实世界不是这么简单而美好的, “标准行为”总是会引起”标准错误”. 于是就有了后面三种启动模式.<br>考虑一种情况, 我们需要在应用App1中启动应用App2的某个<code>Activity B</code>. 假设这个B以标准模式启动会有什么问题呢? 每次调用都会创建B并添加到任务栈中, 导致任务栈上茫茫多的B, 退都退不完. 更糟糕的是, 默认情况下B没有指定任务栈, 它会被放在调用它的应用的任务栈上, 这就导致你回到原来的应用界面需要穿过千山万水. 这种情形很常见, 例如点击通知栏通知, 就会跳转到指定应用的指定<code>Activity</code>, 点一百次通知就创建一百个实例这是不可接受的. 通常情况下其实只需要更新数据, 根本没必要新建一个实例. 于是我们有了<code>singleTop</code>模式. 它的作用在于, 该模式下的<code>Activity</code>实例, 如果本身已经在栈顶, 那么再次调用<code>startActivity</code>的时候, 不会创建新的实例, 而是调用已存在实例的<code>onNewIntent()</code>生命周期, 处理新传入的<code>Intent</code>. 如果实例不存在或不在栈顶, 那就跟标准模式一样创建新的实例并放在栈顶.<br>考虑另一种情况, 我们需要在A-B两个<code>Activity</code>中反复互相启动(秘技:反复横跳!), 那么就会引起问题. 由于标准模式下只是无脑启动并添加<code>Activity</code>, 就会导致回退栈中存有大量的<code>A-B-A-B-A-B</code>这样的序列, 而实际上存在多个A还是一个A对用户来说没有分别, 反而多个A导致退出的时候需要按很多次<code>Back</code>, 不胜其烦, 而<code>singleTop</code>模式也不能解决这种问题. 于是我们有了<code>singleTask</code>模式. 它的作用在于, 处于<code>singleTask</code>模式的<code>Activity</code>, 在整个<code>Task</code>之中只能有一个实例. 在启动该<code>Activity</code>的时候, 如果<code>Task</code>中没有该实例, 则新建实例并添加到任务栈, 走全新创建的生命周期, 否则将任务栈中处于该实例以上的所有<code>Activity</code>出栈, 令它处于栈顶(唯我独尊有木有!), 然后调用<code>onNewIntent()</code>周期. 它也是可以快速清空栈内<code>Activity</code>的黑科技.(思考: <code>singleTask</code>模式一定会新建一个<code>Task</code>吗?)<br>再考虑另一种情况, 某个<code>Activity</code>的功能非常单一, 我们全局只需要一个这样的实例来完成他的功能就可以了, 相当于要一个单例<code>Activity</code>. 这样的话, 以上三种模式都无法满足需要, 他们都是强调在某一个Task栈中的状态, 但处于不同的Task栈的话就没有限制了(特别说明一下<code>singleTask</code>模式, 它令Task中只有一个实例, 按理说如果我们只有一个Task的话也可以满足单例的要求, 但它的”副作用”是会清空实例以上的全部<code>Activity</code>, 这却不是我们希望的效果), 所以我们需要一个新的模式来代表这种跨Task栈的单例, 由此诞生了<code>singleInstance</code>模式. 处于该模式的<code>Activity</code>, 在被启动的时候会新建一个<code>Task</code>, 整个生命周期都在这个<code>Task</code>中, 并且这个<code>Task</code><strong>有且只有</strong>它一个实例, 无论从哪里启动它, 只要在某个<code>Task</code>中存在实例, 就会调用这个实例的<code>onNewIntent()</code>周期, 而不是新建一个实例. 这样的例子还是挺多的, 例如桌面日历, 桌面时钟.(思考: 如果指定另一个<code>Activity</code>跟这个<code>singleInstance</code>的<code>Activity</code>拥有同样的<code>Task</code>, 会怎样? 如果从这个<code>singleInstance</code>实例中启动新的<code>Activity</code>, 新的<code>Activity</code>会放在哪里?)  </p>
<p>以上就是四种启动模式的特点. 在官网中对启动模式的描述, 隐含条件是非标准启动模式都指定了<code>taskAffinity</code>属性, 故可能会引起误解.  </p>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><p>启动模式可以配合<code>taskAffinity</code>属性使用.这里来解释一下<code>taskAffinity</code>这个属性.<br>它是<code>Application</code>和<code>Activity</code>标签都有的属性, 用于指定一个<code>Task</code>的名字, 直译的话可以译作”任务归属性”或者”任务亲和性”吧. 不填写该属性的情况下, 所有<code>Activity</code>在一个以包名为名字的<code>Task</code>中, <code>Activity</code>指定了该属性时, 会被放在以该属性值为名字的<code>Task</code>中, <code>Application</code>指定了该属性时, 整个<code>Application</code>的默认<code>Task</code>以该属性值为名.<br>前文曾提出疑问, <code>singleTask</code>是否一定会新建一个<code>Task</code>, 答案是”不一定”. 以<code>singleTask</code>模式启动的<code>Activity</code>, 总是在”将要放置该Activity的Task”中检查实例, 而不指定<code>taskAffinity</code>的情况下将要放置该<code>Activity</code>的就是默认<code>Task</code>了. 实际上只有在指定了<code>taskAffinity</code>并且该<code>Task</code>还不存在的情况下, 才会新建以<code>taskAffinity</code>值命名的<code>Task</code>.<br>需要注意的是, <code>taskAffinity</code>属性是<strong>跨应用的</strong>, 你完全可以为不同的应用指定同一个<code>Task</code>. 要使该属性生效, 必须允许在启动拥有该属性的<code>Activity</code>时新建<code>Task</code>, 即需要传入下文将要介绍的<code>FLAG_ACTIVITY_NEW_TASK</code>标志或为<code>Activity</code>指定<code>allowTaskReparenting</code>为<code>True</code>.  </p>
<h2 id="intent-flags"><a href="#intent-flags" class="headerlink" title="intent flags"></a>intent flags</h2><p>如果说, 我们想要在代码中动态地改变<code>Activity</code>启动模式, 比如想让本来以<code>standard</code>模式启动的<code>Activity</code>在某种情况下以<code>singleTop</code>模式启动, 这可以办到吗? <code>Android</code>工程师们显然想到了这种情形, 设计了<code>intent flags</code>来达成该目的.<br>在启动<code>Activity</code>的时候需要一个<code>Intent</code>, 通过<code>Intent.setFlags()</code>可以设置启动标志, 其中启动模式和FLAG的对应关系如下:  </p>
<table>
<thead>
<tr>
<th style="text-align:left">启动模式</th>
<th style="text-align:left">启动标志</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">standard</td>
<td style="text-align:left">不设置</td>
</tr>
<tr>
<td style="text-align:left">singleTop</td>
<td style="text-align:left">FLAG_ACTIVITY_SINGLE_TOP</td>
</tr>
<tr>
<td style="text-align:left">singleTask</td>
<td style="text-align:left">FLAG_ACTIVITY_NEW_TASK &#124; FLAG_ACTIVITY_CLEAR_TOP</td>
</tr>
</tbody>
</table>
<p>另外还有更多的FLAG可以达成其他效果, 查看<code>Intent</code>类源码可以了解更多.<br>细心的同学可能发现了, 上述表格跟官网的介绍有出入. 官网说仅<code>FLAG_ACTIVITY_NEW_TASK</code>就会产生与<code>singleTask</code>模式相同的行为, 事实上经我实验只有在指定了<code>taskAffinity</code>时这句话才成立. 官网说<code>FLAG_ACTIVITY_CLEAR_TOP</code>属性没有对应的启动模式, 事实上确实如此, 因为它是<code>singleTask</code>模式的其中一个行为.  </p>
<p>细心的同学可能还发现, 表格中没有<code>singleInstance</code>模式对应的FLAG. 那是因为这种模式要达成的效果需要在处理<code>Intent</code>之前更早的时期来控制, 在<code>Intent</code>中设置没用.  </p>
<h2 id="任务栈和回退栈"><a href="#任务栈和回退栈" class="headerlink" title="任务栈和回退栈"></a>任务栈和回退栈</h2><p>由前文所述我们接触到两个概念: 任务栈和回退栈. 我姑且在此拙劣地理解一下: 任务栈是为了完成某种任务而形成的<code>Activity</code>的栈; 回退栈是显示回退顺序的<code>Activity</code>栈. 如此理解的话, 那么两者是从不同的侧面来描述<code>Activity</code>的组织方式, 其中任务栈就是我们上文一直在说的<code>Task</code>, 而回退栈只是一个逻辑上的概念. 事实上我们在新建或者唤起一个<code>Activity</code>的时候, 它所在的整个<code>Task</code>会被提到最上层, 也就是”回退栈”的顶端, 就算<code>launcher</code>应用也是以这种方式回到栈顶的, 只不过它对<code>Back</code>和<code>Home</code>做了处理, 我们无法通过返回键令它出栈而回到位于它下面的<code>Activity</code>. 这就是为什么我们能够在不同的应用间切换, 还能保持应用所打开的<code>Activity</code>的原因(事实上通过设置<code>clearTaskOnLaunch</code>等属性, 切入后台后再切回来可以清空已打开的<code>Activity</code>). 一个栈的名字由在这个栈的底端的那个<code>Activity</code>来定义, 默认就是那个<code>Activity</code>所在的应用的包名.<br>最后一个思考题, 这些任务栈是被谁在什么时候进行管理的呢?<br>祭出我们的大杀器: 源码. 全目录搜索关键词<code>launchMode</code>, 然后就会发现一个东西<code>./frameworks/base/services/java/com/android/server/am/ActivityStack.java</code>以及另一个东西<code>./frameworks/base/core/java/android/content/pm/ActivityInfo.java</code>, 其中前者我们在AMS中已经见到过了, 至此得解.  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html#ManagingTasks" target="_blank" rel="external">官网 任务和返回栈</a>  </li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0520/2897.html" target="_blank" rel="external">Activity启动模式图文详解</a>  </li>
<li><a href="http://blog.csdn.net/qilamaxiu/article/details/51604957" target="_blank" rel="external">Activity启动模式解析</a>  </li>
<li><a href="http://blog.csdn.net/liuhe688/article/details/6754323" target="_blank" rel="external">基础总结篇之二：Activity的四种launchMode</a>  </li>
<li><a href="http://blog.csdn.net/thewalker3000/article/details/62035836" target="_blank" rel="external">如何正确理解和使用 Activity的4种启动模式</a>  </li>
<li><a href="http://wangkuiwu.github.io/2014/06/26/IntentFlag/" target="_blank" rel="external">Android 之Activity启动模式(二)之 Intent的Flag属性</a>  </li>
<li><a href="http://www.cloudchou.com/android/post-760.html" target="_blank" rel="external">深入理解Activity启动模式(二)–Activity,回退栈,Task之间的关系</a>  </li>
<li><a href="http://blog.csdn.net/wanghao200906/article/details/49766309" target="_blank" rel="external">android的启动模式 到底在什么时候用呢</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      我们知道, `Activity`需要配置在`AndroidManifest.xml`中才能正常启动, 其原因是launc...
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】ActivityManagerService全解(1/5)</title>
    <link href="https://hjhjw1991.github.io/android/2017/03/05/%5BAndroid%E6%95%99%E7%A8%8B%5DActivityManagerService%E5%85%A8%E8%A7%A3-part1/"/>
    <id>https://hjhjw1991.github.io/android/2017/03/05/[Android教程]ActivityManagerService全解-part1/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2017-05-04T10:36:03.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在<code>Android</code>操作系统中, 有许多个默默维护<code>Android</code>系统稳定正常流畅运行的幕后工作者, 对于上层App开发者来说这些工作者的名字可能是不太熟悉甚至完全陌生的, 就像电影散场时的演职人员表, 人人都知道没有他们电影完不成, 也都知道他们各有分工, 各有名谓, 但少有人清楚他们具体做了什么. 其中为人所熟知的几大系统服务之一就是<code>ActivityManagerService</code>, 今天我们来访谈一下这位幕后工作者.  </p>
</blockquote>
<p>采访者: <a href="https://hjhjw1991.github.io">hjhjw1991</a><br>被采访者: <code>ActivityManagerService</code>家族<br>地点: <code>Android 4.0</code>源码目录<br>时间: 2017-03-01  </p>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><ul>
<li><p>你好, 请简要介绍一下你自己.<br><a href="https://hjhjw1991.github.io">hjhjw1991</a>你好, 大家好, 我是<code>ActivityManagerService</code>, 位于<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>. 我的父亲是<code>ActivityManagerNative</code>, 我的祖父是<code>Binder</code>. 我左手这个接口是<code>Watchdog.Monitor</code>, 右手的接口是<code>BatteryStatsImpl.BatteryCallback</code>, 我们家的关系就像下面这幅图所示:<br><img src="/images/blogs/activity_manager_service_stack.png" alt="ActivityManagerService类关系图"><br>感谢我家的健康咨询师<a href="http://blog.csdn.net/innost" target="_blank" rel="external">邓凡平老师</a>为我绘制的族谱, 他将族谱放在了<a href="http://wiki.jikexueyuan.com/project/deep-android-v2/activity.html" target="_blank" rel="external">这里</a>, 有兴趣的同学欢迎买他的书以表支持.  </p>
</li>
<li><p>好的, 我就叫你<code>AMS</code>可以吗?<br>没问题, 大家都这么叫我.  </p>
</li>
<li><p><code>AMS</code>, 你现在的职业是什么呢?<br>我现在在家族企业<code>Android Framework</code>上班, 日常工作也就是管理管理企业四大金刚<code>Activity</code> <code>Service</code> <code>ContentProvider</code> <code>BroadcastReceiver</code>.  </p>
</li>
<li><p>听起来位置很重要呢, 平时主要忙些什么呢?<br>确实非常重要, 我常常忙不过来呢. 我主要负责调度和管理刚刚提到的四大金刚, 他们是我们企业的业务骨干, 几乎所有业务都交给他们去做的, 所以为了他们能安心做好分内工作, 我作为中间协调人就需要负责在业务到来的时候找到合适的执行人并通知他们去执行. 不过说是这么说, 我其实也不是直接通知他们, 像<code>Activity</code>, 我就是在接到相关业务的时候, 选择合适的时机让我父亲<code>ActivityManagerNative</code>判断一下是什么业务, 然后告诉我应该做什么, 我就根据这个具体业务, 找到具体能做这个业务的对象. 我们有一个专门的对外接口人, 他叫<code>ActivityManagerProxy</code>, 负责跑业务.<br>比如接口人接到一个<code>startActivity</code>的任务, 他就拿着资料先给我父亲看一下(<code>ActivityManagerProxy.transact-&gt;ActivityManagerNative.onTransact</code>), 他没有权限见我父亲, 好在他手上有支可以直接接通我父亲的专属电话<code>mRemote</code>, 平时什么业务都是通过这支电话传递的. 据说这支电话是我祖父<code>Binder</code>和他的兄弟们发明的, 他们可以监听电话里所有的通信内容, 我祖父真厉害.<br>我父亲一看, 原来是<code>START_ACTIVITY_TRANSACTION</code>这种事务, 他帮我整理整理事务资料(因为据说事务资料都是包装在一种叫做<code>Parcel</code>的密封材料中的, 需要特别的解封技巧, 我不太会), 然后把整理好的资料交给我. <code>START_ACTIVITY_TRANSACTION</code>是我父亲和接口人<code>Proxy</code>约定好的暗语, 我们有一整套暗语, 写在<code>IActivityManager</code>这个文件里面, 这文件藏在<code>frameworks/base/core/java/android/app/IActivityManager.java</code>, 我也有一份拷贝, 是我父亲给我的, 但我基本上没看过, 都让我父亲看(<code>ActivityManagerService.onTransact</code>里面就是<code>super.onTransact</code>), 没办法我太忙了. 据说这套暗语也是祖父发明的, 我祖父真厉害.<br>父亲将资料交给我的时候也会告诉我, 要用<code>startActivity</code>这个方法去完成这个事务. 这个方法我知道, 我给你手写一下:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div></pre></td><td class="code"><pre><div class="line">  public final int startActivity(IApplicationThread caller,</div><div class="line">          Intent intent, String resolvedType, Uri[] grantedUriPermissions,</div><div class="line">          int grantedMode, IBinder resultTo,</div><div class="line">          String resultWho, int requestCode, boolean onlyIfNeeded, boolean debug,</div><div class="line">          String profileFile, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; // 方法签名</div><div class="line">      return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType,</div><div class="line">              grantedUriPermissions, grantedMode, resultTo, resultWho,</div><div class="line">              requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler,</div><div class="line">              null, null); // 执行者</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  你看, 很简单吧, 我其实只是把资料全都交给对的家伙去处理罢了. 说得我都有点不好意思了, 我平时真的很忙的, 真的. 这个`mMainStack`是我一个得力秘书, 他专精`Activity`相关管理事务, 据说他们家族是`ActivityStack`. 我看他能力不错, 就在`main`的时候把他招进来了.  </div><div class="line">  我做的工作差不多都是这种模式, 像`startService`这种事务我可能做的事要多些, `startService -&gt; startServiceLocked -&gt; bringUpServiceLocked -&gt; realStartServiceLocked -&gt; app.thread.scheduleCreateService`, 基本上就是检查权限, 检查是不是已经在做了, 检查做的人还在不在, 如果做的人在但是还没开始做并且做的人能做, 我就交给他去做. 这个做事的人, 就是`app.thread`. `app`是`ProcessRecord`家的, 他小弟`thread`是`IApplicationThread`家的. 我虽然是`ServerThread`一手提拔起来让我做到现在位置的, 但是我们的运营完全独立于他, 行话说就是我们在**独立线程**上.  </div><div class="line">  </div><div class="line">- 你刚刚提到了`main`, 你所说的`main`是个什么过程呢?  </div><div class="line">  `main`是我的上司`SystemServer::ServerThread`(位于`frameworks/base/services/java/com/android/server/SystemServer.java`)交给我的任务. 他一旦告诉我要做`main`了, 我就要开始工作了. 具体来说, 我做的工作是这样的:</div><div class="line">  </div><div class="line">  ```  </div><div class="line">    public static final Context main(int factoryTest) &#123;</div><div class="line">        AThread thr = new AThread(); // #1 创建一个AThread线程对象</div><div class="line">        thr.start();</div><div class="line"></div><div class="line">        synchronized (thr) &#123;</div><div class="line">            ... // #2 等待线程的thr.mService创建完成</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ActivityManagerService m = thr.mService;</div><div class="line">        mSelf = m;</div><div class="line">        ActivityThread at = ActivityThread.systemMain(); // #3 调用ActivityThread.systemMain函数</div><div class="line">        mSystemThread = at;</div><div class="line">        Context context = at.getSystemContext(); // #4 获得SystemContext</div><div class="line">        context.setTheme(android.R.style.Theme_Holo);</div><div class="line">        m.mContext = context;</div><div class="line">        m.mFactoryTest = factoryTest;</div><div class="line">        m.mMainStack = new ActivityStack(m, context, true); // #5 使用m和context新建ActivityStack对象</div><div class="line">        </div><div class="line">        m.mBatteryStatsService.publish(context); // 调用BSS和USS的publish方法</div><div class="line">        m.mUsageStatsService.publish(context);</div><div class="line">        </div><div class="line">        synchronized (thr) &#123;</div><div class="line">            thr.mReady = true; // #6 设置thr为已准备, 并通知thr可以开始他的表演</div><div class="line">            thr.notifyAll();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m.startRunning(null, null, null, null); // 全null参数调用startRunning, 主要作用是设置`mStartRunning`标志, 因为此时`mSystemReady`还是默认值`false`, 走不到后面的`systemReady`逻辑</div><div class="line">        </div><div class="line">        return context;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static class AThread extends Thread &#123;</div><div class="line">        ActivityManagerService mService;</div><div class="line">        boolean mReady = false;</div><div class="line"></div><div class="line">        public AThread() &#123;</div><div class="line">            super(&quot;ActivityManager&quot;); // 设置线程名字</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void run() &#123;</div><div class="line">            Looper.prepare(); // 准备Looper, 估计是要用消息队列来处理消息</div><div class="line"></div><div class="line">            android.os.Process.setThreadPriority(</div><div class="line">                    android.os.Process.THREAD_PRIORITY_FOREGROUND); // 设置线程优先级</div><div class="line">            android.os.Process.setCanSelfBackground(false);</div><div class="line"></div><div class="line">            ActivityManagerService m = new ActivityManagerService(); // 创建AMS对象</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                mService = m; // AMS对象赋值给成员mService</div><div class="line">                notifyAll(); // #7 通知其他以本线程为锁的线程, 可以获取本线程来做锁了</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                ...// #8 等待mReady被外部(也就是main所在线程)设置为true</div><div class="line">            &#125;</div><div class="line">            ...</div><div class="line"></div><div class="line">            Looper.loop(); // 开始消息循环</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  ```  </div><div class="line">  老大让我开始`main`之后, 我就分配一个小弟`AThread thr`, 等他向我汇报(#2), 小弟汇报完(#7)就等我把老大这边交代的工作做完(#3~#6), 然后他再继续剩下的工作(#8), 并处于待命状态, 随时准备处理后面的消息.  </div><div class="line">  </div><div class="line">- 好像越来越复杂了, 又是`ActivityThread`又是`SystemServer`的, 看来我又多了几个采访对象. 想问一下`AMS`, 我注意到刚刚在你`AThread`中有一步是`new ActivityManagerService()`, 这里面做了什么能让我看一下吗?  </div><div class="line">  不能╭(╯^╰)╮. `Java`类的构造函数就像女孩子的闺房, 允许你看才能看. 我可以大概跟你说里面做了什么. 大概就是下面这样:  </div><div class="line">  </div><div class="line">  ```  </div><div class="line">  private ActivityManagerService() &#123;</div><div class="line">      Slog.i(TAG, &quot;Memory class: &quot; + ActivityManager.staticGetMemoryClass()); // 日志</div><div class="line">      </div><div class="line">      File dataDir = Environment.getDataDirectory(); // /data/目录</div><div class="line">      File systemDir = new File(dataDir, &quot;system&quot;); // /data/system</div><div class="line">      systemDir.mkdirs();</div><div class="line">      // 创建BatteryStatsService, BSS</div><div class="line">      mBatteryStatsService = new BatteryStatsService(new File(</div><div class="line">              systemDir, &quot;batterystats.bin&quot;).toString());</div><div class="line">      mBatteryStatsService.getActiveStatistics().readLocked();</div><div class="line">      mBatteryStatsService.getActiveStatistics().writeAsyncLocked();</div><div class="line">      mOnBattery = DEBUG_POWER ? true</div><div class="line">              : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</div><div class="line">      mBatteryStatsService.getActiveStatistics().setCallback(this);</div><div class="line">      </div><div class="line">      // 创建UsageStatsService, USS</div><div class="line">      mUsageStatsService = new UsageStatsService(new File(</div><div class="line">              systemDir, &quot;usagestats&quot;).toString());</div><div class="line"></div><div class="line">      GL_ES_VERSION = SystemProperties.getInt(&quot;ro.opengles.version&quot;,</div><div class="line">          ConfigurationInfo.GL_ES_VERSION_UNDEFINED); // OpenGL_ES版本</div><div class="line"></div><div class="line">      mConfiguration.setToDefaults();</div><div class="line">      mConfiguration.locale = Locale.getDefault();</div><div class="line">      mProcessStats.init(); // ProcessStats, 用于统计CPU/内存信息, 解析/proc/stat文件的内容</div><div class="line">      </div><div class="line">      // 解析/data/system/packages-compat.xml文件, 获得APK的屏幕尺寸要求.  </div><div class="line">      mCompatModePackages = new CompatModePackages(this, systemDir);</div><div class="line"></div><div class="line">      // Add ourself to the Watchdog monitors.</div><div class="line">      Watchdog.getInstance().addMonitor(this);</div><div class="line"></div><div class="line">      // 新线程用于定时更新系统信息</div><div class="line">      mProcessStatsThread = new Thread(&quot;ProcessStats&quot;) &#123;</div><div class="line">          public void run() &#123;</div><div class="line">              while (true) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      try &#123;</div><div class="line">                          synchronized(this) &#123;</div><div class="line">                              final long now = SystemClock.uptimeMillis();</div><div class="line">                              long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</div><div class="line">                              long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</div><div class="line">                              //Slog.i(TAG, &quot;Cpu delay=&quot; + nextCpuDelay</div><div class="line">                              //        + &quot;, write delay=&quot; + nextWriteDelay);</div><div class="line">                              if (nextWriteDelay &lt; nextCpuDelay) &#123;</div><div class="line">                                  nextCpuDelay = nextWriteDelay;</div><div class="line">                              &#125;</div><div class="line">                              if (nextCpuDelay &gt; 0) &#123;</div><div class="line">                                  mProcessStatsMutexFree.set(true);</div><div class="line">                                  this.wait(nextCpuDelay);</div><div class="line">                              &#125;</div><div class="line">                          &#125;</div><div class="line">                      &#125; catch (InterruptedException e) &#123;</div><div class="line">                      &#125;</div><div class="line">                      updateCpuStatsNow();</div><div class="line">                  &#125; catch (Exception e) &#123;</div><div class="line">                      Slog.e(TAG, &quot;Unexpected exception collecting process stats&quot;, e);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;;</div><div class="line">      mProcessStatsThread.start();</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  总的来说就是创建了`/data/system`目录, 实例化了BSS和USS两个服务, 创建了`ProcessStats`的实例及其运行线程, 这些都是用来监控系统状况的. 另外初始化了`mCompatModePackages`和`mConfiguration`.  </div><div class="line">  </div><div class="line">- 那`ActivityThread.systemMain()`和`ActivityManagerService.startRunning()`又做了什么呢?  </div><div class="line">  `ActivityThread.systemMain()`先禁用硬件渲染, 然后实例化了一个`ActivityThread`对象并调用了它的`attach(true)`方法, 然后把这个对象丢回来. `attach(true)`传入的参数表示调用者是否系统进程. 在系统进程下它做了以下工作:  </div><div class="line"></div><div class="line">  ```  </div><div class="line">  </div><div class="line">      private void attach(boolean system) &#123;</div><div class="line">          sThreadLocal.set(this);</div><div class="line">          mSystemThread = system;</div><div class="line">          if (!system) &#123;// 非系统进程时的处理</div><div class="line">          &#125; else &#123;</div><div class="line">              // Don&apos;t set application object here -- if the system crashes,</div><div class="line">              // we can&apos;t display an alert, we just want to die die die.</div><div class="line">              // 以上是源码中的注释, 绝不是我在卖萌</div><div class="line">              // 设置显示的进程名称为system_process</div><div class="line">              android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;);</div><div class="line">              try &#123;</div><div class="line">                  // 构造Instrumentation, Context, Application, 并调用Applicaiton.onCreate()</div><div class="line">                  mInstrumentation = new Instrumentation();</div><div class="line">                  ContextImpl context = new ContextImpl();</div><div class="line">                  // 调用init时第一个参数是getSystemContext().mPackageInfo</div><div class="line">                  context.init(getSystemContext().mPackageInfo, null, this);</div><div class="line">                  Application app = Instrumentation.newApplication(Application.class, context);</div><div class="line">                  mAllApplications.add(app);</div><div class="line">                  mInitialApplication = app;</div><div class="line">                  app.onCreate();</div><div class="line">              &#125; catch (Exception e) &#123;</div><div class="line">                  ...</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          // 添加Configuration回调</div><div class="line">          ViewRootImpl.addConfigCallback(new ComponentCallbacks2() &#123;</div><div class="line">              public void onConfigurationChanged(Configuration newConfig) &#123;</div><div class="line">                  synchronized (mPackages) &#123;</div><div class="line">                      // We need to apply this change to the resources</div><div class="line">                      // immediately, because upon returning the view</div><div class="line">                      // hierarchy will be informed about it.</div><div class="line">                      if (applyConfigurationToResourcesLocked(newConfig, null)) &#123;</div><div class="line">                          // This actually changed the resources!  Tell</div><div class="line">                          // everyone about it.</div><div class="line">                          ...</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              public void onLowMemory() &#123;</div><div class="line">              &#125;</div><div class="line">              public void onTrimMemory(int level) &#123;</div><div class="line">              &#125;</div><div class="line">          &#125;);</div><div class="line">      &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">  可见, 在系统初始化的时候以系统的身份借助了`ActivityThread`的功能, 去获取系统资源`framework-res.apk`(应用名`android`). 从这个角度来说, `SystemServer`进程实际上也是一个特殊的应用进程, 在其上运行的应用都是仅供给系统使用的. 在`systemMain`调用结束后, 就可以通过返回的`ActivityThread`实例像操作普通应用一样操作系统应用以及和`Android`环境交互了. 相当于`SystemServer`也运行在跟应用进程相似的`Android`运行环境中.  </div><div class="line">  然后`startRunning()`做的事:  </div><div class="line">  </div><div class="line">  ```  </div><div class="line">  // 以全null参数调用</div><div class="line">  public final void startRunning(String pkg, String cls, String action,</div><div class="line">          String data) &#123;</div><div class="line">      synchronized(this) &#123;</div><div class="line">          if (mStartRunning) &#123;</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">          mStartRunning = true; // 设置标记, 如果已经设置过了直接返回</div><div class="line">          mTopComponent = pkg != null &amp;&amp; cls != null</div><div class="line">                  ? new ComponentName(pkg, cls) : null;</div><div class="line">          mTopAction = action != null ? action : Intent.ACTION_MAIN;</div><div class="line">          mTopData = data; // 由于传入的参数全null, 所以这里几个成员变量也是null, action则是Intent.ACTION_MAIN</div><div class="line">          if (!mSystemReady) &#123; // 此时mSystemReady仍为默认值false, 直接返回</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      systemReady(null); // 重要函数, 执行完后意味着系统已经启动完毕. 代码非常长, 而且在本次调用startRunning时并不会走到这里.</div><div class="line">  &#125;</div><div class="line">  ```  </div><div class="line">  </div><div class="line">- 好的, 我大概更糊涂了. 我总结一下, AMS的`main()`总共做了三点主要的工作:</div><div class="line">    1. 新启`AThread`线程创建`AMS`实例, 在`AMS`构造函数里面, 创建BSS/USS/mProcessStats: ProcessStats/mProcessStatsThread, 用于统计系统运行状况,</div><div class="line">还创建了`/data/system`目录,</div><div class="line">并为mCompatModePackages: CompatModePackages 和 mConfiguration: Configuration 等成员变量赋值;</div><div class="line">    2. 通过`ActivityThread.systemMain()`函数得到了一个`ActivityThread`实例, 代表了`framework-res.apk`应用所在的应用进程,</div><div class="line">为`SystemServer`创建了与Android环境交互的条件. 普通的应用则是应用的主线程调用`ActivityThread.main()`来获得`ActivityThread`实例;</div><div class="line">    3. 调用`startRunning()`, 并返回第2步创建好的`Context`实例, 完成`AMS.main()`的最后一步.</div><div class="line"></div><div class="line">    到这里为止都是`Activity`和`Application`啥的, 你前面说过跟四大金刚打交道, 那么其他几位你又是怎么跟他们打交道的呢?</div><div class="line"></div><div class="line">    嗯, 下次有空再说吧.</div><div class="line"></div><div class="line">- 好的, 距离上次(2017-03-05)已经过去了一个月, 咱们继续采访吧.</div><div class="line"></div><div class="line">    上次说到, `SystemServer::ServerThread`调用了`AMS.main()`从而为`SystemServer`创建了`Android`环境, 为`AMS`的工作做了准备.</div><div class="line">    然而上次在`startRunning()`时留了一个悬念, 即`SystemReady()`这个函数并没有在此时被调用. `main()`执行完之后返回了`Context`实例. 那么后面发生了什么呢?</div><div class="line">其实, 在`SystemServer::ServerThread::run()`中可以看到, 在`main()`方法调用之后, 经过了其他一些必要的初始化(例如调用`PackageManagerService.main()`),</div><div class="line">然后该线程调用了`ActivityManagerService.setSystemProcess()`, 该函数定义如下:</div></pre></td></tr></table></figure>
<p>  public static void setSystemProcess() {</p>
<pre><code>try {
    ActivityManagerService m = mSelf;
    // 向ServiceManager注册服务
    ServiceManager.addService(&quot;activity&quot;, m);// 注册本服务, 服务名activity
    ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(m));// 监控内存信息
    ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(m));// 监控硬件加速信息, 可通过adb shell dumpsys gfxinfo查看,
    4.0新增
    if (MONITOR_CPU_USAGE) {
        ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(m));// 监控CPU使用, MONITOR_CPU_USAGE默认为true
    }
    ServiceManager.addService(&quot;permission&quot;, new PermissionController(m));// 权限管理服务

    //#1 通过AMS的Context获取到PackageManagerService, 查询名为&quot;android&quot;的ApplicationInfo
    ApplicationInfo info =
        mSelf.mContext.getPackageManager().getApplicationInfo(
                &quot;android&quot;, STOCK_PM_FLAGS);
    //#2 调用ActivityThread.installSystemApplicationInfo()函数
    mSystemThread.installSystemApplicationInfo(info);

    synchronized (mSelf) {
        //#3 使用info新建并保存ProcessRecord对象
        ProcessRecord app = mSelf.newProcessRecordLocked(
                mSystemThread.getApplicationThread(), info,
                info.processName);// info.processName == &quot;system&quot;
        app.persistent = true;
        app.pid = MY_PID;
        app.maxAdj = ProcessList.SYSTEM_ADJ;
        mSelf.mProcessNames.put(app.processName, app.info.uid, app);
        synchronized (mSelf.mPidsSelfLocked) {
            mSelf.mPidsSelfLocked.put(app.pid, app);
        }
        //#4 更新LruProcess中存储的进程的顺序
        mSelf.updateLruProcessLocked(app, true, true);
    }
} catch (PackageManager.NameNotFoundException e) {
    throw new RuntimeException(
            &quot;Unable to find android system package&quot;, e);
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">从以上代码可以看到, AMS通过PMS(PackageManagerService)查询名为&quot;android&quot;的ApplicationInfo, 尽管他们实质上都是在`ServerThread`同一个进程上运行,</div><div class="line">完全可以以本地调用的方式互相调用, 但统一通过Context来进行交互的话, 保持了与其他服务相同的交互接口, 未来对交互方式的扩展也可以直接作用到这里, 使得代码更加灵活.</div><div class="line">现在来看看#2. 该函数以`ApplicationInfo`为参数, 根据前面的内容, 我们知道&quot;android&quot;这个名字对应的package就是&quot;framework-res.apk&quot;,</div><div class="line">猜测`ApplicationInfo`是其代码模型. 我们来看看这个方法的代码:</div></pre></td></tr></table></figure>
<p>  // frameworks/core/java/android/app/ActivityThread.java<br>  public void installSystemApplicationInfo(ApplicationInfo info) {</p>
<pre><code>synchronized (this) {
    // 返回的ContextImpl对象就是前面在AMS的main中创建的对象
    ContextImpl context = getSystemContext();
    //#1 oops!又一次调用了init, 是不是重复了?
    context.init(new LoadedApk(this, &quot;android&quot;, context, info,
            CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO), null, this);

    // give ourselves a default profiler
    // 用于性能统计
    mProfiler = new Profiler();
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">看#1再次调用了`ContextImpl.init`, 似乎跟`AMS.main`中`ActivityThread.getSystemContext()`时调用的`ContextImpl.init`重复了? 仔细看看,</div><div class="line">原来后者虽然给`LoadedApk`的名字也是&quot;android&quot;, 但是传入的第四个参数是`null`, 而前者#1中传入的第四个参数是指向&quot;framework-res.apk&quot;的`ApplicationInfo`实例.</div><div class="line">这就相当于`LoadedApk`指向了实际的apk包. 那么, 为什么要这样做呢? 实际上, 前面创建`ContextImpl`的时候, 并不需要用到&quot;framework-res.apk&quot;的东西,</div><div class="line">而只是希望创建一个android运行环境, 所以不需要绑定实际的包, 而此时往后需要用到&quot;framework-res.apk&quot;的东西了, 它的正确运行需要一个正确初始化的android运行环境,</div><div class="line">所以需要将代表它的`ApplicationInfo`绑定到`ContextImpl`上, 这也就是这个方法名字的含义. 由此看来接下来要做的事情就比较清晰了: 为&quot;framework-res.apk&quot;的运行创建或分配一个进程,</div><div class="line">并管理这个进程. 这些工作也是AMS完成的.</div><div class="line">于是我们可以看到 #3 #4 这两步就是在做进程管理. `ProcessRecord`是用于进程管理的数据结构. 通过`AMS.newProcessRecordLocked()`来创建`ProcessRecord`实例.</div><div class="line">到这里我们可以思考一个问题: 进程创建之后, AMS怎么跟进程进行交互? 我们想一下, AMS自己有一个进程, 这里又新建了一个进程, 那么AMS要跟新建的进程交互, 就需要进行跨进程交互. 这是不是意味着要借助Binder?</div><div class="line">原因可以看我以前写的Binder解析. 事实是确实如此, AMS通过Binder对其他进程进行管理, 充当桥梁的是`ActivityThread.ApplicationThread`这个类及其相关类和接口,</div><div class="line">这些都是Binder的标准套路, 其中`IApplicationThread`提供了操作接口, 用于启动/暂停/停止Activity.</div><div class="line">`ApplicationThread`的服务端实现就位于AMS要控制的那个进程的`ActivityThread`中, 具体来说就是客户端调用接口后,</div><div class="line">服务端`ActivityThread`会对应往自己线程的handler中发送一个消息, 而服务端`ActivityThread`自身运行在主线程中, 所以最终就是将消息发送到了服务端的主线程中处理.</div><div class="line">思考完这个问题, 我们来看`newProcessRecordLocked()`的代码:</div></pre></td></tr></table></figure>
<p>  final ProcessRecord newProcessRecordLocked(IApplicationThread thread,</p>
<pre><code>    ApplicationInfo info, String customProcess) {
String proc = customProcess != null ? customProcess : info.processName;
BatteryStatsImpl.Uid.Proc ps = null;
BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
    ps = stats.getProcessStatsLocked(info.uid, proc);// 为本进程创建一个耗电量统计项
}
// 创建一个ProcessRecord对象, 第二个参数就是用来和其他进程进行通信的thread
return new ProcessRecord(ps, thread, info, proc);
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">看到没有, 第一个参数就是`IApplicationThread`. 除此之外, AMS还需要更多的进程信息来管理进程, 这些信息就放在`ProcessRecord`这个数据结构中. 我们有空可以看一看这个类的实现, 它位于`frameworks/base/services/java/com/android/server/am/ProcessRecord.java`, 有一丢丢大. 我们这里只要知道,</div><div class="line">在构造函数中不经保存了和应用进程进行通信的`IApplicationThread`对象, 还保存了进程名, 不同状态对应的OOM_Adj值, 以及一个`ApplicationInfo`.</div><div class="line">一个进程虽然可以运行多个Application, 但`ProcessRecord`一般只保存该进程中最先运行的那个`Application`的`ApplicationInfo`.</div><div class="line">到此为止, 已经创建了一个`ProcessRecord`对象. 创建应用进程时的过程也与此类似. 和其他应用进程不同的是, 现在创建的这个对象所对应的进程是`SystemServer`. 它既然这么特殊,</div><div class="line">自然有一些与众不同的地方, 从上面的代码也可以看到, AMS为这个特殊的进程记录的一部分成员变量设定了特殊的值:</div></pre></td></tr></table></figure>
<p>  // 前一步已以ApplicationInfo.processName初始化ProcessRecord, 该值为”system”<br>  app.persistent = true; // 该值为true表示本进程常驻内存, 即使被杀掉也会被系统重启<br>  app.pid = MY_PID; // 设置pid为SystemServer的pid<br>  app.maxAdj = ProcessList.SYSTEM_ADJ; // 设置最大OOM_Adj为系统进程默认值, -16</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    至此, 一个`SystemServer`对应的`ProcessRecord`就创建完毕, 紧接着AMS将它纳入自己的管理之中. AMS通过以下几个数据结构来管理包括这个进程记录在内的进程记录:</div><div class="line">    ![process_names](/images/blogs/process_names.png)</div><div class="line"></div><div class="line">    总结一下, `setSystemProcess()`这个方法正如其名, 它主要完成了代表`SystemServer`进程的`ProcessRecord`对象的创建, 从此将系统进程也纳入AMS管理范围. 除此之外,</div><div class="line">    它还将AMS/meminfo/gfxinfo等服务注册到了`ServiceManager`中.</div><div class="line"></div><div class="line">- 好的, 你高兴就好, 你请继续.</div><div class="line"></div><div class="line">    好, 我们再回到`SystemServer::ServerThread::run`看接下来的内容.</div></pre></td></tr></table></figure>
<p>  try {<br>  // 其他内容都省略</p>
<pre><code>Slog.i(TAG, &quot;Entropy Service&quot;);
Slog.i(TAG, &quot;Power Manager&quot;);
Slog.i(TAG, &quot;Activity Manager&quot;);
Slog.i(TAG, &quot;Telephony Registry&quot;);
Slog.i(TAG, &quot;Package Manager&quot;);

ActivityManagerService.setSystemProcess();

// The AccountManager must come before the ContentService
try {
    Slog.i(TAG, &quot;Account Manager&quot;);
} catch (Throwable e) {
    Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e);
}
Slog.i(TAG, &quot;Content Manager&quot;);

Slog.i(TAG, &quot;System Content Providers&quot;);
ActivityManagerService.installSystemProviders();// #1

Slog.i(TAG, &quot;Vibrator Service&quot;);
Slog.i(TAG, &quot;Alarm Manager&quot;);
Slog.i(TAG, &quot;Init Watchdog&quot;);
Slog.i(TAG, &quot;Window Manager&quot;);

ActivityManagerService.self().setWindowManager(wm);// #2

// Skip Bluetooth if we have an emulator kernel
if (SystemProperties.get(&quot;ro.kernel.qemu&quot;).equals(&quot;1&quot;)) {
    Slog.i(TAG, &quot;No Bluetooh Service (emulator)&quot;);
} else if (factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL) {
    Slog.i(TAG, &quot;No Bluetooth Service (factory test)&quot;);
} else {
    Slog.i(TAG, &quot;Bluetooth Service&quot;);
}
</code></pre><p>  } catch (RuntimeException e) {<br>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">接下来跟AMS有关的就#1 #2两步了. #2比较好理解, 我们重点来看#1, 即`AMS.installSystemProviders()`. 代码如下:</div></pre></td></tr></table></figure>
<p>  public static final void installSystemProviders() {</p>
<pre><code>List&lt;ProviderInfo&gt; providers;
synchronized (mSelf) {
    ProcessRecord app = mSelf.mProcessNames.get(&quot;system&quot;, Process.SYSTEM_UID); // 通过名字和PID获取system对应的进程记录
    providers = mSelf.generateApplicationProvidersLocked(app); // #1
    if (providers != null) {
        for (int i=providers.size()-1; i&gt;=0; i--) {
            ProviderInfo pi = (ProviderInfo)providers.get(i);
            if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) { // 移除非系统Provider
                Slog.w(TAG, &quot;Not installing system proc provider &quot; + pi.name
                        + &quot;: not system .apk&quot;);
                providers.remove(i);
            }
        }
    }
}
if (providers != null) {
    mSystemThread.installSystemProviders(providers); // #2
}

mSelf.mCoreSettingsObserver = new CoreSettingsObserver(mSelf); // #3

mSelf.mUsageStatsService.monitorPackages(); // #4
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">在分析代码前, 我们先说明一下为什么会有这么个方法. 在Android中SystemServer上很多Service都需要通过Settings数据库查询配置信息,</div><div class="line">而这个Settings数据库是Android通过agiel特殊的Provider `SettingsProvider`提供给开发者的. 该Provider位于`SettingsProvider.apk`中,</div><div class="line">这个apk跟`framework-re.apk`类似, 也是在`SystemServer`进程上运行. 以上代码就是加载这个Provider. 加载完毕后`SystemServer`上就同时存在两个`apk`了.</div><div class="line">以上步骤#3和#4我们暂且不分析, 前者是监视Settings数据库的观察者, 后者是`UsageStatsService`的工作. #1可以看出是生成Provider列表的, 而#2则是调用`ActivityThread</div><div class="line">.installSystemProvider()`将系统Provider装载在进程上.</div><div class="line"></div><div class="line">#1 里面, 首先通过`AppGlobals.getPackageManager().queryContentProviders(app.processName, app.info.uid,</div><div class="line">STOCK_PM_FLAGS|PackageManager.GET_URI_PERMISSION_PATTERNS)`获取到满足进程名和进程id条件的`ProviderInfo`列表.</div><div class="line">遍历该列表并获取或构造`ContentProviderRecord`对象(这些对象都会保存在`AMS.mProvidersByClass`中, 一看这个名字我们差不多能猜到它就是代表ContentProvider的信息了),</div><div class="line">然后将这个对象以名字为键放到`app.pubProviders`中,并将它对应的包名放到`app.addPackage()`中, 最后看看能否对这个Provider包进行Dex优化. 别忘记这里的`app`就是上文中的`ProcessRecord`对象.</div><div class="line">至此, 查询到的Provider就纳入了当前进程`SystemServer`中了. 至于怎么通过进程名和pid查找的Provider, 这里我们就暂且不说了, 会放在`PackageManager`文章中来说.</div><div class="line">思考题: 为什么AMS和ProcessRecord都需要保存ContentProviderRecord?</div><div class="line"></div><div class="line">#2 里面做剩下的工作. #1之后实际上只是保存了`ContentProvider`的信息, 并没有产生`ContentProvider`对象, #2就能产生`ContentProvider`对象.</div><div class="line">实际上跟标准的`ContentProvider`产生过程并无两样. 代码如下:</div></pre></td></tr></table></figure>
<p>  public final void installSystemProviders(List<providerinfo> providers) {</providerinfo></p>
<pre><code>if (providers != null) {
    installContentProviders(mInitialApplication, providers);// 第一个参数实际类型是Application
}
</code></pre><p>  }</p>
<p>  private void installContentProviders( // 产生ContentProvider的必经之路, 标准的产生ContentProvider的方法</p>
<pre><code>    Context context, List&lt;ProviderInfo&gt; providers) {
final ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =
    new ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();

Iterator&lt;ProviderInfo&gt; i = providers.iterator();
while (i.hasNext()) {
    ProviderInfo cpi = i.next();
    ...
    // 调用installProvider获得一个IContentProvider对象
    IContentProvider cp = installProvider(context, null, cpi, false);
    if (cp != null) {
        IActivityManager.ContentProviderHolder cph =
            new IActivityManager.ContentProviderHolder(cpi);
        cph.provider = cp;// IContentProvider对象与ProviderInfo对象绑定
        results.add(cph);
        // Don&apos;t ever unload this provider from the process.
        synchronized(mProviderMap) {
            mProviderRefCountMap.put(cp.asBinder(), new ProviderRefCount(10000));//引用计数
        }
    }
}

try {
// 向AMS注册所有的ContentProvider, 第一个参数是ApplicationThread
    ActivityManagerNative.getDefault().publishContentProviders(
        getApplicationThread(), results);
} catch (RemoteException ex) {
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">总结一下, 以上代码做了两件事: 1. 通过`ActivityThread.installProvider`获得`ContentProvider`实例; 2. 向AMS发布所有`ContentProvider`实例.</div><div class="line">其实这跟`Binder Service`类似: 创建`Binder Service`实例, 向`ServiceManager`注册实例.</div><div class="line">`ActivityThread`和`ContentProvider`的关系如图:</div><div class="line">![contentProvider](/images/blogs/activity_manager_service_content_provider.png)</div><div class="line"></div><div class="line">我们这里不去深入分析`ActivityThread.installProvider()`, 这个内容放到分析`ActivityThread`的时候来讲. 我们来看`AMS.publishContentProviders()`. 代码如下:</div></pre></td></tr></table></figure>
<p>  // 此时传入的参数是caller=getApplicationThread(),即<code>framework-res.apk</code>所在的<code>SystemServer</code>进程中, 用于进程间通信的<code>ApplicationThread</code>客户端实例<br>  public final void publishContentProviders(IApplicationThread caller,</p>
<pre><code>    List&lt;ContentProviderHolder&gt; providers) {
if (providers == null) {
    return;
}

synchronized(this) {
    final ProcessRecord r = getRecordForAppLocked(caller);//根据调用者Binder对象找到调用者所在的进程信息
    ...
    final long origId = Binder.clearCallingIdentity();

    final int N = providers.size();
    for (int i=0; i&lt;N; i++) {
        ContentProviderHolder src = providers.get(i);
        if (src == null || src.info == null || src.provider == null) {
            continue;
        }
        ContentProviderRecord dst = r.pubProviders.get(src.info.name);// 从调用者进程信息中找到对应的ContentProviderRecord
        if (dst != null) {
            ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);
            mProvidersByClass.put(comp, dst);//以ComponentName为键, 保存ContentProviderRecord. 这是寻找ContentProvider的方式之一
            String names[] = dst.info.authority.split(&quot;;&quot;);
            for (int j = 0; j &lt; names.length; j++) {
                mProvidersByName.put(names[j], dst);// 以authority为键, 保存ContentProviderRecord. 这是寻找ContentProvider的方式之一
            }

            int NL = mLaunchingProviders.size();// 处于启动状态的ContentProvider
            int j;
            for (j=0; j&lt;NL; j++) {
                if (mLaunchingProviders.get(j) == dst) {
                    mLaunchingProviders.remove(j);
                    j--;
                    NL--;
                }
            }
            synchronized (dst) {
                dst.provider = src.provider;
                dst.proc = r;
                dst.notifyAll();//通知所有等待中的进程, 本ContentProvider已经发布, 可供使用
            }
            updateOomAdjLocked(r);// 每发布一个ContentProvider, 调整一次调用者进程的oom_adj
        }
    }

    Binder.restoreCallingIdentity(origId);
}
</code></pre><p>  }</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">总结一下, `SettingsProvider.apk`作为一个系统级的`ContentProvider`,</div><div class="line">通过`installSystemProvider`由`SystemServer`进程走普通的`ContentProvider`创建和发布流程完成发布.</div><div class="line">接着我们再回到`SystemServer::ServerThread::run`, 走余下的流程:</div></pre></td></tr></table></figure>
<p>  // in file SystemServer.java<br>  …<br>  // We now tell the activity manager it is okay to run third party<br>  // code.  It will call back into us once it has gotten to the state<br>  // where third party code can really run (but before it has actually<br>  // started launching the initial applications), for us to complete our<br>  // initialization.<br>  ActivityManagerService.self().systemReady(new Runnable() {</p>
<pre><code>public void run() {
    Slog.i(TAG, &quot;Making services ready&quot;);

    startSystemUi(contextF);
    try {
        if (batteryF != null) batteryF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Battery Service ready&quot;, e);
    }
    try {
        if (networkManagementF != null) networkManagementF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Managment Service ready&quot;, e);
    }
    try {
        if (networkStatsF != null) networkStatsF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Stats Service ready&quot;, e);
    }
    try {
        if (networkPolicyF != null) networkPolicyF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Policy Service ready&quot;, e);
    }
    try {
        if (connectivityF != null) connectivityF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Connectivity Service ready&quot;, e);
    }
    try {
        if (dockF != null) dockF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Dock Service ready&quot;, e);
    }
    try {
        if (usbF != null) usbF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making USB Service ready&quot;, e);
    }
    try {
        if (uiModeF != null) uiModeF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making UI Mode Service ready&quot;, e);
    }
    try {
        if (recognitionF != null) recognitionF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Recognition Service ready&quot;, e);
    }
    Watchdog.getInstance().start();

    // It is now okay to let the various system services start their
    // third party code...

    try {
        if (appWidgetF != null) appWidgetF.systemReady(safeMode);
    } catch (Throwable e) {
        reportWtf(&quot;making App Widget Service ready&quot;, e);
    }
    try {
        if (wallpaperF != null) wallpaperF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Wallpaper Service ready&quot;, e);
    }
    try {
        if (immF != null) immF.systemReady(statusBarF);
    } catch (Throwable e) {
        reportWtf(&quot;making Input Method Service ready&quot;, e);
    }
    try {
        if (locationF != null) locationF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Location Service ready&quot;, e);
    }
    try {
        if (countryDetectorF != null) countryDetectorF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Country Detector Service ready&quot;, e);
    }
    try {
        if (throttleF != null) throttleF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Throttle Service ready&quot;, e);
    }
    try {
        if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Network Time Service ready&quot;, e);
    }
    try {
        if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemReady();
    } catch (Throwable e) {
        reportWtf(&quot;making Text Services Manager Service ready&quot;, e);
    }
}
</code></pre><p>  });</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以看到传给了`AMS.systemReady()`一个`Runnable`的回调. 是时候打开`ActivityManagerService.systemReady()`看一看了. 源码如下:</div></pre></td></tr></table></figure>
<p>  // todo 添加源码<br>  ```</p>
</li>
</ul>
<h2 id="ActivityManagerNative-ActivityManagerProxy与ActivityManager"><a href="#ActivityManagerNative-ActivityManagerProxy与ActivityManager" class="headerlink" title="ActivityManagerNative, ActivityManagerProxy与ActivityManager"></a>ActivityManagerNative, ActivityManagerProxy与ActivityManager</h2>]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲ActivityManagerService系统服务-由于这个东西涉及的面实在广, 前面我又没有写过其他的相关内容, 所以这个话题我分5个部分来介绍.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android源码伴读】Retrofit源码探秘</title>
    <link href="https://hjhjw1991.github.io/android/2017/03/01/%5BAndroid%E6%BA%90%E7%A0%81%E4%BC%B4%E8%AF%BB%5DRetrofit%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A7%98/"/>
    <id>https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/</id>
    <published>2017-02-28T16:00:00.000Z</published>
    <updated>2017-03-05T11:15:49.483Z</updated>
    
    <content type="html"><![CDATA[<p>截至我写文章为止, <code>Retrofit</code>更新到了<code>2.2.0</code>版本. 据说<code>1.x</code>与<code>2.0+</code>差异巨大, 这里我们就直接拥抱变化来看最新代码了.  </p>
<h2 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h2><p>添加依赖和添加网络权限我就不说了. 假设我们要访问网络获取一个<code>Json</code>格式的响应, 来看代码怎么写:  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
                    .baseUrl(&quot;http://url.of.yourserver/&quot;)
                    .addConverterFactory(GsonConverterFactory.create())
                    .build(); // 创建全局管理
HttpService httpService = retrofit.create(YourHttpService.class); // 创建访问接口实例
Call&lt;Json&gt; call = httpService.getJson(); // 为要访问的接口创建Call
call.enqueue(new YourCallbackForThisCall(){...}); // Call入队列并添加回调
</code></pre><p>非常简单对不对, 而且<code>YourHttpService.class</code>甚至可能根据某种规范直接从服务端导出, 需要自己手写的代码几乎可以忽略不计, 出bug的几率就更小了.<br>这里的<code>Callback</code>经我验证是在UI线程执行的, 所以可以直接在<code>onResponse</code>里更新UI. 如果想要换到其他线程处理, 需要设置<code>callbackExecutor</code>, 默认是主线程.  </p>
<h2 id="Retrofit源码探秘"><a href="#Retrofit源码探秘" class="headerlink" title="Retrofit源码探秘"></a>Retrofit源码探秘</h2><p>根据我们前面分析过的<code>OkHttp</code>源码可以知道, <code>Retrofit</code>背后的请求发送和接收都是通过它来完成的, 自己几乎没做什么. <code>Retrofit</code>能实现这么简单的调用方式, 其魔法就在它的抽象架构上. <code>Retrofit</code>通过定义和解析注解的方式生成<code>Request</code>, 又在原本<code>OkHttpCall</code>(<code>Retrofit</code>定义的<code>OkHttp</code>的代理)的回调之中加了一层, 用于处理响应出错情况和把响应结果包装成<code>ExceptionCatchingRequestBody</code>, 最后用<code>ServiceMethod.toResponse</code>使用<code>Converter</code>完成响应解析, 使用解析结果通过<code>CallAdapter</code>构造一个自定义的<code>Response&lt;T&gt;</code>并返回. 再在外层回调我们设置的<code>Callback&lt;T&gt;</code>.<br>真正的网络请求的事情包括连接和缓存的维护都交给<code>OkHttpClient</code>完成了, 因此关键就在于<code>Retrofit</code>从注解到<code>Call</code>的过程和从<code>Response</code>到<code>Response&lt;T&gt;</code>的过程.  </p>
<h3 id="Retrofit注解定义和解析"><a href="#Retrofit注解定义和解析" class="headerlink" title="Retrofit注解定义和解析"></a>Retrofit注解定义和解析</h3><p>在我之前的某篇文章中曾经解析过<code>Java</code>的<code>Annotation</code>机制, 这里就不再解释了, 我们已经知道, <code>Java</code>的注解是通过注解处理器<code>Processor</code>进行处理的, <code>Retrofit</code>应该也是实现了类似的机制去处理它自己的注解. 注解都是编译器完成处理的, 其处理后的代码的生命周期根据它的<code>Retention</code>不同而不同, <code>Retention</code>为<code>RUNTIME</code>的注解在编译器处理之后存在于<code>.class</code>文件中并且还被虚拟机载入, 所以可供后续处理. 接下来我们就来看看<code>Retrofit</code>中的注解定义和解析器的定义, 我们将会发现它所有的注解都是<code>RUNTIME</code>的.<br>注解都在<code>http</code>包下, 从名字也看得出来基本上对应了<code>http</code>协议中的各个实体. 我们只看其中<code>GET</code> <code>Headers</code> <code>Streaming</code>三个.<br>选这三个的原因是三个在<code>http</code>协议中分别代表三种类型: 请求方法, 结构参数, 传输标记. 如果不记得<code>http</code>协议的同学可以看我另一篇博客<a href="/images/blogs/network.md">Android源码解析-网络架构</a>.<br>三个注解的完整代码如下:  </p>
<pre><code>@Target(METHOD)
@Retention(RUNTIME)
public @interface GET {
  /**
   * A relative or absolute path, or full URL of the endpoint. This value is optional if the first
   * parameter of the method is annotated with {@link Url @Url}.
   * &lt;p&gt;
   * See {@linkplain retrofit2.Retrofit.Builder#baseUrl(HttpUrl) base URL} for details of how
   * this is resolved against a base URL to create the full endpoint URL.
   */
  String value() default &quot;&quot;;
}

/**
 * Adds headers literally supplied in the {@code value}.
 * &lt;pre&gt;&lt;code&gt;
 * &amp;#64;Headers(&quot;Cache-Control: max-age=640000&quot;)
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 *
 * &amp;#64;Headers({
 *   &quot;X-Foo: Bar&quot;,
 *   &quot;X-Ping: Pong&quot;
 * })
 * &amp;#64;GET(&quot;/&quot;)
 * ...
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;strong&gt;Note:&lt;/strong&gt; Headers do not overwrite each other. All headers with the same name will
 * be included in the request.
 *
 * @see Header
 * @see HeaderMap
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Headers {
  String[] value();
}

/**
 * Treat the response body on methods returning {@link okhttp3.Response Response} as is,
 * i.e. without converting {@link okhttp3.Response#body() body()} to {@code byte[]}.
 */
@Documented
@Target(METHOD)
@Retention(RUNTIME)
public @interface Streaming {
}
</code></pre><p>为避免各位说我凑篇幅, 请各位仔细看上文代码的注释部分和注解部分, 我们可以看到这几个注解的设计思路, 基本上是按照<code>http</code>协议的基本部分来分解的, 并且都有明确的作用对象和作用范围.<br>对这三种类型的注解的处理自然也是不太一样, 接下来我们就看看<code>Retrofit</code>为它的这些注解编写了怎样的处理器. 注解的转存在<code>ServiceMethod.Builder()</code>中, 处理则在<code>ServiceMethod.Builder.build()</code>中, 如下:  </p>
<pre><code>public ServiceMethod build() {
  ...
  // Method级别的Annotation, 主要是GET/POST等方法
  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
  }
  ...
  // Parameter级别的Annotation, 主要是Path等
  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    if (Utils.hasUnresolvableType(parameterType)) {
      throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;,
          parameterType);
    }

    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    if (parameterAnnotations == null) {
      throw parameterError(p, &quot;No Retrofit annotation found.&quot;);
    }

    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }
 ...
}

// 处理Method级别Annotation
private void parseMethodAnnotation(Annotation annotation) {
  if (annotation instanceof DELETE) {
    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
  } else if (annotation instanceof GET) {
    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
  } else if (annotation instanceof HEAD) {
    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);
    if (!Void.class.equals(responseType)) {
      throw methodError(&quot;HEAD method must use Void as response type.&quot;);
    }
  } else if (annotation instanceof PATCH) {
    parseHttpMethodAndPath(&quot;PATCH&quot;, ((PATCH) annotation).value(), true);
  } else if (annotation instanceof POST) {
    parseHttpMethodAndPath(&quot;POST&quot;, ((POST) annotation).value(), true);
  } else if (annotation instanceof PUT) {
    parseHttpMethodAndPath(&quot;PUT&quot;, ((PUT) annotation).value(), true);
  } else if (annotation instanceof OPTIONS) {
    parseHttpMethodAndPath(&quot;OPTIONS&quot;, ((OPTIONS) annotation).value(), false);
  } else if (annotation instanceof HTTP) {
    HTTP http = (HTTP) annotation;
    parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
  } else if (annotation instanceof retrofit2.http.Headers) {
    String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
    if (headersToParse.length == 0) {
      throw methodError(&quot;@Headers annotation is empty.&quot;);
    }
    headers = parseHeaders(headersToParse);
  } else if (annotation instanceof Multipart) {
    if (isFormEncoded) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isMultipart = true;
  } else if (annotation instanceof FormUrlEncoded) {
    if (isMultipart) {
      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);
    }
    isFormEncoded = true;
  }
}

// 处理Parameter级别Annotation
private ParameterHandler&lt;?&gt; parseParameter(
    int p, Type parameterType, Annotation[] annotations) {
  ParameterHandler&lt;?&gt; result = null;
  for (Annotation annotation : annotations) {
    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(
        p, parameterType, annotations, annotation);

    ...// handleException

    result = annotationAction;
  }
  ...// handleException

  return result;
}

// 具体的处理Annotation的实现, 方法颇长就不贴详情了
private ParameterHandler&lt;?&gt; parseParameterAnnotation(
    int p, Type type, Annotation[] annotations, Annotation annotation) {
  if (annotation instanceof Url) { // handle @Url
    ...// throw Exception if necessary

    gotUrl = true;

    if (type == HttpUrl.class
        || type == String.class
        || type == URI.class
        || (type instanceof Class &amp;&amp; &quot;android.net.Uri&quot;.equals(((Class&lt;?&gt;) type).getName()))) {
      return new ParameterHandler.RelativeUrl();
    } else {
      ...// throw Exception
    }

  } else if (annotation instanceof Path) { // handle @Path
    ...// throw Exception if necessary

    gotPath = true;

    Path path = (Path) annotation;
    String name = path.value();
    validatePathName(p, name);

    Converter&lt;?, String&gt; converter = retrofit.stringConverter(type, annotations); // 见Retrofit.stringConverter()
    return new ParameterHandler.Path&lt;&gt;(name, converter, path.encoded()); // 见ParameterHandler.Path&lt;&gt;

  } else if (annotation instanceof Query) { // handle @Query
  } else if (annotation instanceof QueryName) { // handle @QueryName
  } else if (annotation instanceof Header) { // handle @Header
  } else if (annotation instanceof FieldMap) { // handle @FieldMap
  } else if (annotation instanceof Part) { // handle @Part
  } else if (annotation instanceof PartMap) { // handle @PartMap
  } else if (annotation instanceof Body) { // handle @Body
  }
  return null; // Not a Retrofit annotation.
}
</code></pre><p>可见<code>Retrofit</code>对注解的处理分为两个部分: 一个是<code>Method</code>级别的<code>Annotation</code>, 所有<code>http</code>协议方法都被定义为该级别的<code>Annotation</code>, 在<code>ServiceMethod.parseHttpMethodAndPath</code>中处理(注意到, 基本方法<code>DELETE</code> <code>GET</code> <code>HEAD</code> <code>POST</code>等应该是互斥的, 但代码中没有进行判断, 而<code>Multipard</code>和<code>FormUrlEncoded</code>之间却进行了判断, 至于代码中没有对<code>Streaming</code>的处理, 是因为逻辑上它不在这一层, 而是在响应结果的解析, 所以其实是在<code>retrofit2/BuiltInConverters.java</code>中进行了处理); 另一个是<code>Parameter</code>级别的, 大多数是在进行基本预处理之后就委托给<code>ParameterHandler</code>接口的实现类进行处理.  </p>
<p>通过对某个方法的注解的处理, 在<code>ServiceMethod.Builder.build()</code>完成后<code>ServiceMethod</code>就获取到了调用该方法发起网络请求所需要的信息, 可以开始构造<code>Call</code>了.  </p>
<h3 id="Retrofit的Call与Response"><a href="#Retrofit的Call与Response" class="headerlink" title="Retrofit的Call与Response"></a>Retrofit的Call与Response</h3><p><code>Retrofit</code>的<code>Call</code>和<code>Response</code>是对<code>OkHttp</code>的<code>Call</code>和<code>Response</code>的封装, 为什么要进行这么一层封装呢? 接下来我们就看看它的源码.<br>我们选择从核心方法<code>Retrofit.create(Class)</code>开始.  </p>
<pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service); // #1
  if (validateEagerly) {
    eagerlyValidateMethods(service); // #2
  }

  // #3 below
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
      new InvocationHandler() {
        private final Platform platform = Platform.get();

        @Override public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
          // If the method is a method from Object then defer to normal invocation.
          if (method.getDeclaringClass() == Object.class) {
            return method.invoke(this, args);
          }
          if (platform.isDefaultMethod(method)) {
            return platform.invokeDefaultMethod(method, service, proxy, args);
          }
          ServiceMethod&lt;Object, Object&gt; serviceMethod =
              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); // #4
          OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // #5
          return serviceMethod.callAdapter.adapt(okHttpCall); // #6
        }
      });
}
</code></pre><p>这里面一共有三个步骤, 其中前两步是用来检查接口和提前载入方法的, 第三步是关键, 生成并返回了一个代理. 实例化代理时传入了三个参数, 第三个是<code>InvocationHandler</code>的实现, 我们可以看到里面最关键的步骤是<code>#4 #5 #6</code>, 分别完成方法载入(<code>Method-&gt;ServiceMethod</code>), <code>Call</code>构造和返回<code>Call</code>代理. 这里<code>Proxy</code>及<code>InvocationHandler</code>都是<code>Java</code>中就已经存在并引入了<code>Android</code>中的机制, 即动态代理机制. 关于动态代理机制, 思想成熟战法犀利, 是相当有意思的一个东西, 可以参见<a href="http://a.codekk.com/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">这篇文章</a><br>总之要使用动态代理呢, 委托类必须要实现某个接口, 而<code>Proxy</code>创建的代理类通过实现<code>InvocationHandler</code>来调用委托类的方法, 完成代理. 所有这一切都跟反射密不可分, 所以理所当然<code>Proxy</code>是在反射包下的.<br>从上面代码可以看出, <code>Platform.isDefaultMethod()</code>和<code>Object</code>的方法将被<code>InvocationHandler</code>直接代理执行, 而其他方法则被包装成<code>OkHttpCall</code>交给<code>ServiceMethod</code>的<code>CallAdapter</code>去执行. 这里也可以看出对<code>Call</code>和<code>Response</code>进行封装代理的作用: 屏蔽底层实现, 统一处理非核心逻辑, 统一接口, 令底层替换成其他网络访问库成为可能.  </p>
<p>下面我们来看<code>ServiceMethod</code>的构造过程, <code>OkHttpCall</code>的构造过程以及默认的<code>CallAdapter</code>的代码.<br>还记得在<code>create</code>里传入<code>loadServiceMethod</code>的是<code>Method method</code>, 它是代理方法, 通过它去访问委托(被代理)方法, 代码如下:  </p>
<pre><code>ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) {
  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);
  if (result != null) return result;

  synchronized (serviceMethodCache) {
    result = serviceMethodCache.get(method);
    if (result == null) {
      result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); // 传入Retrofit, Method实例, 构造代理包装类ServiceMethod实例
      serviceMethodCache.put(method, result); // 缓存代理方法-代理包装实例映射
    }
  }
  return result;
}
</code></pre><p>然后根据传入的方法及其参数, 构造一个合适的<code>Call</code>, 这个<code>Call</code>是<code>OkHttp</code>中<code>Call</code>的代理, 所以<code>Retrofit</code>中它的类是<code>OkHttpCall</code>. 下面我们看它是怎么构造和代理的, 代码如下:  </p>
<pre><code>final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; {
    OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) {
      this.serviceMethod = serviceMethod;
      this.args = args;
    }

    @Override public void enqueue(final Callback&lt;T&gt; callback) {
      // 检查参数

      okhttp3.Call call;
      Throwable failure;

      synchronized (this) {
        if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);
        executed = true;

        call = rawCall;
        failure = creationFailure;
        if (call == null &amp;&amp; failure == null) {
          try {
            call = rawCall = createRawCall();
          } catch (Throwable t) {
            failure = creationFailure = t;
          }
        }
      }

      if (failure != null) {
        callback.onFailure(this, failure);
        return;
      }

      if (canceled) {
        call.cancel();
      }

      call.enqueue(new okhttp3.Callback() { // okhttp3.Callback反向代理retrofit2.Callback
        @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
            throws IOException {
          Response&lt;T&gt; response;
          try {
            response = parseResponse(rawResponse); // 解析响应
          } catch (Throwable e) {
            callFailure(e); // 回调自身callFailure
            return;
          }
          callSuccess(response); // 回调自身callSuccess
        }

        @Override public void onFailure(okhttp3.Call call, IOException e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callFailure(Throwable e) {
          try {
            callback.onFailure(OkHttpCall.this, e);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }

        private void callSuccess(Response&lt;T&gt; response) {
          try {
            callback.onResponse(OkHttpCall.this, response);
          } catch (Throwable t) {
            t.printStackTrace();
          }
        }
      });
    }
}
</code></pre><p>结构清晰, 基本可以当做<code>OkHttpCall</code>来对待.  </p>
<p>接下来通过<code>ServiceMethod.callAdapter.adapt(OkHttpCall)</code>将<code>OkHttpCall</code>转换为<code>Call&lt;T&gt;</code>. <code>ServiceMethod</code>的建造模式如下:  </p>
<pre><code>Builder(Retrofit retrofit, Method method) {
  this.retrofit = retrofit;
  this.method = method;
  this.methodAnnotations = method.getAnnotations(); # 获取代理方法的方法注解
  this.parameterTypes = method.getGenericParameterTypes(); # 获取泛型参数类型
  this.parameterAnnotationsArray = method.getParameterAnnotations(); # 获取参数注解
}

public ServiceMethod build() {
  callAdapter = createCallAdapter(); # 根据泛型返回类型和方法注解, 通过retrofit.callAdapter(returnType, annotations)寻找适配器实例. Retrofit实例化时默认添加`DefaultCallAdapterFactory`工厂
  responseType = callAdapter.responseType(); # 获取返回类型
  if (responseType == Response.class || responseType == okhttp3.Response.class) {
    throw methodError(&quot;&apos;&quot;
        + Utils.getRawType(responseType).getName()
        + &quot;&apos; is not a valid response body type. Did you mean ResponseBody?&quot;); # 不允许以`Response`作为返回类型
  }
  responseConverter = createResponseConverter();

  for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation); # 解析方法注解
  }

  if (httpMethod == null) {
    throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
  }

  ...// 判断方法注解合法性

  int parameterCount = parameterAnnotationsArray.length;
  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
  for (int p = 0; p &lt; parameterCount; p++) {
    Type parameterType = parameterTypes[p];
    // 解析参数注解
    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];
    ...
    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
  }

  ...// 判断参数合法性

  return new ServiceMethod&lt;&gt;(this);
}

ServiceMethod(Builder&lt;R, T&gt; builder) {
  this.callFactory = builder.retrofit.callFactory();
  this.callAdapter = builder.callAdapter;
  this.baseUrl = builder.retrofit.baseUrl();
  this.responseConverter = builder.responseConverter;
  this.httpMethod = builder.httpMethod;
  this.relativeUrl = builder.relativeUrl;
  this.headers = builder.headers;
  this.contentType = builder.contentType;
  this.hasBody = builder.hasBody;
  this.isFormEncoded = builder.isFormEncoded;
  this.isMultipart = builder.isMultipart;
  this.parameterHandlers = builder.parameterHandlers;
}
</code></pre><p>始终别忘了以上内容都是通过<code>Java</code>自带的<code>Proxy</code>机制调用<code>InvocationHandler</code>来代理的, 所以<code>create</code>传入的是什么类, 返回的就是什么类的代理, 访问这个代理的方法时, 实际调用的是<code>InvocationHandler</code>. 通过<code>ServiceMethod.callAdapter.adapt()</code>可以将传入的方法适配为你自己定义的返回类型<code>Call&lt;T&gt;</code>的实例. 我们来看看默认情况下添加的<code>DefaultCallAdapterFactory</code>会生成什么<code>CallAdapter</code>:  </p>
<pre><code>public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { // 工厂方法, 传入返回类型, 注解数组, retrofit实例
  if (getRawType(returnType) != Call.class) { // 返回类型如果不是Call则直接返回null
    return null;
  }

  final Type responseType = Utils.getCallResponseType(returnType); // 获取ReturnType&lt;T&gt;中泛型参数T的上限类型
  return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() {
    @Override public Type responseType() {
      return responseType;
    }

    @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) {
      return call; // 默认返回传入参数
    }
  };
}
</code></pre><p>显然默认情况下这个适配器什么也不做, 直接把传入的<code>OkHttpCall</code>返回给你.  </p>
<h3 id="Retrofit的Converter与CallAdapter-开始使用RxJava"><a href="#Retrofit的Converter与CallAdapter-开始使用RxJava" class="headerlink" title="Retrofit的Converter与CallAdapter: 开始使用RxJava"></a>Retrofit的Converter与CallAdapter: 开始使用RxJava</h3><p>上文已经暗示了, 对结果的解析器<code>Converter</code>可以替换, 其实发送请求的代理<code>Call</code>也可以被替换, 只要换掉<code>CallAdapter</code>就可以了, 网上都说<code>RxJava+Retrofit</code>可以打出成吨输出, 原因就在于<code>CallAdapter</code>可以换成一个返回<code>Observable</code>类型的适配器, 这使得在<code>Retrofit.create()</code>之后可以直接以<code>RxJava</code>的风格做链式调用.<br>实现起来也非常简单, 只要<code>.addConverterFactory()</code> <code>.addCallAdapterFactory()</code>即可, 因为<code>Retrofit</code>对外提供了抽象类<code>Converter.Factory</code> <code>CallAdapter.Factory</code>, 并且实例全部使用泛型来表示, 通过对外提供统一接口, 只要外部可以继承抽象工厂类并返回实现了统一接口的实例类, 就可以在不改变<code>Retrofit</code>一行代码的情况下接入其他库, 或者原有逻辑代码变动不大的情况下接入<code>Retrofit</code>.  </p>
<p>是时候上一波图了:<br><img src="/images/blogs/retrofit_okhttp.png" alt="Retrofit, RxJava 和 OkHttp之间的关系"><br>上面这张图是我基于<a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Stay的这篇文章</a>改的, 荣耀归他, 另外由于图滞后于<code>Retrofit</code>版本, 所以如果有不一致的地方锅也归他(目前没看见不一致).  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>这篇文章分析了<code>Retrofit</code>的实现, 其优缺点即使不是一目了然, 也是足够清晰了, 希望能够帮助到正在选择网络请求框架的各位.<br>本文参考如下:  </p>
<ul>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">Retrofit 源码解析</a>  </li>
<li><a href="http://www.jianshu.com/p/097947afddaf" target="_blank" rel="external">Retrofit源码分析（超详细）</a>  </li>
<li><a href="http://www.jianshu.com/p/07dac989272c" target="_blank" rel="external">Android网络框架源码分析二—Retrofit</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a>  </li>
<li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit</a>  </li>
<li><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit源码</a>  </li>
<li><a href="https://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a>  </li>
<li><a href="https://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="external">Retrofit文档</a>  </li>
<li><a href="https://inthecheesefactory.com/blog/retrofit-2.0/en" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲Retrofit. 总的来说它是一个面向业务流程的网络请求库, 内部默认使用面向网络协议的库OkHttp来打出成吨伤害.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Android网络架构</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/28/%5BAndroid%E6%95%99%E7%A8%8B%5DAndroid%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/28/[Android教程]Android网络架构/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-05-04T10:27:47.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为方便初学者, 也为知识体系能够脉络清晰, 本文分为两个部分:  </p>
<ul>
<li>第一部分讲述网络基础知识, 这是一切的基本功  </li>
<li>第二部分讲述几种常用的Android网络框架的使用方法和设计思想(不涉及源码解析)  </li>
</ul>
<p>由于Android官方提供的网络请求工具就是<code>HttpURLConnection</code>, 内容比较少就不再单独写了, 放在了第二部分. 各位可各取所需.  </p>
<h2 id="http基础知识"><a href="#http基础知识" class="headerlink" title="http基础知识"></a>http基础知识</h2><h3 id="http的历史"><a href="#http的历史" class="headerlink" title="http的历史"></a>http的历史</h3><p>我觉得了解一点技术的历史, 有助于理解该技术产生的思想内核, 以及时代局限, 但是网络这个话题实在太广泛, 因此不得不择其一二来讲述, 我选择了http及其相关技术, 不感兴趣的同学可以跳过.  </p>
<p>http协议可以说是目前互联网使用最广泛的协议, 它在RFC中的定义历经二十年至今版本迭代才至2.0, 此前主要使用的是http1.0/1.1, 版本之间差异很大, 但不像别的技术, http由于影响面及其广, 所以在整个互联网中更新换代是非常缓慢的过程.  </p>
<p>http是现在事实标准TCP/IP协议簇中的一员, 但它不为TCP/IP而生, 也不依赖于TCP/IP, 事实上只要保证传输稳定性, 它的下层用什么协议它并不关心(它自身位于协议栈的栈顶, 即应用层). 在上个世纪90年代, http诞生了, 它的主要设计人是Tim Berners Lee 博士, 这位牛人同时也是HTML, WWW和URL的主要贡献者, 是一个真正值得敬仰的前辈. http规定的是服务器和客户端之间, 或者说虚拟机和虚拟机之间, 数据传输的约定, 它从作用到内容其实并不神秘, 它的发展历程几乎可以等同于国际互联网的发展历程.  </p>
<p>http全称是<code>HyperText Transfer Protocol</code>, 超文本传输协议. 名字好像挺玄乎, 其实也不神秘, 首先它把一段包含很多额外信息的文本称为超文本, 比如这段文本里面有URL链接, 代表另一段文本, 或者代表一个多媒体文件. 然后这个传输协议就是约定发送和接收双方如何来对待这段超文本, 发送方如何封包, 接收方如何解包, 这很像快递过程, 超文本被包裹在内, 其外放上一些防止内容被破坏的数据, 以及一些写着出发地和到达地的数据, 到了到达地, 再由收件人拆包, 获得超文本内容.  </p>
<p>虽然说起来简单, 但这个协议实际上有长达60页的协议细节, 有兴趣的同学可以查看<a href="http://www.rfc-editor.org/rfc/rfc1945.txt" target="_blank" rel="external">RFC-http</a>和<a href="http://www.rfc-editor.org/rfc/rfc2068.txt" target="_blank" rel="external">RFC-http1.1</a>两个文档, 你如果熟知这两个文档的内容, 那下面有关http1.0/1.1的部分就完全不用看了.  </p>
<h3 id="http基础-协议格式-https"><a href="#http基础-协议格式-https" class="headerlink" title="http基础: 协议格式, https"></a>http基础: 协议格式, https</h3><p>以下内容主要参考维基百科<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" title="Hypertext_Transfer_Protocol_Wikipedia" target="_blank" rel="external">Http-Wiki</a>, RFC定义<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="external">w3http1.1</a>, 在线博客和一些计算机书籍  </p>
<p>前面说了, http协议规定了怎么在客户端和服务端之间传输文件, 而规定的方式就是在传输数据包的时候, 在头尾加东西. 本节就来看看具体加了什么东西, 也就是http协议格式. 注意, 本节<strong>不讲tcp协议</strong>  </p>
<p>教科书上都是由上到下, 先讲协议设计再讲具体数据, 但我想随着门槛的降低, 真正从事计算机相关工作且有坚实计算机网络基础的同学可能不多, 所以我从实践到理论地来讲http协议格式, 可能同学们更好理解些. 为方便说明, 我们可以任意生成一个http数据包, 比如, 我用Chrome自带的抓包工具<code>chrome://net-internals/</code>随便抓取了几个访问某https页面时生成的包(不带任何参数). 经过格式化解析之后的内容如下(#是我给的注释):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">t=695 [st=  0] +REQUEST_ALIVE  [dt=149]</div><div class="line">t=695 [st=  0]    DELEGATE_INFO  [dt=6] # 请求代理信息</div><div class="line">                  --&gt; delegate_info = &quot;NavigationResourceThrottle&quot;</div><div class="line">t=701 [st=  6]   +URL_REQUEST_DELEGATE  [dt=2]</div><div class="line">t=701 [st=  6]      DELEGATE_INFO  [dt=2]</div><div class="line">                    --&gt; delegate_info = &quot;扩展程序“AdBlock”&quot;</div><div class="line">t=703 [st=  8]   -URL_REQUEST_DELEGATE</div><div class="line">t=703 [st=  8]    URL_REQUEST_START_JOB  [dt=1] # URL请求类型</div><div class="line">                  --&gt; load_flags = 37121 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VALIDATE_CACHE | VERIFY_EV_CERT) # 标志位</div><div class="line">                  --&gt; method = &quot;GET&quot; # 请求方法</div><div class="line">                  --&gt; priority = &quot;HIGHEST&quot; # 优先级</div><div class="line">                  --&gt; url = &quot;https://www.baidu.com/&quot; #请求的URL</div><div class="line">t=704 [st=  9]   +URL_REQUEST_START_JOB  [dt=135]</div><div class="line">                  --&gt; load_flags = 37121 (MAIN_FRAME_DEPRECATED | MAYBE_USER_GESTURE | VALIDATE_CACHE | VERIFY_EV_CERT)</div><div class="line">                  --&gt; method = &quot;GET&quot;</div><div class="line">                  --&gt; priority = &quot;HIGHEST&quot;</div><div class="line">                  --&gt; url = &quot;https://www.baidu.com/&quot;</div><div class="line">t=704 [st=  9]      URL_REQUEST_DELEGATE  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_GET_BACKEND  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_OPEN_ENTRY  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_ADD_TO_ENTRY  [dt=0]</div><div class="line">t=704 [st=  9]      HTTP_CACHE_READ_INFO  [dt=0]</div><div class="line">t=708 [st= 13]     +HTTP_TRANSACTION_SEND_REQUEST  [dt=0] # 请求事务类型</div><div class="line">t=708 [st= 13]        HTTP_TRANSACTION_SEND_REQUEST_HEADERS # 头部</div><div class="line">                      --&gt; GET / HTTP/1.1 # 方法, 协议, 版本</div><div class="line">                          Host: www.baidu.com # 主机</div><div class="line">                          Connection: keep-alive # 连接类型</div><div class="line">                          Cache-Control: max-age=0 # 缓存</div><div class="line">                          Upgrade-Insecure-Requests: 1</div><div class="line">                          User-Agent: Mozilla/5.0 (X11; Linux x86_64)  AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36 # 用户代理</div><div class="line">                          Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 # 接受的数据类型</div><div class="line">                          DNT: 1</div><div class="line">                          Accept-Encoding: gzip, deflate, sdch, br # 接受的数据类型</div><div class="line">                          Accept-Language: zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4 # 接受的语种</div><div class="line">                          Cookie: [1203 bytes were stripped] # 附带的Cookie, 被解包工具跳过了</div><div class="line">t=708 [st= 13]     -HTTP_TRANSACTION_SEND_REQUEST</div><div class="line">t=708 [st= 13]     +HTTP_TRANSACTION_READ_HEADERS  [dt=130] # 读取事务类型</div><div class="line">t=708 [st= 13]        HTTP_STREAM_PARSER_READ_HEADERS  [dt=130] # 解析头部</div><div class="line">t=838 [st=143]        HTTP_TRANSACTION_READ_RESPONSE_HEADERS# 读取响应头部</div><div class="line">                      --&gt; HTTP/1.1 200 OK # 协议, 版本, 状态</div><div class="line">                          Server: bfe/1.0.8.18</div><div class="line">                          Date: Tue, 24 Jan 2017 02:26:34 GMT # 时间</div><div class="line">                          Content-Type: text/html;charset=utf-8 # 内容类型, 字符集</div><div class="line">                          Transfer-Encoding: chunked # 传输编码类型</div><div class="line">                          Connection: keep-alive # 连接类型</div><div class="line">                          Cache-Control: private # 缓存控制</div><div class="line">                          Expires: Tue, 24 Jan 2017 02:26:34 GMT # 过期时间</div><div class="line">                          Content-Encoding: gzip # 内容编码</div><div class="line">                          X-UA-Compatible: IE=Edge,chrome=1 # UserAgent兼容</div><div class="line">                          Strict-Transport-Security: max-age=172800</div><div class="line">                          BDPAGETYPE: 2</div><div class="line">                          BDQID: 0xa98302dc00005b89</div><div class="line">                          BDUSERID: 27620551</div><div class="line">                          Set-Cookie: [19 bytes were stripped] # 设置Cookie</div><div class="line">                          Set-Cookie: [17 bytes were stripped]</div><div class="line">                          Set-Cookie: [54 bytes were stripped]</div><div class="line">                          Set-Cookie: [124 bytes were stripped]</div><div class="line">t=838 [st=143]     -HTTP_TRANSACTION_READ_HEADERS</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_INFO  [dt=0]</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_DATA  [dt=0]</div><div class="line">t=838 [st=143]      HTTP_CACHE_WRITE_INFO  [dt=0]</div><div class="line">t=838 [st=143]      URL_REQUEST_DELEGATE  [dt=1]</div><div class="line">t=839 [st=144]      URL_REQUEST_FILTERS_SET</div><div class="line">                    --&gt; filters = &quot;FILTER_TYPE_GZIP&quot;</div><div class="line">t=839 [st=144]   -URL_REQUEST_START_JOB</div><div class="line">t=839 [st=144]    HTTP_TRANSACTION_READ_BODY  [dt=0] # 读取Body</div><div class="line">t=839 [st=144]    HTTP_CACHE_WRITE_DATA  [dt=0] # 写缓存, 下面还有几次读取Body和写缓存</div><div class="line">t=840 [st=145]    URL_REQUEST_JOB_FILTERED_BYTES_READ</div><div class="line">                  --&gt; byte_count = 11343</div><div class="line">t=840 [st=145]    HTTP_TRANSACTION_READ_BODY  [dt=0]</div><div class="line">t=840 [st=145]    HTTP_CACHE_WRITE_DATA  [dt=0]</div><div class="line">t=844 [st=149] -REQUEST_ALIVE</div></pre></td></tr></table></figure></p>
<p>所以可以看到我们客户端的请求是一个比较简单的结构Header, 而主机返回的报文分成Header和Body两个部分. 先看我们发送的Header.  </p>
<p>发送Header这个行为类型是<code>URL_REQUEST_START_JOB</code> <code>HTTP_TRANSACTION_SEND_REQUEST</code>, 我们发送的Header中method是GET, 表明我们想从服务器获取数据, http协议中允许的方法有以下几种:  </p>
<ul>
<li>GET: 用来请求访问已被URL识别的资源  </li>
<li>POST: 用来传输实体的主体  </li>
<li>PUT: 用来传输文件  </li>
<li>HEAD: 和GET方法一样，只不过不返回实体报文  </li>
<li>DELETE: 用来指定删除文件，与PUT方法相反  </li>
<li>OPTION: 用来查询针对请求URL指定的资源支持的方法  </li>
<li>TRACE: 让web服务器端将之前的请求通信还回给客户端的方法  </li>
<li>CONNECT: 要求的与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信  </li>
</ul>
<p>发送的包是否有消息体(Body)取决于方法, GET方法没有消息体, POST方法就有消息体. host是请求的主机, DNS域名解析, Socket连接建立等过程我们不去探究, 我们只要知道它代表了谁来处理这次请求. 接着看到了Connection, 这个字段表示连接选项, 可以告诉服务器怎么对待这次连接, 有<code>close</code>和<code>keep-alive</code>两种模式, 在0.9/1.0版本时, http连接默认是完成之后立即关闭, 需要设置为<code>keep-alive</code>模式才能保持连接, 在1.1以后, http连接默认就是<code>keep-alive</code>模式, 需要设置<code>close</code>模式才能断开连接. <code>keep-alive</code>的连接数过多的话就会引起服务器性能问题, 同一个页面如果交互次数多而不设置<code>keep-alive</code>的话, 会造成响应过慢的问题, 因为每次请求数据都要重新经历一次建立连接的过程. 注意, 即使设置了<code>keep-alive</code>也不能一定保证连接被保持. 用户代理(<code>User-Agent</code>)代表使用的软件(例如浏览器)是什么类型, 通过UA服务器可以区别对待响应内容, 比如Android系统/Chrome浏览器, 或者Mac系统/Safari浏览器等. Accept段表示可接受的媒介数据类型, 例如网页, 图片, 应用, 音频等. Accept-Encoding与之类似, 不过限制的对象是响应中的消息体编码, 例如允许gzip压缩文件等. Accept-Language表示页面语言, 没什么好说的, 注意它不同于页面编码.<br>至此Header内容就没有了, 如果是POST请求那么在此之后还有一个消息体代表要传输的内容.  </p>
<p>接下来我们看服务器给回来的响应<code>Response</code>的格式(这里就不贴内容了, 依旧用chrome查看响应包), 其实可以看出它的格式与http请求的格式非常类似, 只不过多了一些响应状态的数据. 仍然先看Header, 第一行是响应协议, 响应状态代码, 以及响应状态. http的响应状态是一个三位数的数字编码, 大致意思是这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1xx：指示信息--表示请求已接收, 继续处理.</div><div class="line">2xx：成功--表示请求已被成功接收、理解、接受. # 正常状态就是200</div><div class="line">3xx：重定向--要完成请求必须进行更进一步的操作. # 例如重定向301 302</div><div class="line">4xx：客户端错误--请求有语法错误或请求无法实现. # 403 404就在这里</div><div class="line">5xx：服务器端错误--服务器未能实现合法的请求. # 500 Internal Server Error在这里</div></pre></td></tr></table></figure></p>
<p>然后给了响应时间, 返回内容的类型(<code>text/html</code>)和编码(<code>utf-8</code>). 接着是Transfer-Encoding, 值为<code>chunked</code>. 这是一个比较重要的字段, 它代表这个响应本身以什么方式进行”传输编码”, 以保证能够正确传输. 例如, 这里的<code>chunked</code>代表要传输的消息体被分成一系列块(chunk)来传输, 每个块有自己的块长度, 这就是”流模式(streaming)”. 这意味着动态产生的内容就算很长, 并且服务端预先无法知道总长度, 也可以通过这种方式到达客户端, 只要它包含客户端用以判断是否传输完成的必要信息. 这个值也意味着会有后续消息传输, 也意味着连接应该被保持. 文档指出, http1.0及更旧版本的应用可能无法识别<code>Transfer-Encoding</code>这个属性. 后面的内容几乎是对应请求中的可接受内容相应值了, 同时这个响应还设置了cookie值. cookie这个东西挺有意思的, http是无连接的协议, 但有时候又真的需要一些已经生成的信息, 所以就需要把这些未来会用到的信息保存下来, cookie就起这么个作用. 再往后就是消息体了, 消息体里面会包含例如本段消息长度, 下段消息编号, 等这样的信息.  </p>
<p>在http协议中, 没有对请求URL的长度和消息体的长度做任何限制, 但在实践中由于缓存, 性能, 传输效率, 安全等实际需求, 一般对URL长度和消息体大小都会做一定的限制, 这种限制既有客户端(浏览器)限制, 又有服务端限制. 另外, 从前面可以看出, cookie是放在请求的Header中一起发出的, 所以如果对请求Header大小有限制的话, 势必对cookie总大小也有限制. 实际上多数浏览器也确实限制了同一个域下cookie的数目.  </p>
<p>这就是一次URL请求和响应的全部内容. 平时我们用到GET, POST, <code>keep-alive</code>等方法和属性比较多, 可能对其他几种方法和属性不太熟悉.  </p>
<p>讲完了http协议格式, 现在来看https. https又叫 <code>HTTP over TLS</code>, 顾名思义是建立在一层TLS之上的http. TLS全称 Transport Layer Security, 传输层安全协议, 它的前身是SSL, Secure Sockets Layer. HTTPS协议下的URI格式与HTTP完全相同, 只不过它指示浏览器用一层SSL/TLS加密层来保护网络传输. HTTPS协议中, 在传统的HTTP之上又加了一层SSL/TLS, 所以说实现上是SSL/TLS在http之上, 逻辑上是http在SSL/TLS之上. SSL/TLS层创建了一个客户端和服务端之间的隧道, 所有传输都在这个隧道中完成, 这意味着http协议中传输的一切内容, 包括url, 都可以被加密(主机地址和端口号除外, 因为他们是TCP/IP协议的必需部分, 这意味着ip和端口可能被攻击者替换). SSL/TLS层负责服务端信任和传输安全保证.  </p>
<h3 id="http基础-http2-0"><a href="#http基础-http2-0" class="headerlink" title="http基础: http2.0"></a>http基础: http2.0</h3><p>以下内容主要参考<a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank" rel="external">Http2-Wiki</a> <a href="https://http2.github.io/http2-spec/" target="_blank" rel="external">HTTP/2 Spec</a>和<a href="http://blog.csdn.net/pangqiandou/article/details/53098962" target="_blank" rel="external">http协议揭秘</a>  </p>
<p>理解了1.1协议之后, 2.0版本的协议就只需要重点看差异. 2.0版本协议是在2015年发布的, 正式名称是<code>HTTP/2</code>, 因为计划中不再有子版本, 下个版本的HTTP协议主版本号将是3. 在HTTP/2出现之前, 最流行的http1.1协议, 同一个TCP连接里面, 所有数据通信按次序进行, 服务器只有处理完一个回应, 才能进行下一个回应, 任意一个回应都可能成为瓶颈造成阻塞, 造成传输效率底下. 由于这是http1.1协议的缺陷, 因此我们只能设法避开这个问题, 一般有两个思路, 一是减少请求数, 二是多个持久连接, 很多网页优化技巧就是在此基础上开发出来的, 比如合并脚本和样式表, 将图片嵌入css代码, 域名分片等. 2009年, Google公开了它自主研发的SPDY协议, 其主要目的就是解决http1.1协议效率不高的问题, 并且在彼时已经在chrome浏览器上证明了其可行性. SPDY协议被当做HTTP/2协议的基础, 其主要特性在HTTP/2中都有体现.<br>相比http1.1, http/2有以下不同:  </p>
<ul>
<li>纯二进制.<br>在http1.1中头信息可以是文本(ASCII编码), 消息体可以是文本或二进制, 在http/2中, 头信息和消息体都是二进制, 被称为头信息帧(header frame)和数据帧. 这样做可以定义更多种类型的帧, 根据帧类型进行二进制数据解析, 显然比通过文本来获得数据类型, 再进行解析要快捷得多.  </li>
<li>多工.<br>HTTP/2复用TCP连接, 在同一个连接里, 客户端和服务端都可以同时发送多个请求或响应, 而且不用按照顺序. 例如, 服务器同时收到A请求和B请求, 先响应A请求, 发现非常耗时, 于是把A请求已经处理好的部分发送回去, 再响应B请求并处理, 完成后发送A请求剩下的部分. 这样同时允许上行和下行数据的通信方式叫做双工通信, 服务器可以和多个客户端建立这种通信, 因此叫多工.  </li>
<li>数据流.<br>HTTP/2中数据表不按顺序发送, 因此同一个连接里面连续的数据包可能属于不同的响应, 因此在数据包中有做标记表明它属于哪个响应. HTTP/2将一次响应对应的所有数据包, 称为一个数据流(stream), 每个数据流都有独一无二的编号, 每个数据包都必须标记数据流ID. 约定客户端发送的数据流ID一律为奇数, 服务端发送的则为偶数. 在http1.1中要在发送数据的中途取消数据发送, 唯一的方式就是关闭TCP连接, 但http/2中允许在任意时刻由任意一方发送取消信号(RST_STREAM帧)来取消数据流传输, 并且保持TCP连接活跃.  </li>
<li>头信息压缩.<br>http1.1协议中, 由于连接本身不带状态, 所以每次请求都需要携带全部必须信息, 实际情况是同一次TCP连接时候携带的cookie, user agent这些信息往往是不变的, 导致不必要的重复发送, 浪费了带宽. 在http/2中, 引入头信息压缩机制, 一方面, 头信息被gzip或compress压缩后再发送, 另一方面, 客户端和服务端同时维护一张头信息表, 所有字段都会存入这个表, 生成一个索引号, 多次发送只发送索引号而不必发送重复的字段.  </li>
<li>服务器推送.<br>http/2允许服务器主动向客户端发送资源, 即服务器推送(Server Push). 例如, 客户端请求一个页面, 该页面包含很多静态资源. 正常情况下客户端必须解析完返回的html之后, 再根据内容去请求静态资源, 但在http/2协议下, 服务端可以预判客户端在请求该网页后很可能会再次请求静态资源, 因此可以主动把静态资源跟网页一起发送给客户端.  </li>
</ul>
<h2 id="Android中流行的网络框架使用方法及其设计思想"><a href="#Android中流行的网络框架使用方法及其设计思想" class="headerlink" title="Android中流行的网络框架使用方法及其设计思想"></a>Android中流行的网络框架使用方法及其设计思想</h2><p>在Android源码中, 有两种访问网络的方式, 一种是使用<code>HttpClient</code>, 另一种是<code>HttpURLConnection</code>, Google曾选择前者, 后来切换到了后者, 原因见<a href="https://android-developers.googleblog.com/2011/09/androids-http-clients.html" target="_blank" rel="external">这篇文章</a>, 大体是说<code>HttpClient</code>好是好bug也少但是太重, 相比之下Android上使用更轻量级的<code>HttpURLConnection</code>更合适. 在我看来技术本身没有好与不好之分, 只有合不合时宜, 至今我没有改变过这个看法. <code>HttpClient</code>是从Java继承来的, 是Apache基金会负责维护的网络客户端, 它好不好, 当然好, 大量的人在让它变得更好. 但是正因为它用的地方太广了, 需要照顾的人群和情景太多, 所以它在任何特定的情境下都很难作为最好的选择, 例如移动开发. 哪怕是它的兄弟项目<code>AndroidHttpClient</code>专门为Android而生, 也仍然携带了太多API内容, 以至于Android项目如果要使用它, 就会受到它的掣肘. 相反, <code>HttpURLConnection</code>提供的API就要少得多, 这让Android系统团队对它的扩展要容易得多.<br>我们打开SDK中的<code>HttpURLConnection</code>这个类, 可以发现它提供的API确实少, 它连同它的父类<code>URLConnection</code>提供的API都主要是面向上面我们介绍的http协议格式的, 可以很明确地知道我们如何调用它的API来构造一个URL请求.<br>一次网络请求很简单, 但是我们面临的问题往往是复杂的多次网络请求, 比如下载, 比如图片, 比如很多很多其他情况, 这就要求我们对所有需要的网络连接进行管理, 什么时候该开新长连接, 什么时候该关闭, 什么时候该新开线程运行, 什么时候需要缓存, 如何处理异常返回码等等, 而这里面大多数工作其实跟我们的业务没有什么关系. 做网络请求管理, 是一件令人心烦的事情, 有烦心事就会有人想要去解决, 于是Android上出现了诸多网络通信的库, 他们提供更高层级的封装和抽象, 面向业务逻辑而不是http报文格式来设计API. 他们提供缓存机制和连接管理机制, 他们让我们不需要关心网络连接的细节, 只需要关注业务逻辑.<br>下面我们就简单介绍其中较为流行的几种框架.  </p>
<h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>名声很大, 大到什么程度呢? 一问你们用的什么网络框架, Volley都会出现在备选中. 它跟OkHttp应该算是两个主流网络请求框架了. 它是谷歌的亲儿子, 在2013年随着Google I/O推出, 作为一个网络请求模块, 独立于Android系统之外, 它像是把<code>AsyncHttpClient</code>和<code>Universal-Image-Loader</code>的优点都集于一身, 可以简单地进行http通信, 也可以轻松加载网络图片. Google出品不敢说全都是精品, 但至少是一流.<br>Volley在<code>HttpURLConnection</code>基础之上, 设计了简单易用的API, 同时在性能方面也有大幅优化, 设计目标是处理数据量不大但通信频繁的网络操作, 对于大数据量的网络操作则并不擅长.<br>频繁请求的场景是非常常见的, 例如新闻订阅, 定期更新的任何场景, 实时类应用, 像微博啊Twitter之类的都属于这一类.  </p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>既然是独立模块, 自然需要单独下载安装使用.<br>本节主要参考<a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Volley官方文档</a><br>我们可以通过源码下载Volley库:  </p>
<pre><code>git clone https://android.googlesource.com/platform/frameworks/volley
# 或者 https://github.com/google/volley
</code></pre><p>再用Android Studio或者SDK把它导出为jar包, 或者直接将这个库作为library module依赖.<br>也可以使用官方给出的gradle依赖配置:  </p>
<pre><code>compile &apos;com.android.volley:volley:1.0.0&apos;
</code></pre><p>也可以使用别人放在Maven仓库的包(这个是个人行为, 不是官方放上去的, 并且现在已经停止维护了)  </p>
<pre><code>compile &apos;com.mcxiaoke.volley:library:1.0.6&apos;
</code></pre><p>这位作者把Volley放到了Github上, 地址是 <a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a>, 感谢他.<br>我们将会以一次Get请求和/或一次Post请求为例, 来说明Volley以及接下来几个框架的基本使用方法.  </p>
<pre><code>//简单的 GET 请求
mQueue = Volley.newRequestQueue(getApplicationContext());  
mQueue.add(new JsonObjectRequest(Method.GET, url, null,  
            new Listener() {  
                @Override  
                public void onResponse(JSONObject response) {  
                    Log.d(TAG, &quot;response : &quot; + response.toString());  
                }  
            }, null));  
mQueue.start();
</code></pre><p>这个例子是我在<a href="http://www.codeceo.com/article/android-network.html" target="_blank" rel="external">这篇文章</a>里摘抄的. 从这些代码我们可以猜测一些东西(由于本文不涉及Volley源码解析, 所以我也还没读过源码, 只能猜测, 之后我会抽空把Volley源码和OkHttp源码都走一遍):  </p>
<ol>
<li>Volley类恐怕是单例, 甚至不提供实例, 只提供静态方法. 原因是构造请求队列时调用静态方法, 使用了Context信息, 而且这个例子中使用的是Application Context, 在我有关Context的分析文章中说过, 这个Context实际就是整个Application.  </li>
<li>基于接口. 显而易见, 就连响应类型都已经有预定义的接口了, 需要什么类型的请求直接找Volley的API就搞定, 而且显然即使官方没有也一定有人做了基于泛型的自定义接口. Volley在定义好这些接口之后, 基于这些接口就可以把缓存/并发/性能优化/图片优化/连接管理等功能给做了, 而完全不必关心请求具体是什么样子. 另外, 从队列add方法中新建的匿名类的回调来看, Volley的工作模式显然是异步的.  </li>
<li>轮询. 这个是基于最后一句的猜测, 队列调用了start()方法想必是开始处理请求了, 这一点非常像Handler的使用中调用Looper.loop()方法开始处理消息队列, 所以这么猜测.  </li>
</ol>
<p>可以看到, 相较于HttpURLConnection, Volley的网络请求构造起来就简单多了, 任何细节我们都不必关心, 只需要给出最基本的参数(Method, URL)和一个回调.  </p>
<h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>本节主要参考<a href="http://www.cnblogs.com/yueyanglou/p/5446464.html" target="_blank" rel="external">Volley设计思想和流程分析</a>  </p>
<p><style><br>img {<br>    width: 600px;<br>    height: 400px;<br>}<br></style><br><img src="/images/blogs/volley.png" alt="volley原理图"><br>啊这是个视频截图.  </p>
<p>Volley中的请求数据流在<strong>RequestQueue</strong>中, 一切故事都围绕它展开. 原理图中我们可以看到Volley被设计为三种线程下的分工, 第一种当然是UI线程, 它负责将新产生的请求加入到请求队列, 以及对请求的响应做处理. 第二种是cache thread, 它负责请求及其响应的缓存. 第三种是网络线程, 它负责实际分发网络请求, 响应解析, 以及写缓存.  </p>
<p>在故事开始, 我们通过<code>Volley.newRequestQueue</code>生成了一个请求队列, 并且如果打开源码稍微看一下就会知道Volley在此时就帮我们创建了缓存数据结构(<code>DiskBasedCache</code>)和网络连接线程池, 建立好请求队列之后, 我们同时拥有了缓存请求队列(在缓存线程)和网络请求队列(在网络线程).  </p>
<p>接下来就是处理这些请求. 两种请求对应两种线程, <code>CacheDispatcher</code>处理缓存请求, 传入缓存请求队列和网络请求队列, 这两个队列的具体实现请看源码. 它先从缓存请求队列取出缓存请求, 在缓存中查找请求, 如果命中, 则直接从缓存取得响应进行分发, 如果没有命中或者缓存已过期, 则把这个请求放到网络请求队列中. <code>NetworkDispatcher</code>处理网络请求队列, 它先从网络请求队列中获取请求, 使用网络连接池进行实际的网络请求, 请求完成后如果返回结果可以缓存则存入缓存, 最后将响应结果分发.  </p>
<p>到这里, Volley的魔术就只剩三个地方了: Cache管理, Request定义, 以及Request执行. 这是Volley高效的秘密所在. 先说Request执行. Volley定义了<code>HttpStack.performRequest</code>接口帮助定义Request执行过程, Request执行阶段, 默认的<code>HttpStack</code>实现会通过这个接口获取到Request实例和Headers, 构造http请求, 然后获取到响应的Response二进制流. 随后它调用Request的<code>parseNetworkResponse</code>将响应按照格式进行解析, 得到数据实体.  </p>
<p>来看<code>Request</code>定义. Volley中预定义了几种常用的请求, 例如<code>StringRequest</code>, <code>JsonRequest</code>等, 所有这些请求中都有一个<code>Listener&lt;T&gt;</code>参数, T是请求所预期的返回数据类型. 这个参数就是我们在上面示例代码中添加的回调了, 在解析完<code>Response</code>之后, Volley便会调用<code>Request.deliverResponse</code>方法分发响应, 这跟<code>Handler</code>是不是很像? 在该方法中, 就是调用了<code>Listener.onResponse</code>来处理响应. 针对不同的请求, 可以对<code>Request</code>的定义有特定的优化.  </p>
<p>再看缓存<code>Cache</code>. 前面说了, Volley默认使用<code>DiskBasedCache</code>作为缓存的数据结构. 这里我们不去看它的具体实现, 其实它不见得是最佳选择. 我们重点来看在整个请求生成到执行过程中Cache的作用. 假如没有缓存那么每次请求都会实实在在地被执行, 这在对某一静态资源做多次请求的时候显然不合适, 造成带宽和性能浪费. 缓存在这里的作用就是, 在每次新的请求发生的时候, 先检查是否可以由缓存提供响应, 如果可以就不会执行网络请求了, 这样网络负载就转化成了缓存读取负载, 在<code>DiskBasedCache</code>中就是文件读取负载(因为它把缓存写在了文件里). 在每次真正执行了请求之后, 如果请求预先设置了要进行缓存, 就会把这次请求的url连同它的响应, 包上一个<code>CacheHeader</code>(内含缓存大小等属性), 写入到SD卡中, 并在内存中保存一份<code>&lt;URL, CacheHeader&gt;</code>的映射, 用以判断是否存在缓存以及缓存是否有效.  </p>
<p>关于缓存更详细的内容参见<a href="http://www.voidcn.com/blog/yuan514168845/article/p-4950325.html" target="_blank" rel="external">Volley的cache之硬盘缓存–DiskBasedCache</a>  </p>
<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>前面说了Volley的原理, 基本上也就展现了它的优点: 面向<code>Request</code>接口, 灵活度高, 对<code>Request</code>有多个封装, 可以取消请求, 有缓存, 可以设置请求优先级, 可以有多个并发的网络连接, 自动异步执行等等. 它当然也有一些缺点或者说不足:  </p>
<ol>
<li><code>ImageRequest</code>, <code>ImageLoader</code>仍然不够高效. 这都是因为后来出了更高效的框架, 技术世界就是这样, 不服老不行.  </li>
<li>默认不支持<code>https</code>  </li>
</ol>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>大神<code>JackWharton</code>出品(他的其他”小作品”还包括: <code>Retrofit</code>, <code>Butterknife</code>, <code>ActionBarSherlock</code>, <code>DiskLruCache</code>… Github上年提交3k+, 精力之旺盛, 执行力之强, 我辈典范).  </p>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用方法参见我另一篇博客<a href="https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/">OkHttp源码探索</a>  </p>
<h4 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h4><p>设计思想其实在上面那篇博客的<code>OkHttp</code>架构图中可以看出. 总的来说是在<code>http/https/SPDY</code>协议基础上做了一层一对一的封装, 接管了缓存管理/请求管理/连接管理/响应解析等环节, 并分别进行了优化, 如多线程并发的请求和连接, 基于<code>DiskLruCache</code>的缓存管理, 非UI线程的响应等.  </p>
<h4 id="局限-1"><a href="#局限-1" class="headerlink" title="局限"></a>局限</h4><p><code>OkHttp</code>的优点是好用的同时保留了几乎和<code>HttpURLConnection</code>一样的接口, 学习成本较低, 但同时缺点也是它: API更接近协议, 对用户不够友好, 我们需要处理较多不属于业务的内容.  </p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p><code>Retrofit</code>其实是在<code>OkHttp</code>这样一个Http封装库的基础上再进行的一次封装(当然你也可以用别的方式完成请求), 它更多的是面向业务流程而非协议细节, 所以比上面两个妖艳贱货要高一个层次.  </p>
<h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>Retrofit</code>和<code>OkHttp</code>都是属于<code>Square</code>公司的开源项目, 主力开发同样是<code>JackWharton</code>, 令人敬佩的同时也就理解了它为什么默认采用<code>OkHttp</code>作为底层请求库. 不得不说<code>Okio+OkHttp+Retrofit</code>这套组合不仅好用而且足够灵活和容易扩展, 是开源世界一道优美的风景.  </p>
<h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>见我另一篇博客<a href="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/">Retrofit源码探秘</a>  </p>
<h4 id="设计思想-2"><a href="#设计思想-2" class="headerlink" title="设计思想"></a>设计思想</h4><p><code>Retrofit</code>将网络请求彻底视为<code>路径/参数/响应函数</code>的组合, 于是采用了<code>annotation</code>的方式来描述网络请求, 并用它来标注响应函数, 而把一切构造请求和获取响应的过程都藏到了身后, 开发者不需要知道背后的任何细节.<br>这其实跟<code>Flask</code>的服务端的思路有点相似.  </p>
<h4 id="局限-2"><a href="#局限-2" class="headerlink" title="局限"></a>局限</h4><p><code>Retrofit</code>的好处是隐藏了一切细节, 一切<code>dirty work</code>, 你只需要按照特定格式使用注解去定义一个请求, 其他的事情都可以交给他来做. 同时它保留了足够的灵活性和可扩展性, 实际的请求是由一个单独的请求工具完成的, 这个工具可以换成适合你业务的任意其他工具, 只需要实现一层中间接口.<br>以上都是它的优点, 那么它的缺点在哪里呢?<br>曾经的它无法取消正在进行的请求(而<code>OkHttp</code>是可以的), 也无法仅获取<code>Json</code>格式的字符串返回结果(它会自动使用<code>Gson</code>去解析成实例对象), 然而<code>2.0+</code>版本以后, 请求接口重新定义了之后已经可以像<code>OkHttp</code>那样轻松地取消请求, 同时它去掉了自动, 默认仅仅解析为字符串, 你需要自行添加对应<code>Converter</code>库依赖才能使用它为你实现的解析器, 或者你也可以自行实现一个解析器.<br>然而它依然有一些限制, 例如<code>interface</code>不能继承其他的<code>Interface</code>. 这还算可以接受, 毕竟每个业务完全应该有一套单独的业务接口, 应该通过接口的组合而不是继承来使用接口, 也许它现在最大的缺点就是<code>1.x</code>和<code>2.x</code>完全不兼容了(就连这一点, 它也有提供向下兼容的API库来解决).  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/android/" target="_blank" rel="external">Android源码</a>  </li>
<li><a href="https://developer.android.com/guide/index.html" target="_blank" rel="external">Android官网介绍</a>  </li>
<li><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="external">Android网络请求心路历程</a>  </li>
</ul>
<p><hr><br>update: 2017-02-27 我把<code>OkHttp</code>的源码大致走了一遍, 记录在<a href="https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/">这里</a><br>update: 2017-02-28 我把<code>Retrofit</code>的源码大致走了一遍, 记录在<a href="https://hjhjw1991.github.io/android/2017/03/01/[Android源码伴读]Retrofit源码探秘/">这里</a>  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Android系统下网络请求的多种姿势
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android源码伴读】OkHttp源码探索</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/27/%5BAndroid%E6%BA%90%E7%A0%81%E4%BC%B4%E8%AF%BB%5DOkHttp%E6%BA%90%E7%A0%81%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/27/[Android源码伴读]OkHttp源码探索/</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2017-03-05T11:15:02.011Z</updated>
    
    <content type="html"><![CDATA[<p><code>OkHttp</code>是一种面向<code>http</code>协议的高效网络请求库, 下面我们就来探索它的源码, 找到它高效的秘密.<br>源码github地址: <a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a>  </p>
<h2 id="OkHttp的使用"><a href="#OkHttp的使用" class="headerlink" title="OkHttp的使用"></a>OkHttp的使用</h2><p>这一节是为了那些从未用过<code>OkHttp</code>而写, 如果您已经可以很熟练地使用<code>OkHttp</code>, 这节的内容不适合您.<br>可以通过配置<code>build.gradle</code>指定使用<code>OkHttp</code>.<br><code>OkHttp</code>采用<code>Builder</code>模式构造请求, 它可以做的事情在<code>public static class Builder</code>这个内部类中都告诉你了, 接口对应了<code>http</code>协议请求的内容. 也就是说, 你必须要了解<code>http</code>协议以及你想要构造的请求的具体内容, 才能很方便地使用<code>OkHttp</code>, 这就是我说<code>OkHttp</code>是面向<code>http</code>协议的请求库的原因. 直观上来说, 它把构造请求和获取响应的操作简单化了.<br>更多使用教程参见<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a>.  </p>
<p>不仅如此, 查看它的<a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="external">文档</a>, 可以发现它定义了大约50个类, 除了常规的几个<code>Builder</code>类和<code>Factory</code>类以外, 其他类都是面向网络请求某一方面的. 从类名来看, 涵盖了请求, 响应, 回调, 鉴权, 加密, 证书, 连接池, Cookie, Dns, Tls, MultipartBody等方面. 可以很明显感受到它支持<code>Https</code>和<code>Http/2</code>协议. 据<a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">OkHttp源码解析</a>所述, 它也同时支持<code>SPDY</code>.  </p>
<h2 id="OkHttp源码探索"><a href="#OkHttp源码探索" class="headerlink" title="OkHttp源码探索"></a>OkHttp源码探索</h2><p>废话少说, 我们现在就开始源码探索. 在探索之前, 先对<code>OkHttp</code>工作流, 也就是它的模型有一个整体的认识, 见下图:<br><img src="/images/blogs/okhttp_workflow.png" alt="okhttp-workflow">  </p>
<p>上图来自<a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">这篇博客</a>, 很可惜博客已经过时了, 特别是<code>HttpEngine</code>已经被三个新的拦截器所取代, 不过架构还是没有变的.  </p>
<h3 id="OkHttp请求分发类Dispatcher"><a href="#OkHttp请求分发类Dispatcher" class="headerlink" title="OkHttp请求分发类Dispatcher"></a>OkHttp请求分发类Dispatcher</h3><p>以下我们将介绍<code>OkHttp</code>中的类源码, 重点来介绍<code>OkHttp</code>为了优化网络请求做了哪些工作.<br>在发起一个请求的时候, 是调用<code>OkHttpClient.newCall().enqueue(Callback)</code>来入队一个异步请求, 其中调用<code>Dispatcher.enqueue(AsyncCall)</code>执行真正的入队操作. 我们来看看<code>Dispatcher</code>的注释:  </p>
<pre><code>
/**
 * Policy on when async requests are executed.
 *
 * &lt;p&gt;Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
 * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
 * of calls concurrently.
 */
</code></pre><p>这个分发器负责调度和并发执行请求, 看描述我们大致能猜到它内部使用了<code>ExecutorService</code>去执行请求队列. 打开文件发现它是直接<code>new ThreadPoolExecutor</code>来初始化的, 不限制线程池容量, 使用<code>SynchronousQueue</code>作为底层结构, 自行维护一个<code>maxRequests</code>来限制正在执行的请求的最大数量. 调用<code>enqueue()</code>将准备好的请求加入到正在执行的请求队列中并调用<code>executorService().execute(call)</code>执行(我们知道, 这里面就是把要执行的<code>Runnable</code>加入到队列中,等待被调度到的时候调用<code>Runnable.run()</code>接口).  </p>
<p><code>AsyncCall</code>是<code>RealCall</code>的内部类, 在<code>enqueue</code>的时候实际上就是将一个<code>AsyncCall</code>实例入队到<code>ExecutorService</code>的队列中, 反而没<code>RealCall</code>什么事. <code>AsyncCall</code>继承自<code>NamedRunnable</code>, 而<code>NamedRunnable</code>显然继承自<code>Runnable</code>, 并且在它里面把<code>run()</code>方法实现为调用<code>execute()</code>方法. 这就使得<code>ExecutorService</code>通过调用<code>run()</code>方法最终会调用到<code>AsyncCall.execute()</code>方法. 那外层的<code>RealCall</code>又有什么用呢? 其实它提供了一个同步的<code>execute()</code>方法可以让<code>RealCall</code>实例立即被加入到执行队列中, 并等待返回.<br>下面我们来看<code>RealCall</code>的代码.  </p>
<pre><code>
// in file okhttp3/RealCall.java

 @Override public Response execute() throws IOException {
   synchronized (this) {
     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
     executed = true;
   }
   captureCallStackTrace();
   try {
     client.dispatcher().executed(this);
     Response result = getResponseWithInterceptorChain();
     if (result == null) throw new IOException(&quot;Canceled&quot;);
     return result;
   } finally {
     client.dispatcher().finished(this);
   }
 }

 @Override public void enqueue(Callback responseCallback) {
   synchronized (this) {
     if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
     executed = true;
   }
   captureCallStackTrace();
   client.dispatcher().enqueue(new AsyncCall(responseCallback));
 }

   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;

     AsyncCall(Callback responseCallback) {
       this.responseCallback = responseCallback;
     }

     ......

     @Override protected void execute() {
       boolean signalledCallback = false;
       try {
         Response response = getResponseWithInterceptorChain();
         if (retryAndFollowUpInterceptor.isCanceled()) {
           signalledCallback = true;
           responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
         } else {
           signalledCallback = true;
           responseCallback.onResponse(RealCall.this, response);
         }
       } catch (IOException e) {
         if (signalledCallback) {
           // Do not signal the callback twice!
           Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
         } else {
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
         client.dispatcher().finished(this);
       }
     }
   }
</code></pre><h3 id="OkHttp请求执行和响应"><a href="#OkHttp请求执行和响应" class="headerlink" title="OkHttp请求执行和响应"></a>OkHttp请求执行和响应</h3><p> 现在我们了解了请求的并发执行, 我们再来看连接. 上述过程中好像没有看到哪里有管理连接的内容? 别急, 我们一步一步来, 先找到第一个返回<code>Response</code>的地方. 经过上述观察我们发现在<code>getResponseWithInterceptorChain</code>方法第一次得到<code>Response</code>. 在这个方法里面, 用了一系列拦截器(<code>Interceptor</code>)来初始化一个<code>RealInterceptorChain</code>实例, 并通过该实例的<code>proceed()</code>方法获得了<code>Response</code>. 打开<code>RealInterceptorChain.proceed</code>可以发现它是对<code>RealInterceptorChain</code>链上的<code>Interceptor</code>逐个地使用同一套连接参数去初始化和调用<code>intercept()</code>方法, 那么具体拦截下来做什么, 就得看具体<code>intercept</code>中的行为了. 这里可以看到拦截器链首先是添加了<code>Client</code>上的拦截器, 然后加上<code>retryAndFollowUpInterceptor</code>和另外三个拦截器. 我们看看默认的拦截器都有哪些:  </p>
<pre><code>
OkHttpClient(Builder builder) {
  this.dispatcher = builder.dispatcher;
  this.proxy = builder.proxy;
  this.protocols = builder.protocols;
  this.connectionSpecs = builder.connectionSpecs;
  this.interceptors = Util.immutableList(builder.interceptors);// 初始化拦截器
  this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
  this.proxySelector = builder.proxySelector;
  this.cookieJar = builder.cookieJar;
  this.cache = builder.cache;
  this.internalCache = builder.internalCache;
  this.socketFactory = builder.socketFactory;

  boolean isTLS = false;
  for (ConnectionSpec spec : connectionSpecs) {
    isTLS = isTLS || spec.isTls();
  }

  if (builder.sslSocketFactory != null || !isTLS) {
    this.sslSocketFactory = builder.sslSocketFactory;
    this.certificateChainCleaner = builder.certificateChainCleaner;
  } else {
    X509TrustManager trustManager = systemDefaultTrustManager();
    this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
    this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
  }

  this.hostnameVerifier = builder.hostnameVerifier;
  this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
      certificateChainCleaner);
  this.proxyAuthenticator = builder.proxyAuthenticator;
  this.authenticator = builder.authenticator;
  this.connectionPool = builder.connectionPool;
  this.dns = builder.dns;
  this.followSslRedirects = builder.followSslRedirects;
  this.followRedirects = builder.followRedirects;
  this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
  this.connectTimeout = builder.connectTimeout;
  this.readTimeout = builder.readTimeout;
  this.writeTimeout = builder.writeTimeout;
  this.pingInterval = builder.pingInterval;
}
</code></pre><p>直接用的<code>Builder</code>的拦截器, 看一下发现是个空的<code>ArrayList</code>, 好吧, 啥都没有. 那第一个被调用<code>intercept</code>方法的就是<code>retryAndFollowUpInterceptor</code>了. 打开看看发现他是首先分配了一个<code>StreamAllocation</code>, 在流不断开的情况下不断调用传入的拦截器获得响应结果, 并与前面得到的响应结果组装起来, 在无后续响应结果的情况下返回响应.<br> 看来我们还得追踪下一个拦截器, 我估计追踪到最后一个就是实际的连接创建了. 果不其然, <code>BridgeInterceptor</code>作为桥, 将用户请求<code>Request</code>重新构造了一个<code>Request</code>并交给传入的拦截器处理, 对返回的<code>Response</code>也做了处理, 如存<code>Cookie</code>, 构造新的<code>Response</code>等. 它的下一个拦截器是<code>CacheInterceptor</code>, 这个拦截器就是处理缓存的了, 根据我们的缓存策略在缓存表中试图获取缓存的响应并判断是否只需要返回缓存就行了. 如果缓存不适用, 则调用传入的拦截器处理请求, 并根据返回的情况更新缓存时间或重写缓存. 我个人觉得需要注意它代码中多处地方都非常注意关闭缓存, 以防止内存泄漏. 下一个拦截器是<code>ConnectInterceptor</code>, 这应该就是真正发起请求的地方了, 它的代码比意料中少:  </p>
<pre><code>
// in file okhttp3/internal/connection/ConnectInterceptor.java
@Override public Response intercept(Chain chain) throws IOException {
  RealInterceptorChain realChain = (RealInterceptorChain) chain;
  Request request = realChain.request();
  StreamAllocation streamAllocation = realChain.streamAllocation();// #1

  // We need the network to satisfy this request. Possibly for validating a conditional GET.
  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);
  HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); // #2
  RealConnection connection = streamAllocation.connection();// #3

  return realChain.proceed(request, streamAllocation, httpCodec, connection);// #4 注意它虽然调用的是`proceed`而不是`intercept`, 但由于`RealInterceptorChain`中`proceed`的实现就是调用当前`intercept.intercept()`, 所以最终还是走到`intercept()`
}
</code></pre><p>这里关键步骤出来了: 分配IO Stream, Connect, Proceed. 这里传入的拦截器是<code>CallServerInterceptor</code>. 打开分别看看这三步对应的代码. <code>streamAllocation</code>返回的是此次连接的<code>StreamAllocation</code>, <code>connection()</code>返回的也是此次连接, 这两个值从上文可以看到是在<code>retryAndFollowUpInterceptor</code>中就已经初始化了. <code>proceed</code>最终走到<code>CallServerInterceptor.intercept</code>, 代码注释如下:  </p>
<pre><code>
// in file okhttp3/internal/http/CallServerInterceptor.java
@Override public Response intercept(Chain chain) throws IOException {
  HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
  StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
  Request request = chain.request();

  long sentRequestMillis = System.currentTimeMillis();
  httpCodec.writeRequestHeaders(request);

  Response.Builder responseBuilder = null;
  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {
    // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100
    // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return what
    // we did get (such as a 4xx response) without ever transmitting the request body.
    ...

    // Write the request body, unless an &quot;Expect: 100-continue&quot; expectation failed.
    ...
  }

  httpCodec.finishRequest();

  if (responseBuilder == null) {
    responseBuilder = httpCodec.readResponseHeaders(false);
  }

  Response response = responseBuilder
      .request(request)
      .handshake(streamAllocation.connection().handshake())
      .sentRequestAtMillis(sentRequestMillis)
      .receivedResponseAtMillis(System.currentTimeMillis())
      .build();

  int code = response.code();
  if (forWebSocket &amp;&amp; code == 101) {
    // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
    response = response.newBuilder()
        .body(Util.EMPTY_RESPONSE)
        .build();
  } else {
    response = response.newBuilder()
        .body(httpCodec.openResponseBody(response))
        .build();
  }

  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))
      || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {
    streamAllocation.noNewStreams();
  }

  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {
    throw new ProtocolException(
        &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());
  }

  return response;
}
</code></pre><p>厉害了, 原来最后用的是<code>HttpCodec</code>的实例来完成的请求发送和响应接收, 查看它的继承类可以看到<code>Http1Codec</code>和<code>Http2Codec</code>, 明显就是对应两种协议了, 前面在<code>ConnectInterceptor#2</code>的时候实例化了这个编码解码器(实例化过程中通过连接池获取一个可用的连接).<br> 这一条路径下来, 请求构造-&gt;连接构造-&gt;请求发送-&gt;响应接收-&gt;响应解析都完成了, 不得不说大神的代码看起来有点吃力但是非常舒服(拦截器链这一块, 原先曾经是<code>HttpEngine.java</code>完成上文三个默认拦截器的工作, 由<code>Square</code>的另一个大神分解为三个单独的职责分明的拦截器), 逻辑清晰层次分明, 而且还有够用的注释, 吃力主要还是因为自己的抽象能力不足, 对于网络连接的场景需要做什么在心里没有一个完整的模型.<br> 代码中可以看到通过连接池对连接进行了复用, 具体的数据读写使用了<code>Okio</code>(也是<code>Square</code>家的项目).  </p>
<h3 id="OkHttp缓存Cache"><a href="#OkHttp缓存Cache" class="headerlink" title="OkHttp缓存Cache"></a>OkHttp缓存Cache</h3><p>下面看看最后一个重点: 缓存<code>Cache</code>.<br>上文提到, 在<code>CacheInterceptor.intercept</code>中, 会在<code>InternalCache cache</code>中寻找当前请求的缓存, 并获取当前请求的缓存策略(<code>CacheStrategy.Factory(time, request, cacheCandidate).get()</code>), 如果<code>cache</code>不为<code>null</code>调用<code>cache.trackResponse</code>, 其余的判断是否请求被禁止或是否需要缓存等内容我们略过不提, 单看缓存更新<code>cache.update(cachedResponse, networkResponse)</code>和<code>cacheWritingResponse(cacheRequest, response)</code>, 这两种情况都已经访问了网络并获得了响应, 前者的响应表示未更改(状态码304), 客户端应直接读缓存, 所以我们只需要更新缓存的部分内容即可, 后者则需要更新整个缓存的<code>cacheResponse</code>. 两者代码分别如下:  </p>
<pre><code>
// in file okhttp3/Cache.java
void update(Response cached, Response network) {
  Entry entry = new Entry(network);
  DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
  DiskLruCache.Editor editor = null;
  try {
    editor = snapshot.edit(); // Returns null if snapshot is not current.
    if (editor != null) {
      entry.writeTo(editor);
      editor.commit(); // 类似map, 写入缓存. 缓存的默认实现是DiskLruCache  
    }
  } catch (IOException e) {
    abortQuietly(editor);
  }
}

// in file okhttp3/internal/cache/CacheInterceptor.java

  /**
   * Returns a new source that writes bytes to {@code cacheRequest} as they are read by the source
   * consumer. This is careful to discard bytes left over when the stream is closed; otherwise we
   * may never exhaust the source stream and therefore not complete the cached response.
   */
  private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)
      throws IOException {
    // Some apps return a null body; for compatibility we treat that like a null cache request.
    if (cacheRequest == null) return response;
    Sink cacheBodyUnbuffered = cacheRequest.body();
    if (cacheBodyUnbuffered == null) return response;

    final BufferedSource source = response.body().source();
    final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);

    Source cacheWritingSource = new Source() {
      boolean cacheRequestClosed;

      @Override public long read(Buffer sink, long byteCount) throws IOException {
        long bytesRead;
        try {
          bytesRead = source.read(sink, byteCount);
        } catch (IOException e) {
          if (!cacheRequestClosed) {
            cacheRequestClosed = true;
            cacheRequest.abort(); // Failed to write a complete cache response.
          }
          throw e;
        }

        if (bytesRead == -1) {
          if (!cacheRequestClosed) {
            cacheRequestClosed = true;
            cacheBody.close(); // The cache response is complete!
          }
          return -1;
        }

        sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);
        cacheBody.emitCompleteSegments();
        return bytesRead;
      }

      @Override public Timeout timeout() {
        return source.timeout();
      }

      @Override public void close() throws IOException {
        if (!cacheRequestClosed
            &amp;&amp; !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
          cacheRequestClosed = true;
          cacheRequest.abort();
        }
        source.close();
      }
    }; // 实现一个读取流, 读取Okio.BufferedSource接口的实例`response.body().source()`

    return response.newBuilder()
        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
        .build(); // 使用以上实现构造RealResponseBody, 传入当前响应, 构造新的响应拷贝
  }
</code></pre><p>其中<code>cache</code>的值是在<code>RealCall</code>中传入<code>new CacheInterceptor(client.internalCache())</code>时初始化的, 其值默认是<code>OkHttpClient.cache.internalCache</code>, 除非<code>cache</code>为空, 彼时会使用<code>OkHttpClient.internalCache</code>. 换句话说, 如果我们初始化<code>OkHttpClient</code>时把<code>cache</code>置空则可以通过设置<code>internalCache</code>使用我们自己的缓存. 事实上<code>OkHttpClient.Builder</code>中这两个缓存正是互斥的:  </p>
<pre><code>
/** Sets the response cache to be used to read and write cached responses. */
void setInternalCache(InternalCache internalCache) {
  this.internalCache = internalCache;
  this.cache = null;
}

/** Sets the response cache to be used to read and write cached responses. */
public Builder cache(Cache cache) {
  this.cache = cache;
  this.internalCache = null;
  return this;
}
</code></pre><p>至此, <code>OkHttp</code>的主干流程已经探索得差不多了, 我们也知道了它提升<code>http</code>效率的主要手段: 复用连接, 并发请求, 缓存响应, 异步响应. 它使得<code>http</code>连接在频繁低载荷或多次连续的数据传输中, 不至于在缓存和重新建立连接上花费太多时间.  </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/square/okhttp" target="_blank" rel="external">OkHttp源码</a>  </li>
<li><a href="http://square.github.io/okhttp/3.x/okhttp/" target="_blank" rel="external">OkHttp文档</a>  </li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">OkHttp使用教程</a>  </li>
<li><a href="http://frodoking.github.io/2015/03/12/android-okhttp/" target="_blank" rel="external">OkHttp源码解析</a>  </li>
<li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="external">OkHttp3源码分析综述</a>  </li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文讲OkHttp. 总体来说它是一个高效简洁易用易扩展的网络库.
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】View/ViewGroup源码阅读</title>
    <link href="https://hjhjw1991.github.io/android/2017/02/24/%5BAndroid%E6%95%99%E7%A8%8B%5DView&amp;ViewGroup%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://hjhjw1991.github.io/android/2017/02/24/[Android教程]View&amp;ViewGroup源码阅读/</id>
    <published>2017-02-23T16:00:00.000Z</published>
    <updated>2017-05-04T10:35:16.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文基于Android 4.0 源码</p>
</blockquote>
<h2 id="View与ViewGroup类结构"><a href="#View与ViewGroup类结构" class="headerlink" title="View与ViewGroup类结构"></a>View与ViewGroup类结构</h2><p><img src="/images/blogs/view_and_viewgroup.png" alt="View与ViewGroup的类关系">  </p>
<h2 id="View与Window"><a href="#View与Window" class="headerlink" title="View与Window"></a>View与Window</h2><p>Android系统中所有的UI类都是建立在<code>View</code>和<code>ViewGroup</code>基础上。<code>View</code>的子类包括widget包中的那些(常用的<code>TextView</code>、<code>ImageView</code>等都在这个包下)，<code>ViewGroup</code>的子类包括Layout命名的类以及<code>RecyclerView</code>等少数以View命名的类，<code>ViewGroup</code>又是<code>View</code>的直接子类，这样就允许<code>View</code>和<code>ViewGroup</code>并列与嵌套存在。在AS中可以通过F4查看类的继承关系。  </p>
<p>Window不继承于View，它就是一个用来显示东西的窗口，通过<code>setContentView</code>来显示东西(调用该方法之后紧接着调用<code>initWindowDecorActionBar</code>来设置ActionBar)，<code>Activity</code>自身持有一个<code>mWindow</code>(初始化为<code>PhoneWindow</code>，<code>PhoneWindow</code>的定义在源码目录<code>frameworks/policies/base/phone/com/android/internal/policy/impl/PhoneWindow</code>，它是Window的直接子类，被标注为<code>@hide</code>，SDK看不到，需要下载SDK源码才能看到，在SDK源码的<code>android-23/com/android/internal/policy/PhoneWindow</code>下)，<code>Activity</code>的<code>setContentView</code>就是<code>mWindow.setContentView</code>的代理。<code>PhoneWindow</code>有个<code>DecorView</code>内部类(继承自<code>FrameLayout</code>)，在初始化<code>PhoneWindow</code>的时候会创建一个<code>DecorView</code>的实例作为根视图。  </p>
<p>还有一个类叫做<code>LayoutInflater</code>，它本身是个抽象类，但只有一个<code>cloneInContext</code>是抽象方法。它采用工厂模式负责将布局文件xml实例化为View对象。看它的<code>inflate</code>方法，最终调用的都是<code>View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot)</code>这个方法，用<code>XmlResourceParser</code>从resource中获取parser，然后<strong>同步地</strong>完成这些调用：<br><code>result=root, attrs=Xml.asAttributeSet(parser)</code><br>-&gt; <code>temp=createViewFromTag(root, name=parser.next().getName(), inflaterContext=mContext, attrs)</code><br>-&gt; <code>root!=null?(params=root.generateLayoutParams(attrs);if(!attachToRoot)temp.setLayoutParams(params)):null</code><br>-&gt; <code>rInflateChildren(parser, temp, attrs, true)</code><br>-&gt; <code>if(root!=null &amp;&amp; attachToRoot) root.addView(temp, params); if(root==null || !attachToRoot)result = temp</code><br>-&gt; <code>return result</code><br>大致意思是首先解析xml，找到第一个开始的Tag即布局文件的根视图的标签，把它和布局文件的<code>AttributeSet</code>传给<code>createViewFromTag</code>就获得了布局文件的根View，如果root非空且要附加到root上就把这个View附加上去。在处理Tag时单独处理MERGE和INCLUDE两个Tag。在返回前调用了<code>rInflateChildren</code>方法来填充这个View的子视图，这是个递归填充子视图的方法，根据Tag名分别调用<code>parseRequestFocus parseViewTag parseInclude createViewFromTag&amp;&amp;rInflateChildren</code>来一层层创建View，在<code>finishInflate</code>的时候View提供了<code>onFinishInflate</code>回调供子类重写。  </p>
<p>这里就有三个东西了，Window、Inflater、View，他们之间的关系就好像画布、画笔和成品作品，xml布局文件就相当于设计图，Activity作为画家需要将成品按照设计图一层层画到画布上。<br>给个图来表示：<br><img src="/images/blogs/ActivityWindow.png" alt="ActivityWindow">  </p>
<h2 id="View绘制与重绘过程"><a href="#View绘制与重绘过程" class="headerlink" title="View绘制与重绘过程"></a>View绘制与重绘过程</h2><p><code>inflate</code>只是相当于给画作打了个线稿，规定了要画的内容的层次关系，具体画什么、在哪里画，就是View的绘制过程。Android中为View和ViewGroup设计了一致的绘制流程。绘制视图总要有个开端，仍以Activity为例，前面说到Activity通过<code>setContentView</code>用Inflater把xml导入成View树，这时候我们只是在逻辑上得到了View的结构，还没有实际画到屏幕上。猜想Activity载入了View之后，应该是在某个生命周期的时候绘图，回想Activity总是在onStart之后才能看到Activity内容，跟随Activity的生命周期，猜想是某个Manager比如ActivityManager在控制。随便找了一下Activity的startActivity方法，发现Activity中所有的startActivity实际上都是调用的<code>startActivityForResult</code>方法（它有两个重载），它里面又是调用的<code>Instrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this,intent, requestCode, options)</code>，在这个方法中使用<code>ActivityManagerNative</code>的<code>getDefault().startActivity()</code>真正开始Activity，查看源码知道<code>getDefault()</code>得到的是<code>ServiceManager.getService(&quot;activity&quot;)</code>，是系统提供的名为<code>activity</code>的服务，它经过<code>asInterface</code>转换成<code>IActivityManager</code>接口后作为结果返回，显然它的实现在Server端，同时有内部类<code>ActivityManagerProxy</code>用来调用远程服务，前面分析AIDL和Binder机制时候说过，实际上对远程服务的调用中，系统Binder驱动和Server各持有一个服务的实例，其中系统持有的是代理。通过<code>queryLocalInterface</code>区分是从服务端还是客户端进行服务调用，从服务端调用就直接返回本地服务了，从客户端调用则通过代理来访问服务。  </p>
<p>这里暂时停下，看到有一个<code>ActivityManager</code>类，很有意思，它的内部类AppTask有个<code>startActivity</code>方法，首先获取<code>ActivityThread</code>，再通过<code>Instrumentation.execStartActivityFromAppTask</code>在<code>ActivityThread</code>的<code>ApplicationThread</code>上开始Activity，点进去一看它实际上是调用的参数中的<code>IAppTask.startActivity</code>，回来看传入的参数是<code>mAppTaskImpl</code>，它的值由构造函数确定，而AppTask的构造函数是隐藏的，这很Android。顺藤摸瓜发现它在ActivityManager的getAppTasks方法中调用，实际上是从<code>ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName())</code>得到的任务列表，好嘛，又看到<code>ActivityManagerNative</code>了，可问题在于，这货的AppTask又是从哪儿得到的呢？  </p>
<p>以上花了不少力气，结果只看明白了Activity的启动是系统服务负责的，虽然通过查看SDK源码的<code>ServiceManager</code>找到了启动Activity的系统服务，但是仍然没有看到控制Activity绘制内容的相关代码，解耦解得厉害就是有这点不好，全都是面向接口了不太好找实现。用了一个土方法，根据分包直接去找activity服务的实现代码，感谢Android良好的模块设计，很快就找到了<code>com/android/server/am/ActivityManagerService.java</code>，一看它继承了<code>ActivityManagerNative</code>，稳了。直奔<code>startActivity</code>方法发现原来用的是<code>startActivityAsUser</code>方法，它又调用的<code>ActivityStackSupervisor.startActivityMayWait</code>，这个方法挺长的，关键的一步是调用<code>startActivityLocked</code>，里面调用<code>doPendingActivityLaunchesLocked</code>，它又调用<code>startActivityUncheckedLocked</code>，(一路各种设置flag，最后调用了<code>ActivityStack</code>的<code>startActivityLocked</code>，在Activity当前栈栈顶添加一个<code>ActivityRecord</code>，再调用<code>WindowManager.addAppToken</code>在task中存下Token，并且记录<binder,token>对应关系，有空单独写个Activity的启动，这里就不再说了)，惭愧看很久也没看到开始Activity的具体代码。求助Google，然后得知<code>ActivityThread</code>(同样是<code>@hide</code>，在SDK中看不到)是启动Activity的关键类，它运行<code>performLaunchActivity</code>和<code>handleResumeActivity</code>来创建和启动Activity。看到<code>performLaunchActivity</code>的第一个参数是<code>ActivityClientRecord</code>类型，感觉自己前面的功夫没有白费，在这里连接起来了。这里通过Instrumentation(<code>android/app/Instrumentation</code>)依次创建了<code>Activity</code>、<code>Application</code>和<code>Context</code>，然后又依次调用了Activity的<code>OnCreate</code>、<code>performStart</code>、<code>OnRestoreInstanceState</code>、<code>OnPostCreate</code>。现在还没有调用<code>OnResume</code>，理论上应该还没有绘制内容。<code>performStart</code>方法也只是使用<code>Instrumentation</code>调用了Activity自身的<code>OnStart</code>，并且将Start事件分发到<code>mFragments</code>而已。  </binder,token></p>
<p>来看<code>handleResumeActivity</code>，上来先是一记<code>performResumeActivity</code>(一番状态设置之后调用<code>activity.performResume</code>)，一堆状态读取和设置后，<code>if(r.activity.mVisibleFromClient)r.activity.makeVisible()</code>，这个方法看起来很有希望就是我要找的方法！找去源码一看，方法内容出奇的简单：<code>mDecor.setVisibility(View.VISIBLE)</code>可以说就这么一句。靠！根本还没完！  </p>
<hr>
<p>接着看，原来<code>View</code>的<code>setVisibility</code>所调用的<code>setFlags</code>方法会在传入参数为<code>VISIBLE</code>时调用<code>invalidate(true)</code>方法(顺便一提<code>setFlags</code>方法当然也会处理<code>GONE</code>和<code>INVISIBLE</code>，再顺便一提这就解释了为什么设置可见性后不需要调用<code>invalidate</code>就可以自动重绘)。最终还是走到了View源码。  </p>
<p>打开<code>invalidate(boolean invalidateCache)</code>，调用的<code>invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate)</code>，这里出现了一个神奇的<code>mGhostView</code>，之后还记得的话再来看看它是干嘛用的。<code>l t r b</code>是需要invalidate的区域，<code>invalidate</code>方法传入的直接就是View实例的整个区域。调用<code>mParent.invalidateChild</code>来invalidate给定区域。<code>mParent</code>只是一个<code>ViewParent</code>接口，它具体是指向什么实例还是要看代码。想一想Activity中什么内容都不设置的话，是有一个<code>DecorView</code>和一个id为content的<code>FrameLayout</code>，应该可以在<code>FrameLayout</code>或者<code>DecorView</code>找到具体的实现代码。幸运的是，在<code>FrameLayout</code>的父类<code>ViewGroup</code>中找到了<code>invalidateChild</code>方法(<code>ViewGroup</code>实现了<code>ViewParent</code>接口)。  </p>
<p>方法挺长，拣重点说。parent变量初始化为<code>ViewGroup</code>自身，先标记出dirty区域(为<code>transformMatrix</code>变形后的dirty区域上下左右各扩大0.5f)，然后调用parent的<code>invalidateChildInParent</code>方法对dirty区域进行扩展并将返回值赋予parent，如此往复直到parent为<code>null</code>为止。<code>ViewGroup</code>的这个方法返回<code>mParent</code>成员变量，它是一个隐藏的变量，从它的名字和可能为<code>null</code>来推断应该是会随着这个方法的调用而变化(我猜它会<strong>层层向上</strong>直到根视图<code>DecorView</code>的父<code>ViewRootImpl</code>，这个东西之前没有提过，其实它就是最顶层<code>DecorView</code>所添加到的地方, <code>DecorView</code>实例作为一个成员变量<code>mView</code>存在于它的实例中, 它受到<code>WindowManager</code>的实现类<code>WindowManagerImpl</code>实际上是<code>WindowManagerGlobal</code>的管理，它是逻辑上存在的一个东西，类型也不是View，但实现了<code>ViewParent</code>接口)，且是受系统什么服务控制的，我猜是<code>WindowManager</code>。在这个过程中如果如我所猜是层层向上，那么总会到达<code>DecorView</code>，而<code>DecorView</code>的父就是并不属于View子类的<code>ViewRootImpl</code>，当此时就会调用到<code>ViewRootImpl</code>的<code>invalidateChildInParent</code>方法，有意思的是这个方法最终返回<code>null</code>，这从侧面验证了我的猜测可能是对的。  </p>
<p>这里有一个关键变量，即<code>mAttachInfo.mInvalidateChildLocation</code>，这是一个仅两个元素的整型数组，分别存储child的left和top，从名字看存的是要invalidate的child的位置，真正绘制应该跟这个数组有关。</p>
<p>至此我发现前面整个过程是一个计算dirty区域的过程，想想图形的出现和更新其实都可以看做是对特定区域的绘制，通过计算dirty区域就统一了这两个行为。到了<code>ViewRootImpl</code>总算是计算完了dirty区域，接下来总应该画图了吧。一看果然，在<code>ViewRootImpl</code>的<code>invalidateChildInParent</code>方法中调用了<code>invalidateRectOnScreen</code>，而这个方法里又有个<code>scheduleTraversals</code>方法的调用，看起来就像是要遍历重绘的意思，它的代码是往Looper队列里添加了一个同步屏障，并在<code>mChoreographer</code>里添加了一个<code>TraversalRunnable</code>的回调，跑去这个Runnable的定义一看，就是调用了<code>doTraversal</code>方法，方法内容是移除同步屏障并执行<code>performTraversals</code>方法。这样想来，估计窗口第一次显示的时候类似的遍历过程会在<code>WindowManagerGlobal</code>调用<code>addView</code>方法之后调用吧。  </p>
<p>先不去管他，咱们来看<code>performTraversals</code>方法。……………………好长，里面写了一些debug的print，有空的话可以把debug开关打开来profile一下。这里挑重点看：首先是判断了一番当前的状态，是否需要创建Surface，是否需要完全重绘，是否需要硬件渲染，根据这些状态设置相应的条件，在满足Measure的条件时，调用<code>performMeasure</code>进行测量(该方法的内容是调用<code>mView.measure()</code>，在<code>View</code>的该方法实现代码中，调用了<code>onMeasure</code>，而<code>DecorView</code>的<code>onMeasure</code>方法在计算好自身宽高以后，调用了父类的<code>onMeasure</code>方法，我们还记得<code>DecorView</code>的父类是<code>FrameLayout</code>，去查看它的<code>onMeasure</code>方法就会发现，它对每一个child调用了<code>measureChildWithMargins</code>进行<strong>递归measure</strong>，然后才调用<code>setMeasuredDimension</code>设置自己的宽高)，measure不好还有可能measure第二次，测量完了之后<code>layoutRequested=true</code>； 接下来就执行了<code>performLayout</code>进行布局，方法中首先调用host(顶层<code>mView</code>的缓存)的layout进行布局(仍然调用的父类的<code>FrameLayout.onLayout</code>方法，非常暴力，就是一个<code>layoutChildren</code>进行<strong>递归layout</strong>)，然后计算有效的布局请求的View数量，如果此时还有需要布局的View则执行以下三步：遍历调用<code>View.requestLayout</code>，接着调用<code>measureHierarchy</code>，然后是<code>host.layout</code>再走一遍。这三步是第二次layout了，此时再检查还有没有需要布局的View，如果还有就只好将遍历调用<code>View.layout</code>的任务post到队列中等待下一帧执行，该方法完成后源码中注释说此时所有View就已经计算好并放置好了，接下来就会计算透明区域，主要就是把透明区域搜集起来并设置，如果透明区域跟之前的不同，则要求完全重绘；此时已经知道了屏幕上哪些地方需要重绘，哪些地方是透明的，接下来判断是否cancelDraw，<code>mAttachInfo.mTreeObserver.dispatchOnPreDraw()</code>完成(<code>AttachInfo</code>是<code>View</code>的内部类，当某个<code>View</code>附着到它的父窗口时，这个类的实例就存储一些相关的信息)或者<code>viewVisibility!=VISIBLE</code>都会被记为<code>cancelDraw</code>，如果可见性为<code>VISIBLE</code>则此时还会再试一次<code>scheduleTraversals</code>。只有在经过前面的状态判断后仍然需要绘制的情况下，才会调用<code>performDraw()</code>进行绘制，该方法调用<code>draw()</code>方法，在<code>draw()</code>中首先<code>mAttachInfo.mTreeObserver.dispatchOnDraw()</code>将事件传给观察者(<code>dispatchOnDraw</code>方法中，依次调用已注册的<code>OnDrawListener</code>中的<code>onDraw()</code>方法)，然后根据情况调用<code>mAttachInfo.mHardwareRenderer.draw</code>或者<code>drawSoftware</code>(在<code>drawSoftware</code>中会调用<code>mView.draw</code>，查看<code>DecorView</code>源码知道其实主要是调用的<code>super.draw</code>，再看<code>FrameLayout</code>源码发现未被重写，再往上到<code>ViewGroup</code>的源码，很棒仍然没找到<code>draw</code>不过找到了<code>drawChild</code>，再往上看，就到<code>View</code>了，<code>View</code>的<code>draw</code>方法中会先调用<code>drawBackground</code>，再调用<code>onDraw</code>来画自身内容，然后调用<code>dispatchDraw</code>请求孩子进行绘制，最后调用<code>onDrawForeground</code>。然而<code>View</code>中<code>dispatchDraw</code>是个空方法，根据逻辑它应该是个<code>ViewGroup</code>来实现，于是回来找到<code>ViewGroup</code>，果然里面有<code>dispatchDraw</code>的实现代码，这个方法大体还是对每个child调用<code>drawChild</code>，<code>drawChild</code>方法只是返回<code>child.draw</code>的结果，至此完成<strong>递归draw</strong>)，这期间有可能再来一次<code>scheduleTraversals</code>。  </p>
<p>看到这里有个疑问，<code>dirty</code>区域哪去了？其实回头一看就会知道，<code>dirty</code>早在<code>invalidateRectOnScreen</code>的时候就被合并到<code>mDirty</code>中了，而<code>mDirty</code>会在<code>draw</code>方法中使用。想必各位也注意到了，只有<code>draw</code>是要先<code>dispatchOnDraw</code>的，这暗示了这三个重要的步骤的逻辑是前两者由孩子发起，到父亲结束，而绘制动作是由父亲发起。但三个步骤的实际执行都是先执行孩子的对应方法，才执行父亲的对应方法。回想一下，一切的开端都在View调用<code>invalidate(true)</code>的时候。至此，整个重绘的过程就已经清楚了。  </p>
<p>那么，当一切开始时，Activity是怎样从零开始绘制<code>DecorView</code>的呢？借助前面重绘过程的探索分析，我发现了在执行<code>ActivityThread#handleResumeActivity</code>时会调用<code>r.activity.makeVisible()</code>方法使<code>activity</code>可见，这个过程就是上面我们分析过的测量和绘制视图的过程了。那么这些视图是什么时候初始化的呢？从<code>setContentView</code>到视图可见，之间经历了什么？其实在<code>makeVisible()</code>这个调用之前，在<code>performResumeActivity</code>之后，还有一个重要的步骤，就是添加<code>DecorView</code>，具体是先通过<code>r.window = r.activity.getWindow()</code>获取Activity所在的Window，并记录到r中，一般来说这个Window就是<code>PhoneWindow</code>了，所以接下来就不难理解调用<code>r.window.getDecorView()</code>获取到了<code>DecorView</code>的引用。获取到<code>DecorView</code>引用后，首先设置为<code>INVISIBLE</code>，然后通过<code>ViewManager wm = a.getWindowManager()</code>获取到<code>ViewManager</code>实例，通过<code>WindowManager.LayoutParams l = r.window.getAttributes()</code>获取到布局参数，最后通过<code>wm.addView(decor, l)</code>添加<code>DecorView</code>到<code>WindowManager</code>中。  </p>
<p>来看<code>addView</code>，前面讲过这里的<code>WindowManager</code>实际上是<code>WindowManagerGlobal</code>，所以我们知道这里实际调用的是<code>WindowManagerGlobal.addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code>(这里的后两个参数来自于<code>WindowManagerImpl</code>的<code>mDisplay</code>和<code>mParentWindow</code>)，它做了什么呢？打开源码，看到它首先使用<code>params</code>参数调整父窗口的子窗口(<code>parentWindow.adjustLayoutParamsForSubWindow(wparams)</code>)，然后<strong>同步地</strong>先确保之前的<code>removeView()</code>执行完毕，再用<code>View.getContext()</code>实例化了<code>ViewRootImpl</code>并赋值给局部变量<code>root</code>，同时分别在<code>mViews mRoots mParams</code>添加记录<code>view root params</code>。同步块之后调用了<code>root.setView(view, params, panelParentView)</code>设置视图内容。这个<code>setView</code>方法厉害了，它整个都是同步的，跳过一些我暂时看不懂的<code>SurfaceHolder</code>等内容后，首先设置<code>mAttachInfo.mRootView = view</code>，然后调用了<code>requestLayout</code>，然后调用<code>mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel)</code>将<code>mWindow</code>加入到<code>WindowManagerGlobal</code>中，然后<code>view.assignParent(this)</code>把<code>ViewRootImpl</code>注册为<code>DecorView</code>的父亲。其中<code>mWindowSession</code>是<code>WindowManagerService</code>的远程事务。至此，<code>DecorView</code>就已经被加入到<code>ViewRootImpl</code>并随着<code>PhoneWindow</code>加入到了<code>WindowManagerService</code>中接受其管理。  </p>
<p>总结一下，可以看到<code>View</code>的绘制过程和重绘过程其实本质上是一样的，只不过绘制的dirty区域是整个窗口。在<code>Activity</code>初始化的时候，在<code>ResumeActivity</code>之后，真正显示之前，<code>ActivityThread</code>进行了Activity中DecorView的创建、初始化和添加，然后通过调用<code>setVisibility</code>来间接调用<code>invalidate</code>方法进行重绘，在重绘时子View通过调用<code>invalidate</code>方法，请求父亲计算dirty区域并递归依次按需执行<code>measure、layout、draw</code>三种方法。孩子节点要进行重绘的时候，只需要在设置好新的界面值之后直接或间接调用<code>invalidate</code>方法，就可以触发该孩子节点及其所有<strong>祖先</strong>的重绘。源码为了健壮性，有很多地方都可能进行两次甚至三次某个步骤，有些地方甚至直接重新全部执行，过多次数的计算和重绘可能会产生性能瓶颈。  </p>
<h2 id="View与ViewGroup事件分发"><a href="#View与ViewGroup事件分发" class="headerlink" title="View与ViewGroup事件分发"></a>View与ViewGroup事件分发</h2><p>在前面我们已经见到了两个神奇的方法<code>dispatchOnPreDraw</code>和<code>dispatchOnDraw</code>，这一节我们来看更多的<code>dispatchXXX</code>, 也就是Android中的<strong>事件分发机制</strong>。多一句嘴, View的事件分发机制只是针对触屏事件的一种处理思路, 这种思路完全可以用在别的事件的分发和处理流程上.  </p>
<p>我们知道, 对于用户来说, 跟Activity交互的主要方式之一就是触屏, 而展示在用户面前, 用户可以看见的东西, 就是我们的 <code>View</code> 和 <code>ViewGroup</code>, 所以 <code>View</code> 和 <code>ViewGroup</code> 必然会对触屏事件做处理. 这里我们直接通过读源码的方式去了解<code>View</code>的时间分发机制, 并着重根据以下几种触屏事件来梳理思路, 加深理解:  </p>
<ol>
<li>点击事件(Click)分发  </li>
<li>按下事件/释放事件  </li>
<li>滑动事件  </li>
</ol>
<p>同时, 我们需要注意一个事件的处理周期, 即它分发的路径是怎样的, 是否会停止分发, 满足什么条件会停止分发.<br>对事件分发机制有充分理解, 那么各种按键事件响应处理和事件冲突问题, 就可以迎刃而解.<br>写这一节参考了网上的一些资料, 这里先做个说明, 本节不会以”消费”来表示事件处理函数返回<code>true</code>的情况, 纯粹因为我个人不喜欢这个词, 觉得表意不明确, 我认为方法的返回值只是表示”是否停止处理事件”, 而这个意思用”消费”来表示不太准确, 尽管源代码中用来表示这种情况的<code>Consume</code>通常确实被翻译为消费. 各位读者如果习惯这样称呼, 也并无不妥. 其他内容如有引用会在文中注明.<br>本节行文方式是先背景知识, 再总体流程图, 再贴源码详细解释.  </p>
<h3 id="事件产生"><a href="#事件产生" class="headerlink" title="事件产生"></a>事件产生</h3><p>触屏对操作系统提供硬件接口用以通知操作系统产生了什么事件, 操作系统通过硬件驱动读取和解析硬件接口的事件, 这个跟源码关系不大我们就不说了. 我们只说当事件被Android系统捕捉到之后, 传入Activity的时候是个什么形式, 没错, 就是<code>MotionEvent</code>. 硬件输入事件被<code>InputEvent</code>来描述, 该类是一个抽象类, 其有两个直接子类, 即<code>MotionEvent</code>和<code>KeyEvent</code>, 分别对应触屏事件和按键事件. 我们这里重点关注<code>MotionEvent</code>.<br>它在<code>frameworks/base/core/java/android/view/MotionEvent.java</code>中定义, 比较大, 注释也多, 我们只抽象地简单了解一下它刻画了触屏事件的哪些属性.<br>首先它定义了一系列ACTION常量来表示触屏事件, 例如我们下面会用到的<code>ACTION_DOWN</code> <code>ACTION_MOVE</code> <code>ACTION_UP</code>, 以及<code>ACTION_OUTSIDE</code> <code>ACTION_CANCEL</code> <code>ACTION_POINTER_DOWN</code> <code>ACTION_POINTER_UP</code> <code>ACTION_SCROLL</code>等.<br>其次它还定义了触屏事件的坐标属性包括偏移量等信息, 对应的处理和转换方法(@hide), 以及相应的Getter.<br>最后它定义了触屏事件的发生时间, 以及一系列<code>toString</code>方法.<br>这里面有很多方法都是native的, 而且也用到了aidl可见跟binder驱动估计也有关系. 如果今后有时间, 我会深入去看一下硬件到事件的过程, 今天先点到为止.<br>对<code>MotionEvent</code>本身感兴趣的同学可以去看看源码和官网的文档, 也可以在网上搜一下, 已经有很多人写过相关的博客.  </p>
<h3 id="事件分发和处理"><a href="#事件分发和处理" class="headerlink" title="事件分发和处理"></a>事件分发和处理</h3><p>事件产生之后(<code>MotionEvent</code>), 是怎么分发和处理呢? 我们先来看一张图:<br><img src="/images/blogs/view_event_dispatch.png" alt="事件分发总流程"><br>上图来自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>. 图中白色箭头代表事件流动的方向. 大体上来说一个全新的事件就是按照这个过程分发和分级处理的.<br>可见事件处理的主体主要分三个层级, 即<code>Activity</code> <code>ViewGroup</code> <code>View</code>, 你没看错, <code>Activity</code>这个浓眉大眼的家伙也可以处理<code>MotionEvent</code>.<br>网上常说”从上往下传递事件, 从下往上处理事件”, 其实默认是从”View树层次结构”的角度去说的, 而不是”View的显示层次”, 在”View树层次结构”这个角度上, <code>Activity</code>及其<code>DecorView</code>就是最上层, 逐层往下是<code>ViewGroup</code>和<code>View</code>, 这其实是一个<strong>深度优先搜索</strong>的过程, 对于一个确定的<code>MotionEvent</code>, 在这棵树上的路径也是确定的. 其实每一层都是先往下搜索看子节点是否处理完毕这个事件, 如果处理完毕了, <code>dispatchTouchEvent</code>就返回<code>true</code>, 否则本层调用<code>onTouchEvent</code>进行处理并返回处理结果.<br>所以我们可以猜测代码逻辑是这样:  </p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent e){
    View target;
    for (View child: children){
        target = child.getTouchTarget(e); // find event target
        if (target != null){
            break;
        }
    }
    if (target != null &amp;&amp; target.dispatchTouchEvent(e)){
        return true;
    }

    return onTouchEvent(e);
}
</code></pre><p>当然事实上远没有这么简单, 在<code>View</code>和<code>ViewGroup</code>中, 在实际分发和处理事件之前, 进行了一系列的逻辑处理(这里我就不贴源码了, 有兴趣的同学可以自行查看), 如: 在<code>ViewGroup</code>中, 判断当前是<code>DOWN</code>事件或者目标非空, 如果满足条件, 则设置一系列标记, 并判断该事件是否被自己拦截(<code>onInterceptTouchEvent</code>). 如果不满足条件, 即非<code>DOWN</code>事件且目标为空, 则直接标记该事件被拦截, 随后关键步骤是调用<code>dispatchTransformedTouchEvent</code>, 根据传入参数来决定是调用孩子节点的<code>onTouchEvent</code>还是调用<code>super.dispatchTouchEvent</code>(即<code>View.dispatchTouchEvent</code>, 这条路径会让自己的<code>onTouchListener</code>或<code>onTouchEvent</code>处理事件); 在<code>View</code>中, <code>DOWN</code>事件会让<code>View</code>停止滚动, 判断是否被<code>OnTouchListener</code>处理完毕(该步取代了<code>dispatchTouchEvent</code>, 原因显而易见), 如果没有则调用<code>OnTouchEvent</code>处理; 以上两者都会判断事件是否满足一致性校验, 是否满足安全性策略, 是否被取消.<br>与此相比, <code>Activity</code>中的事件处理就是一股清流, 它的代码非常简短, 几乎就跟我上面给出的差不多. 它先将<code>DOWN</code>事件交给<code>onUserInteraction</code>处理, 然后并不返回, 继续将该事件交给<code>getWindow().superDispatchTouchEvent</code>, 如果未被处理完毕则交给自身的<code>onTouchEvent</code>处理并返回.<br>神秘的就在于<code>superDispatchTouchEvent</code>了, 复习一下第一节的知识知道它八成是在<code>PhoneWindow</code>中定义的. 打开一看, 果不其然, 又被<code>mDecor</code>代理了…我们回忆一下, <code>DecorView</code>这个内部类是继承自<code>FrameLayout</code>的, 也就是说他是个<code>ViewGroup</code>, 好, 我们来看看这个类中<code>superDispatchTouchEvent</code>怎么定义的:  </p>
<pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {
            return super.dispatchTouchEvent(event);
}
</code></pre><p>直接丢给父类了, 人干事? 好在我们惊喜地发现这个方法是<code>public</code>的, 我们可以自己定义<code>Window.superDispatchTouchEvent</code>. 当然, 最惊喜的是<code>getWindow()</code>也是<code>public</code>的, 使得自定义<code>Window</code>并修改事件分发策略成为可能, 这个设计绝赞.  </p>
<p>现在我们已经大体知道了事件分发和处理的逻辑, 不清楚读者心中产生了什么新的疑问, 我有两个疑问: 1. 事件从何处传递给<code>Activity</code>(我们怎么确定顶层处理组件是<code>Activity</code>而不是其他什么东西?); 2. 事件何时终止传递, 连续事件(<code>DOWN-&gt;MOVE-&gt;UP</code>)有时候是要同一个<code>View</code>进行处理的, 例如滑动<code>ListView</code>, 如何保证这个过程?  </p>
<p>对于第一个问题, 我自己想想就觉得头大, 首先它肯定是硬件传递给我们操作系统再分发给某个服务(<code>ActivityManagerService</code>?)的, 这里面估计涉及到<code>Binder</code>通讯, 分析<code>Binder</code>原理的时候要了我半条命(感兴趣的同学可以在我博客里搜索到<code>Binder</code>原理解析的文章). 其次, 对于裸的驱动事件, 必然需要借助设备驱动将事件进行重新包装和定义, 这一步可能是<code>Android</code>提供接口, 设备驱动来完成, 也可能是<code>Android</code>系统自己来完成, 具体实现过程不太好找. 没办法, 有此疑问必然辗转反侧, 所以还是来看看吧. <code>Window.Callback</code>接口类定义了<code>dispatchTouchEvent</code>这个接口, 但是对于<code>Activity</code>来说哪个调用了它的这个方法, 我一点线索也没有. 回忆应用启动过程, 应该可以从<code>MotionEvent</code>的构造方法找到一点蛛丝马迹. 具体艰辛的过程我就不细述了, 总之最后终于发现了如下流程:<br><code>Linux</code>系统已经实现了对触屏事件的封装和传递, 硬件事件将会通过内核底层的硬件驱动进行处理, <code>Android</code>系统在此基础上进一步封装内核传递过来的触屏事件, 并根据事件的具体值, 依据硬件设备协议, 来初始化触屏事件<code>MotionEvent</code>.(回忆<code>adb sendevent</code>其实传输的就是触屏事件或按键事件)  </p>
<p>然后事件被包装成<code>QueuedInputEvent</code>, 并且由被设置了<code>Callback</code>的<code>Message</code>携带, 进入了主线程<code>ActivityThread</code>的消息队列, 处理时直接<code>handleCallback</code>调用了<code>Callback</code>, 而这个<code>Callback</code>是调用<code>ViewRootImpl.dispatchInputEvent</code>(接口来自<code>InputEventReceiver</code>)分发给了<code>ViewRootImpl</code>由<code>ViewRootImpl.onInputEvent</code>处理, 它才是真正意义上第一个处理触屏事件的类, 在该类中经过一系列处理后会传递到以下代码中:  </p>
<pre><code>private int processPointerEvent(QueuedInputEvent q) {
    ...
    final MotionEvent event = (MotionEvent)q.mEvent;
    final View eventTarget =
            (event.isFromSource(InputDevice.SOURCE_MOUSE) &amp;&amp; mCapturingView != null) ?
                    mCapturingView : mView;
    mAttachInfo.mHandlingPointerEvent = true;
    boolean handled = eventTarget.dispatchPointerEvent(event);
    ...
}
</code></pre><p>至于<code>mView</code>其实就是<code>DecorView</code>的实例, 是整个<code>View</code>树中最上层的可见元素, 见上文. 于是在这里调用了要么是<code>mCapturingView</code>要么是<code>mView</code>的<code>dispatchPointerEvent</code>, 而在<code>View.dispatchPointerEvent</code>的实现是, 如果它是<code>MotionEvent</code>, 则调用<code>dispatchTouchEvent</code>.<br>在<code>DecorView.dispatchTouchEvent</code>中, 如果有<code>Callback</code>调用<code>Callback.dispatchTouchEvent</code>, 否则调用<code>super.dispatchTouchEvent</code>. 这就厉害了, 这里对于<code>Activity</code>来说, 它是实现了<code>Callback</code>接口的, 也就是说这里如果传入的<code>Callback</code>是<code>Activity</code>实例, 那么就是直接调用<code>Activity.dispatchTouchEvent</code>了, 一切都解释得通了.<br>来梳理一下这一段的调用:  </p>
<pre><code>ActivityThread.mH.handleMessage(Message msg) -&gt;  
ActivityThread.mH.handleCallback(msg.callback)  
ViewRootImpl.dispatchInputEvent(q) -&gt;  
ViewRootImpl.onInputEvent(mEvent) -&gt;  
ViewRootImpl.processPointerEvent(q) -&gt;  
DecorView.dispatchPointerEvent(q.mEvent) -&gt;  
DecorView.dispatchTouchEvent -&gt;  
Activity.dispatchTouchEvent -&gt;  
Activity.getWindow().superDispatchTouchEvent -&gt;  
DecorView.superDispatchTouchEvent -&gt;  
FrameLayout.dispatchTouchEvent
</code></pre><p>可以看到最后好像是绕了个圈, 从<code>DecorView.dispatchTouchEvent</code>出发, 又回到<code>DecorView.super.dispatchTouchEvent</code>.  </p>
<p>对触屏事件的定义见代码<code>./bionic/libc/kernel/common/linux/input.h</code>.<br>触屏驱动见驱动代码目录<code>./kernel/goldfish/drivers/input/touchscreen/</code>.<br>事件封装见<code>./frameworks/base/services/input/EventHub.cpp</code>.  </p>
<p>(如果有兴趣, 可以沿这条路径查阅代码, 感受一下我的艰辛: <code>MotionEvent.obtain() -&gt; ./frameworks/base/services/input/EventHub.cpp</code> -&gt; 实在找不到触发点, 写了个Demo打印调用栈, 发现是异步调用, 事件被放进<code>ActivityThread</code>的<code>looper</code>中 -&gt; 我能怎么办, 我也很绝望啊, 事件从哪里放进looper中的? 沿着处理栈看看吧 -&gt; 惊喜发现)  </p>
<p>至此, 第一个疑问基本得到解答. 第二个疑问是, 事件何时终止传递, 对于连续事件如何处理? 事实上, 从以上代码可以看到, 当任意一层<code>dispatchTouchEvent</code>提前返回而无论自身还是父亲节点都不再调用下一层<code>dispatchTouchEvent</code>的时候, 就终止事件传递了, 具体来说就是<code>dispatchTouchEvent</code>在调用孩子节点的<code>dispatchTouchEvent</code>之前就返回了<code>true</code>(例如, 被拦截或者传递给<code>onTouchEvent</code>并返回<code>true</code>). 连续事件分两类, 一类是像<code>ACTION_MOVE</code>这样的, 由一系列连续的事件点构成的一个事件, 另一类就是像我上文提到的那种, 按下不放滑动手指.  </p>
<p>对于第一类, <code>Android</code>系统实际上将这种多次事件封装在了一个<code>MotionEvent</code>中, 并且用<code>ACTION_MOVE</code>这种标记来表示, 实际上我们手指触摸屏幕的时候, 很难达到仅有<code>ACTION_DOWN</code>-&gt;<code>ACTION_UP</code>, 中间多少都会夹几个<code>ACTION_MOVE</code>.  </p>
<p>对于第二类, 其实也很简单, 在<code>DOWN</code>事件发生时, “<strong>ACTION_DOWN在哪个View的onTouchEvent返回true，那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent 并结束本次事件传递过程… 如果ACTION_DOWN事件是在dispatchTouchEvent消费，那么事件到此为止停止传递，如果ACTION_DOWN事件是在onTouchEvent消费的，那么会把ACTION_MOVE或ACTION_UP事件传给该控件的onTouchEvent处理并结束传递。</strong>“(以上引用自<a href="http://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="external">图解 Android 事件分发机制</a>).<br>现象好像确实如此, 但是代码是怎么做到的呢? 带着好奇我重新看了<code>ViewGroup</code>和<code>View</code>的事件分发, 发现了实现方法. 对于<code>View</code>, 如果在<code>dispatchTouchEvent</code>时调用了默认的<code>onTouchEvent</code>, 并且它是可点击的, 那么<code>DOWN</code> <code>UP</code> <code>MOVE</code> <code>CANCEL</code>四个事件会进入该函数的<code>switch</code>, <code>switch</code>之后必然返回<code>true</code>, 即触屏事件被处理完毕. 由于<code>View</code>本来就是事件分发的最底层, 所以它并没有显示后续事件拦截是如何实现的. 对于<code>ViewGroup</code>, 由于它并没有重写<code>onTouchEvent</code>方法, 故所有事件如果传递到了<code>onTouchEvent</code>则必然也是走<code>View</code>的方法. 在<code>dispatchTouchEvent</code>过程中, 特殊处理<code>DOWN</code>事件, 此时会清除掉内部保存的<code>target</code>链表, 并遍历一个有序的<code>View[] children</code>数组(按绘制先后顺序排序), 对于每一个孩子节点, 在<code>target</code>链表中寻找是否存在它对应的<code>target</code>, 如果存在则循环结束跳出, 否则对这个孩子调用<code>dispatchTransformedTouchEvent</code>, 并在返回<code>true</code>时构造这个孩子的<code>target</code>并插入到链表头部, 然后结束循环, 以上内容都是仅在<code>DOWN</code>事件时发生. 这就意味着, 如果一个<code>child</code>在<code>DOWN</code>事件时<code>dispatchTransformedTouchEvent</code>返回<code>true</code>了, 那么它在链表中就应该存在对应的<code>target</code>. 用<code>newTouchTarget</code>这个变量来暂时存储, 而且这个<code>target</code>应该在链表靠头部的位置. 如果<code>newTouchTarget</code>为空(意味着<code>dispatchTransformedTouchEvent</code>返回<code>false</code>)但<code>target</code>链表不为空(意味着本<code>ViewGroup</code>中已经有一组<code>target</code>等待接收事件), 则<code>newTouchTarget</code>存储链表尾节点. 循环结束后, 根据<code>target</code>链表继续处理事件, 如果<code>target</code>链表为空说明本<code>ViewGroup</code>的孩子节点没有曾经将事件处理完毕过(一旦有过, 就会被链表保存)或者本次事件是<code>DOWN</code>事件但被取消或拦截了, 那么调用<code>View.dispatchTouchEvent</code>继续处理事件, 而该方法默认是调用自身的<code>onTouchEvent</code>. 如果<code>target</code>链表不为空, 遍历<code>target</code>链表把事件传给对应的<code>View</code>进行处理(划重点!!<strong>事件如果被标记为取消或者拦截, 则不继续传递给孩子节点, 事件要么由自身<code>onTouchEvent</code>处理, 要么传递给已经在target列表中的节点处理; 事件不被取消也不被拦截的情况下, 如果孩子节点有一个返回true, 则以后的非DOWN事件也只交给target列表中的节点处理, 不再继续传递给其他孩子; target列表中的节点则是调用其dispatchTouchEvent方法继续传递和处理事件</strong>), 有任意一个处理完毕则都标记本<code>ViewGroup</code>已处理完毕该事件(但是不会中断遍历). 在该过程中如果有<code>View</code>标记为下次<code>UP</code>事件时取消, 则同时从链表中删除并回收该<code>target</code>.  </p>
<p>小结一下, 借助<code>target</code>链表, <code>ViewGroup</code>记录了处理<code>DOWN</code>事件的<code>View</code>集合, 并在下次其他事件传入时仅传给这个链表中的<code>View</code>, 这就实现了对连续事件的处理. 而且对于<code>View</code>的<code>onTouchEvent</code>默认实现来说, 四种事件均会返回<code>true</code>, 即<code>View</code>本身默认就是会拦截事件的.  </p>
<h3 id="事件冲突"><a href="#事件冲突" class="headerlink" title="事件冲突"></a>事件冲突</h3><p>仔细理解了上一节的内容之后, 就不难预见事件冲突这种情况发生的原因以及解决方案了.<br>总的来说, 事件冲突的原因就是意料之外的<code>View</code>或者<code>ViewGroup</code>把事件拦截了, 从而我们想用来处理事件的<code>View</code>或者<code>ViewGroup</code>无法接收到事件.  </p>
<p>典型的, <code>ScrollView</code>中嵌套<code>ListView</code>, 冲突产生的原因是<code>ScrollView</code>在滑动拖拽的过程中会让<code>onInterceptTouchEvent</code>返回<code>true</code>, 直接导致<code>ScrollView</code>拦截事件, 不会被传递到深一层的<code>ListView</code>(其他<code>View</code>也一样). 解决方案也很简单, 就是重写<code>ScrollView</code>的<code>onInterceptTouchEvent</code>, 告诉<code>ScrollView</code>哪些情况该拦截, 哪些情况不该拦截. 如果不能修改这个拦截事件的<code>View</code>怎么办呢? 也好办, 从自己可控的<code>ViewGroup</code>出发, 调用<code>requestDisallowInterceptTouchEvent</code>要求该<code>ViewGroup</code>及其祖先节点不拦截事件, 再视情况恢复这个标记位.<br>可以看出, 了解了<code>Android</code>系统各个层次对事件的分发处理和返回的策略之后, 遇到任何事件冲突问题我们都能够很容易找到症结所在并给出解决方案.  </p>
<p>对于嵌套滑动, <code>View</code>定义了一个接口<code>dispatchNestedScroll</code>用来传递嵌套滑动事件. 今后有空我将会继续研读这一块的设计.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲View
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】SharedPreference详解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DSharedPreference%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/23/[Android教程]SharedPreference详解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-05-04T10:29:27.359Z</updated>
    
    <content type="html"><![CDATA[<p>Android为各位开发者提供了简单的数据存储和交换的方式, 就是<code>SharedPreference</code>, 它是一个在应用数据目录下的<code>.xml</code>文件, 无论是从名字还是实际应用来看, 它都是存取轻量不涉及安全问题的数据(例如设置项)的趁手方式之一. 当然, 它采用xml这样的格式有其自己的考虑, 但未必是最合适的. 当然它的缺点也跟优点一样明显, 今天我们就来看看它在源码中是怎样实现的, 由此也可看出它的优缺点何在.<br>老方法, 我们从实际使用场景来倒推.<br>本文结构:  </p>
<ol>
<li>SharedPreference实现  </li>
<li>SharedPreference优缺点  </li>
</ol>
<h2 id="SharedPreference实现"><a href="#SharedPreference实现" class="headerlink" title="SharedPreference实现"></a>SharedPreference实现</h2><p>一个简单的读写场景通常用到<code>getSharedPreferences</code>接口, 和<code>SharedPreferences.Editor</code>. 例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// TextView ttvv has been initiated before</div><div class="line">SharedPreferences sp = getSharedPreferences(&quot;Test&quot;, MODE_PRIVATE);</div><div class="line">sp.edit().putBoolean(&quot;Another test key&quot;, true).commit();</div><div class="line">Map&lt;String, ?&gt; content = sp.getAll();</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">for(String key : content.keySet())&#123;</div><div class="line">    sb.append(String.format(&quot;%s=%s\n&quot;, key, content.get(key).toString()));</div><div class="line">&#125;</div><div class="line">ttvv.setText(&quot;SharedPreference测试:\n &quot;);</div><div class="line">ttvv.append(sb.toString());</div></pre></td></tr></table></figure></p>
<p>首先追踪<code>getSharedPreferences</code>发现它调用的是<code>ContextWrapper.mBase.getSharedPreferences</code>, <code>mBase</code>这个东西我在另一篇分析<code>Context</code>的博客中讲过, 这里不赘述, 我们直接看它的实现, 发现它返回的是一个<code>SharedPreferencesImpl</code>实例, 其首先在静态成员变量<code>sSharedPrefs</code>中获取以传入的参数<code>name</code>为key的实例, 如果没有则在一个固定目录<code>getPreferencesDir()</code>(默认是<code>shared_prefs</code>)以传入的参数(name)创建一个新的<code>SharedPreference</code>文件<code>name.xml</code>(默认实现中, name不能包含路径分隔符), 然后以(name, mode)创建一个<code>SharedPreferencesImpl</code>实例. 第一个参数很好理解, 就是SharedPreference文件的文件名, 第二个参数指的是文件创建模式, 可选的值在<code>Context</code>抽象类中有定义, 主要是<code>MODE_PRIVATE</code>(默认文件打开方式就是这个, 即仅有创建者所在的应用或共享该应用User ID的其他应用有访问权限) <code>MODE_WORLD_READABLE</code>等常量, 在<code>SharedPreference</code>写的时候会根据创建模式判断是否有写权限.<br><code>SharedPreferencesImpl</code>构造方法中, 开启了一个线程从文件系统中载入指定名称的<code>SharedPreference</code>文件(构造方法中会先备份文件, 载入时如果存在备份文件, 先删除当前文件, 再从备份文件恢复), 并解析成Map存在成员变量<code>mMap</code>中. 可见, 我们实际获得的就是一个普通的xml文件解析成的<code>HashMap</code>.<br>以上, 我们知道了一个<code>SharedPreference</code>文件的创建和读取. 至于<code>edit()</code>接口返回的<code>Editor</code>接口很好理解, 它就是提供了对<code>SharedPreference</code>文件操作的封装, 它的默认实现是<code>SharedPreferencesImpl.EditorImpl</code>, 基本上就是同步地读写<code>mModified</code>成员变量, 它是<code>Maps.newHashMap</code>创建的实例, 它只存储有更改的键值对. 这里我们需要重点关注Editor两个地方的实现<code>boolean commit()</code>和<code>void apply()</code>.<br>相信用过<code>SharedPreference</code>的同学都知道, 这两个接口都是用来提交变化到文件的, 但具体提交过程可能不是人人都清楚. 我们先来看两个接口的说明, 通常源码里面会有重要信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call commit wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;If you don&apos;t care about the return value and you&apos;re</div><div class="line"> * using this from your application&apos;s main thread, consider</div><div class="line"> * using &#123;@link #apply&#125; instead.</div><div class="line"> *</div><div class="line"> * @return Returns true if the new values were successfully written</div><div class="line"> * to persistent storage.</div><div class="line"> */</div><div class="line">boolean commit();</div><div class="line"></div><div class="line">/**</div><div class="line"> * Commit your preferences changes back from this Editor to the</div><div class="line"> * &#123;@link SharedPreferences&#125; object it is editing.  This atomically</div><div class="line"> * performs the requested modifications, replacing whatever is currently</div><div class="line"> * in the SharedPreferences.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Note that when two editors are modifying preferences at the same</div><div class="line"> * time, the last one to call apply wins.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Unlike &#123;@link #commit&#125;, which writes its preferences out</div><div class="line"> * to persistent storage synchronously, &#123;@link #apply&#125;</div><div class="line"> * commits its changes to the in-memory</div><div class="line"> * &#123;@link SharedPreferences&#125; immediately but starts an</div><div class="line"> * asynchronous commit to disk and you won&apos;t be notified of</div><div class="line"> * any failures.  If another editor on this</div><div class="line"> * &#123;@link SharedPreferences&#125; does a regular &#123;@link #commit&#125;</div><div class="line"> * while a &#123;@link #apply&#125; is still outstanding, the</div><div class="line"> * &#123;@link #commit&#125; will block until all async commits are</div><div class="line"> * completed as well as the commit itself.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;As &#123;@link SharedPreferences&#125; instances are singletons within</div><div class="line"> * a process, it&apos;s safe to replace any instance of &#123;@link #commit&#125; with</div><div class="line"> * &#123;@link #apply&#125; if you were already ignoring the return value.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;You don&apos;t need to worry about Android component</div><div class="line"> * lifecycles and their interaction with &lt;code&gt;apply()&lt;/code&gt;</div><div class="line"> * writing to disk.  The framework makes sure in-flight disk</div><div class="line"> * writes from &lt;code&gt;apply()&lt;/code&gt; complete before switching</div><div class="line"> * states.</div><div class="line"> *</div><div class="line"> * &lt;p class=&apos;note&apos;&gt;The SharedPreferences.Editor interface</div><div class="line"> * isn&apos;t expected to be implemented directly.  However, if you</div><div class="line"> * previously did implement it and are now getting errors</div><div class="line"> * about missing &lt;code&gt;apply()&lt;/code&gt;, you can simply call</div><div class="line"> * &#123;@link #commit&#125; from &lt;code&gt;apply()&lt;/code&gt;.</div><div class="line"> */</div><div class="line">void apply();</div></pre></td></tr></table></figure></p>
<p>果不其然, 接口注释中有重要提示. 首先对于<code>commit</code>接口, 源码注释给出了三个信息: 1. 返回值表示是否成功写入到存储器; 2. 两个Editor竞争时, 后调用commit的Editor最终生效; 3. 它<code>原子地</code>写入新值, 如果不关心返回值, 而且是在主线程中调用, 应该考虑<code>apply</code>接口. 第1点和第3点预示着commit方法是同步写入, 可能效率会比较低, 在主线程中调用会引起响应变慢, 同时暗示着<code>apply</code>可能是异步写入. 再来看<code>apply</code> 接口, 源码注释给出了三个信息: 1. commit是同步写入外存, 而apply是先写到内存, 再异步写入到外存, 并且不会给出失败通知; 2. 对于同一个<code>SharedPreference</code>, 如果一个apply在等待时, 另一个editor调用了一个commit, 那么这个commit会被阻塞直到所有异步提交以及这个commit本身完成为止; 3. 它<code>原子地</code>写入新值, 在<code>SharedPreference</code>本身是单例实现的情况下(现在默认情况就是), 将所有的<code>commit</code>替换成<code>apply</code>是安全的, Android Framework保证在改变状态前完成已入队的apply操作, 所以你也不用担心组件生命周期会影响apply.<br>可见二者的最主要区别就是, commit是同步地, apply是异步的. 那么它们写入<code>SharedPreference</code>时候, 是具体怎么写入的呢? 这就要看<code>SharedPreferencesImpl.EditorImpl</code>的实现了.<br>先看<code>EditorImpl.commit()</code>, 它首先调用<code>commitToMemory</code>提交到内存, 然后调用<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把提交结果<code>MemoryCommitResult</code>入队, 再调用<code>MemoryCommitResult.writtenToDiskLatch.await()</code>阻塞直到<code>MemoryCommitResult.setDiskWriteResult</code>被调用, 即该结果已经被处理. 到这里我们知道写入工作分两步, 先写入到内存, 再写入到外存. 稍后我们分别来看这两步具体内容, 这里先看<code>EditorImpl.apply()</code>的实现. 它首先调用<code>commitToMemory</code>提交到内存, 然后新建了一个<code>Runnable awaitCommit</code>内容是<code>MemoryCommitResult.writtenToDiskLatch.await()</code>, 所以这个<code>Runnable</code>中会阻塞直到结果被处理. 然后它把这个<code>Runnable</code>加入到了<code>QueuedWork</code>中, 并且再新建了一个<code>Runnable postWriteRunnable</code>, 里面调用<code>awaitCommit.run()</code>, 并从<code>QueueWork</code>中移除<code>awaitCommit</code>. 最后, 它通过<code>SharedPreferencesImpl.this.enqueueDiskWrite</code>把这个<code>postWriteRunnable</code>入队. 可见, 它是一个异步的提交过程. 以上两个方法的具体实现, 也解释了apply和commit冲突时commit将会阻塞直到所有的apply完成的原因: commit会等待直到自己的提交被执行, 而它之前调用的apply在队列中会先于它处理.<br>现在清楚了提交过程, 来看Editor的数据是如何写入到内存的.<br>在<code>commitToMemory</code>中, 首先实例化了一个<code>MemoryCommitResult mcr</code>, 并让它保存了一个<code>mMap</code>的引用在<code>mapToWriteToDisk</code>成员中. 存在监听器时, 初始化它的<code>keysModified</code>和<code>listeners</code>成员, 并在后面把变化了的键放到<code>keysModified</code>中. 然后遍历<code>mModified</code>, 将新的值写入到<code>mMap</code>中, 或者从<code>mMap</code>中移除预定要移除的值, 最后清空<code>mModified</code>并返回<code>mcr</code>. 简单来说, 它把变化的内容复制到了<code>mMap</code>这个原始内容中.<br>最后, 来看被加入到队列中的<code>MemoryCommitResult</code>是如何被处理的. 先把源码放上方便各位对照:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                              final Runnable postWriteRunnable) &#123;</div><div class="line">    final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (mWritingToDiskLock) &#123;</div><div class="line">                    writeToFile(mcr);</div><div class="line">                &#125;</div><div class="line">                synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                if (postWriteRunnable != null) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    final boolean isFromSyncCommit = (postWriteRunnable == null);</div><div class="line"></div><div class="line">    // Typical #commit() path with fewer allocations, doing a write on</div><div class="line">    // the current thread.</div><div class="line">    if (isFromSyncCommit) &#123;</div><div class="line">        boolean wasEmpty = false;</div><div class="line">        synchronized (SharedPreferencesImpl.this) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">        &#125;</div><div class="line">        if (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看<code>enqueueDiskWrite</code>函数, 发现它先定义了一个<code>Runnable writeToDiskRunnable</code>, 内容是同步地调用<code>writeToFile(mcr)</code>, 递减<code>mDiskWritesInFlight</code>计数(该计数在调用<code>commitToMemory</code>时递增), 调用<code>postWriteRunnable.run</code>. 然后判断是否commit, 判断的方法也是非常暴力: <code>postWriteRunnable == null</code>就是同步commit. 此时先判断当前是否只有自己一个任务在执行, 是的话直接在当前线程上调用<code>writeToDiskRunnable.run</code>然后返回, 否则调用<code>QueueWork.singleThreadExecutor().execute(writeToDiskRunnable)</code>来执行. 我另一篇讲Java并发的博客讲过<code>singleThreadExecutor</code>是什么鬼. 显然, 无论是commit还是apply, 最后都是在用一个单线程池在跑, 跑的内容主要就是<code>writeToFile</code>. 在<code>QueueWork</code>中, 添加的任务都在<code>ConcurrentLinkedQueue sPendingWorkFinishers</code>队列中, 这里我们不再讲该队列的处理.<br>查看<code>writeToFile</code>的实现, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// Note: must hold mWritingToDiskLock</div><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mcr.changesMade) &#123;</div><div class="line">            // If the file already exists, but no changes were</div><div class="line">            // made to the underlying map, it&apos;s wasteful to</div><div class="line">            // re-write the file.  Return as if we wrote it</div><div class="line">            // out.</div><div class="line">            mcr.setDiskWriteResult(true);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mBackupFile.exists()) &#123;</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, &quot;Couldn&apos;t rename file &quot; + mFile</div><div class="line">                      + &quot; to backup file &quot; + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        if (str == null) &#123;</div><div class="line">            mcr.setDiskWriteResult(false);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        FileStatus stat = new FileStatus();</div><div class="line">        if (FileUtils.getFileStatus(mFile.getPath(), stat)) &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                mStatTimestamp = stat.mtime;</div><div class="line">                mStatSize = stat.size;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125; // catch exceptions</div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, &quot;Couldn&apos;t clean up partially-written file &quot; + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码放在博客里有一丢丢长, 但是除了log以外我都没舍得删, 因为我觉得写得很美, 尤其是虽然代码不多但注释不少. 该函数首先判断是否有改变, 没有改变就返回了, 然后判断备份文件是否存在, 不存在则把当前文件作为备份文件. 备份好了后在原文件位置创建新的文件来操作, 把整个<code>mcr.mapToWriteToDisk</code>写入到新文件中, 一切顺利的情况下, 更新<code>SharedPreferencesImpl</code>文件状态信息, 删除备份文件, 并设置写入结果为true, 然后返回. 一旦出错, 就会执行到后面的扫尾代码, 此时将新文件删除, 并设置写入结果为false. 注释里面有一个小提示, <code>Attempt to write the file, delete the backup and return true as atomically as possible</code>, 也就是说这个写入过程可能不是原子的, 只是实现上尽量保证原子而已.<br>至此, <code>SharedPreference</code>的实现原理我们已经大致了解.  </p>
<h2 id="SharedPreference优缺点"><a href="#SharedPreference优缺点" class="headerlink" title="SharedPreference优缺点"></a>SharedPreference优缺点</h2><p><code>SharedPreference</code>的优点是显而易见的: 系统实现, 拿来即可用; 接口定义清晰, 容易使用; 采用Map数据结构实现, 可以存储对象; 在Application中全局可见, 并且全局单例.<br>同时它的缺点也是很明显:  </p>
<ol>
<li>从第一节的分析可以看出, 每次有变化时, 系统默认是将整个<code>SharedPreference</code>文件备份, 写入新文件, 再删除备份文件. 这就意味着<code>SharedPreference</code>不适合存储大量内容, 也不适合对内容改动很少但很频繁的场景, 否则会因为文件读写而存在性能瓶颈. 前者是天然限制, 而后者可以通过尽量少调用commit和apply来规避;  </li>
<li>apply中混用commit可能导致效率降低. 原因在上面分析中讲过, commit会等待前面所有的apply完成, 也就意味着无论前面用了多少次apply, 一旦后面跟着一个commit, 对于commit所在的线程来说, apply的优势就荡然无存了.<br>另外, 由于该文件是通过应用创建的, 所以可以直接在应用数据目录下看到文件内容, 安全性不能保证, 不过这就不在本文讨论范围之内了.  </li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>分析了这些, 对于我们有什么用呢? 虽然我很讨厌什么都用”有没有用”来衡量, 但不写个结论确实也感觉文章虎头蛇尾. <code>SharedPreference</code>源码分析至少给我们几点启示:  </p>
<ol>
<li>注意<code>SharedPreference</code>的使用场景, 尽量规避它所不擅长的情景. 使用时如果对实时性和写入结果要求不高, 尽量只使用<code>apply</code>提交改动.  </li>
<li>完全可以仿照源码自行实现<code>SharedPreference</code>读写接口. 一个应用显然可以有多个<code>SharedPreference</code>文件, 将强耦合的内容分别聚拢到各自的<code>SharedPreference</code>文件中, 理论上可以提高读写效率, 如果有更高效的<code>SharedPreference</code>内容管理方式, 可以完全抛开系统实现, 自行管理<code>SharedPreference</code>文件.  </li>
<li><code>SharedPreference</code>的访问权限是创建时决定的, 依赖于文件创建模式参数, 不一定只有本应用可以访问.  </li>
<li>它一点也不神秘, 甚至在Android系统架构中地位也不太重要, 任何时候它被别的方式取代我也不会吃惊, 但它的实现代码, 透露着一种简洁的优雅.  </li>
</ol>
<p>本篇博客没有参考文献, 唯一参考来源是Android 4.0源码及其注释, 当然自己写来验证想法的Demo不算.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲SharedPreference共享设置
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Context全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/23/%5BAndroid%E6%95%99%E7%A8%8B%5DContext%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/23/[Android教程]Context全解/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2017-05-04T10:31:21.711Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中会遇到很多场景需要Context, 包括但不限于: 获取资源, 创建View, 显示UI元素… 稍微追踪一下知道Context是一个接口, 当然从名字知道它是提供环境信息的接口, 今天我们就来看看, Context以及它的衍生类.  </p>
<h2 id="Context接口和作用"><a href="#Context接口和作用" class="headerlink" title="Context接口和作用"></a>Context接口和作用</h2><p>位于<code>frameworks/base/core/java/android/content/Context.java</code>, 是一个抽象类, 它定义了所有可用的接口, 在AS中查看它的类继承关系, 可以发现它有<code>MockContext</code>和<code>ContextWrapper</code>两个直接子类, 继续追下去会发现它有数量不少的间接子类, <code>Application</code> <code>Activity</code> <code>Service</code>都是它的子类, 这也正是在这些类中用到Context参数时可以直接传<code>this</code>的原因. 我们来看Context定义了哪些接口, 接口及其说明在官网Context页都有说明, 我这里只是相当于翻译一下. 大致上可以分为两类:  </p>
<ol>
<li><p>全局信息资源接口及其配套常量. 包括但不限于以下接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">getResources 返回Resources实例, 提供应用包的资源管理接口.  </div><div class="line">getAssets 返回AssetManager实例, 它提供资源管理接口. 它管理的资源应当和getResources管理的资源保持一致, 即它们维护同一套资源.  </div><div class="line">getPackageManager 返回PackageManager实例, 提供全局包信息.  </div><div class="line">getContentResolver 返回ContentResolver实例, 提供内容解析接口.  </div><div class="line">getText 封装Resources.getText  </div><div class="line">getString 封装Resources.getString</div><div class="line">getClassLoader 获取ClassLoader实例, 可以由此获取包内所有类</div><div class="line">getPackageName 获取应用包的包名  </div><div class="line">getSystemService 获取系统服务, 系统服务的名字以常量形式存在Context类中</div></pre></td></tr></table></figure>
</li>
<li><p>公共方法及其配套常量. 包括但不限于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getMainLooper 返回当前Context的Looper实例  </div><div class="line">getApplicationContext 获取应用的Context实例, 它不同于当前Context实例, 而是一个属于当前进程的, 全局的, 单例的, Application对象, 这意味着它的生命周期不同于当前Context, 而是跟当前进程捆绑  </div><div class="line">registerComponentCallbacks 注册组件回调  </div><div class="line">unregisterComponentCallbacks 注销组件回调  </div><div class="line">deleteFile 删除与当前应用包关联的私有文件  </div><div class="line">deleteDatabase 删除与当前应用包关联的私有SQLiteDatabase数据库  </div><div class="line">startActivity 开始一个Activity  </div><div class="line">registerReceiver 注册广播接收器  </div><div class="line">unregisterReceiver 注销广播接收器</div><div class="line">bindService 绑定服务  </div><div class="line">unbindService 解绑服务  </div><div class="line">startService 开始服务  </div><div class="line">stopService 停止服务  </div><div class="line">createPackageContext 以给定应用包名创建该应用的Context</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Context默认实现"><a href="#Context默认实现" class="headerlink" title="Context默认实现"></a>Context默认实现</h2><p><img src="./images/blogs/context.png" alt="context关系"><br>前文说了, <code>Activity</code>和<code>Application</code>都是<code>Context</code>的间接子类. 但是他们处于不同层级, 拥有不同的继承链, <code>Application</code>继承了<code>ContextWrapper</code>(<code>Service</code>也继承了它), 而<code>Activity</code>继承了<code>ContextThemeWrapper</code>(它是<code>ContextWrapper</code>的直接子类). 在<code>ContextWrapper</code>中提供了大多数方法的默认实现, 正如其名, 它只是包装了一个<code>Context</code>实现, 这个实现就是它的<code>mBase</code>成员变量, 是通过构造函数或者<code>attachBaseContext</code>传入的<code>Context</code>实例. 在应用启动过程中, <code>performLaunchActivity</code>会将一个<code>ContextImpl</code>实例作为参数传入<code>Activity.attach</code>方法, 该方法就用这个实例调用<code>attachBaseContext</code>设置好<code>Context</code>. 换句话说, <code>Activity</code>所拥有的<code>Context</code>就是一个随<code>Activity</code>生命周期的<code>ContextImpl</code>实例, <code>Activity</code>中对<code>Context</code>接口的调用, 中途经过<code>ContextThemeWrapper</code>和<code>ContextWrapper</code>, 最终到达这个<code>mBase</code>指向的<code>ContextImpl</code>的相应接口调用. 也就是说, 它就是我们要找的Activity Context默认实现.<br>那么Application Context呢? 它调用Context接口时最终同样会传达到mBase上, 它的mBase对象又是什么呢? 我们考察应用启动过程, 发现在<code>performLaunchActivity</code>中, 有一步是<code>makeApplication</code>, 返回一个<code>Application</code>对象. 该方法属于<code>LoadedApk</code>类, 打开该类查看, 发现它维护了一个<code>Application mApplication</code>成员变量, <code>makeApplication</code>方法在该变量非空时直接返回该变量(意味着无论调用多少次, 都返回同一个Application实例), 否则新建一个<code>ContextImpl</code>对象, 并以它为参数之一, 调用<code>mActivityThread.mInstrumentation.newApplication</code>返回一个<code>Application</code>对象. 再查看<code>newApplication</code>方法, 它位于<code>frameworks/base/core/java/android/app/Instrumentation.java</code>中, 其行为是使用给定的<code>ClassLoader</code>先装载给定的类(这里是<code>LoadedApk.makeApplication</code>中字符串<code>appClass</code>代表的<code>Application</code>类, 如果没有指定或强制使用默认appClass, 则该值为”android.app.Application”), 再用该类对象的<code>newInstance</code>创建实例并调用<code>attach</code>方法绑定Context实例. 可见, <code>Application</code>的Context仍然是<code>ContextImpl</code>实例, 不同的是它的生命周期与<code>Application</code>一致.<br><code>ContextImpl</code>类中对Context大多数接口方法都有了默认实现, 我们重点只看<code>getApplicationContext</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// in file ContextImpl.java</div><div class="line"></div><div class="line">@Override</div><div class="line">public Context getApplicationContext() &#123;</div><div class="line">    return (mPackageInfo != null) ?</div><div class="line">            mPackageInfo.getApplication() : mMainThread.getApplication();</div><div class="line">&#125;// mPackageInfo是LoadedApk类型</div></pre></td></tr></table></figure></p>
<p>方法<code>Activity.getApplication</code>返回的是成员变量<code>mApplication</code>, 根据其构造过程, 是在<code>attach</code>时赋值的<code>Application</code>实例, 换句话说, 在同一个应用中时, <code>Activity</code>中调用<code>getApplication</code>跟调用<code>getApplicationContext</code>返回的是同一个对象, 这可以很方便地验证.  </p>
<h2 id="Context使用中需要注意的问题"><a href="#Context使用中需要注意的问题" class="headerlink" title="Context使用中需要注意的问题"></a>Context使用中需要注意的问题</h2><p>前文中我们曾特地指出, <code>Activity</code>的Context跟<code>Application</code>的Context生命周期不同, 细心的同学可能要问了, 强调这个是因为有什么坑吗? 是的, 这里有坑.<br>原因就在于我们在创建组件的时候经常会用到Context这个参数, 有时为了图方便就直接传<code>this</code>, 大多数情况下也挺好使, 但其实这里存在很大的内存泄漏风险.<br>举个例子, 我们假设在<code>Activity</code>中创建了一个<code>Bitmap</code>, 为了在手机横竖屏切换的时候不至于重新装载这个资源, 我们将它写成<code>static</code>, 这样它的生命周期也就跟<code>Activity.class</code>相同了. 然后我们通过<code>setBackgroundDrawable</code>将它设置成了某个<code>View</code>(该<code>View</code>是通过<code>new View(this)</code>方法构造的实例)的背景. 我们知道, 在手机横竖屏切换的时候, 当前Activity会被销毁再重新创建, 因此此间会有一个gc标记过程. 这里存在什么问题呢? <code>setBackgroundDrawable</code>之后, 静态变量<code>Bitmap</code>会持有一个该<code>View</code>的引用, 而这个<code>View</code>持有一个<code>Activity</code>的引用, 这就导致<code>Activity</code>的引用计数不为0, gc过程无法回收该对象内存, 但是该对象已经不被任何过程使用, 于是就泄露了. 归根到底是因为创建<code>View</code>的时候使用了<code>Activity</code>作为Context, 但是该<code>View</code>由于存在被静态变量<code>Bitmap</code>引用的情况, 其实际生命周期要长于<code>Activity</code>.<br>解决这种泄露的方法是, 保证在<code>Activity</code>中使用<code>Activity</code>或<code>this</code>作为Context的任何对象, 其生命周期都不长于<code>Activity</code>本身, 否则应该考虑使用<code>Application Context</code>.<br>另外, 如果定义了非静态内部类, 那么对非静态内部类实例的引用也有可能导致外部类实例内存泄漏, 解决这种内存泄漏的方法是控制内部类的引用, 对于生命周期长于外部类的内部类, 应定义为静态内部类.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Android中的Context
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Binder全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/10/%5BAndroid%E6%95%99%E7%A8%8B%5DBinder%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/10/[Android教程]Binder全解/</id>
    <published>2017-01-09T16:00:00.000Z</published>
    <updated>2017-05-04T10:31:43.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回-hu-顾-zhou"><a href="#某渣的凭印象回-hu-顾-zhou" class="headerlink" title="某渣的凭印象回(hu)顾(zhou)"></a>某渣的凭印象回(hu)顾(zhou)</h2><p>Binder是Android提供的一种RPC机制, 它是C/S架构, 可以远程调用服务, 调用其他进程甚至其他App的服务. 它利用AIDL描述服务接口, 通过bind和unbind绑定和解绑具体服务, 其内部使用代理完成服务功能的调用. 调用方需要知道AIDL, 被调用方需要实现AIDL. Android系统的服务就是通过Binder机制来使用的.  </p>
<h2 id="Binder的设计思想-工作原理"><a href="#Binder的设计思想-工作原理" class="headerlink" title="Binder的设计思想/工作原理"></a>Binder的设计思想/工作原理</h2><p>Binder是一种进程间通讯的机制, 不同于Handler的线程间通讯, 由于进程间没有共享区域, 所以Handler那种消息队列的机制在进程之间进行就会变得比较麻烦(进程A将消息拷贝到内核缓存空间, 另一进程B从内核缓存空间取消息), 特别是当进程间通讯涉及到接口调用等业务流程时. 出于安全性考虑, 一个进程的空间只对进程内部开放, 外部想要访问进程内的数据, 就只能曲线救国. Binder就是其中一种方式.  </p>
<p>Binder是一种特化的AIDL服务, 换句话说, AIDL是对Binder机制的上层封装, 它可以快速实现进程间通讯, 所以要想理解Binder就必须理解AIDL. 关于AIDL可以看我的博文<a href="http://hjhjw1991.github.io/android/2016/04/01/[Android%E6%95%99%E7%A8%8B]AIDL%E5%85%A5%E9%97%A8/">AIDL入门</a>, 简单来说, AIDL是服务的接口描述文件, 它在服务端和客户端都共同存在且内容相同, SDK的aidl工具可以帮助我们把<code>.aidl</code>文件转换成同名的<code>.java</code>文件, 只要我们手工调用该工具转换一下, 并看一看转换后的文件, 我相信就能够完全理解aidl的使用原理了(其实跟Hessian之类的RPC框架大同小异). 具体到Binder, 我们可以去看看Binder的实现源码和Binder驱动的源码, 说白了就是系统为我们实现了一套基于Binder接口的获取/绑定/解绑/释放服务代理的业务逻辑, 我们只需要负责将具体的服务传给Binder就可以了. 如果没有Binder, 进行进程间通讯就必须要自己实现基于AIDL的业务逻辑, 实际上这样也是行得通的, 只不过系统服务都是基于Binder实现的, 所以我们有必要了解Binder的实现原理.<br>在最下层, Binder驱动通过Native代码实现, 它是Binder接口的最终实现, 关于Binder驱动的源码可以看这篇博客<a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>, 尤其是其代码注释.  </p>
<p>在Linux中有很多进程间通讯的方式, 为什么Android唯独自己实现了一个Binder机制? 我认为主要原因是现有的Linux进程间通讯方式都太”重”了, 含有许多虽然好但是在Android环境下并不实用的特性. 可以明确的是, 现有的进程间通讯方式肯定可以应用在Android这个基于Linux系统内核的操作系统上. 相比之下, Binder的设计使得它只进行一次数据拷贝, 传输更加高效, 而且发送方和接收方都互相知道对方身份, 更加安全.  </p>
<h2 id="Binder实践"><a href="#Binder实践" class="headerlink" title="Binder实践"></a>Binder实践</h2><p>依旧, 如果只想用Binder, 那直接继承它并实现相应接口即可, 这里的实践指的是看Binder源码. 默认大家已经看过并理解了AIDL的相关内容.<br>不同于上层Framework, 这里要理解Binder需要涉及到底层native代码, 所以我们要提前准备好Android系统源码, 当然前面看Java层代码时不需要. 这里我以4.0源码为基础.<br>照惯例我们先从Binder源码看起. 打开<code>frameworks/base/core/java/android/os/Binder.java</code>, 先来看看它都有哪些主要内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">注释, 大意是说这个类是一个用于远程调用的基类, 是IBinder中定义的轻量级RPC的核心部分, 提供了远程对象本地实现的标准支持, 多数情况下开发者不需要直接实现Binder类, 而是利用aidl工具描述服务接口, 让aidl自动生成合适的Binder子类, 但是开发这当然可以直接继承Binder来实现自己的RPC协议或者仅仅是实例化一个Binder对象作为token在进程之间共享.</div><div class="line">*/</div><div class="line">public class Binder implements IBinder&#123;// Binder类实现IBinder接口</div><div class="line">private int mObject;</div><div class="line">private IInterface mOwner;</div><div class="line">private String mDescriptor;</div><div class="line"></div><div class="line">public static final native int getCallingPid();// 调用者进程ID, 可以用来检查权限</div><div class="line">public static final native int getCallingUid();// 返回与进程绑定的调用者用户ID, 可以用来检查权限</div><div class="line">public static final native long clearCallingIdentity();// 重置调用者ID, 当你需要调用别的Interface的时候, 为了让被调用的Interface检查你自己的权限, 你需要重置调用者ID. 它返回的token可以通过下面这个方法恢复调用者ID  </div><div class="line">public static final native void restoreCallingIdentity(long token);// 恢复调用者ID</div><div class="line">public static final native void setThreadStrictModePolicy(int policyMask);// 设置native层StrictMode策略</div><div class="line">public static final native int getThreadStrictModePolicy();// 获取native层StrictMode策略</div><div class="line">public static final native void flushPendingCommands();// 把等待中的命令刷到内核驱动. 如果将要执行一个可能阻塞很长时间的命令, 那么本方法可以将线程中等待的命令刷到内核驱动, 以防止本线程过久地持有等待中命令的引用</div><div class="line">public static final native void joinThreadPool();// 把调用者线程加入IPC线程池, 该方法仅在进程退出时返回</div><div class="line"></div><div class="line">public Binder() &#123;</div><div class="line">	init();// native method</div><div class="line">	// code to check potential leaks</div><div class="line">&#125;</div><div class="line">public void attachInterface(IInterface owner, String descriptor);// 绑定IInterface和对应的descriptor</div><div class="line">public String getInterfaceDescriptor();</div><div class="line">public boolean pingBinder();// 默认返回true</div><div class="line">public boolean isBinderAlive();// 默认返回true</div><div class="line">public IInterface queryLocalInterface(String descriptor);// 返回descriptor对应的IInterface或者null</div><div class="line">protected boolean onTransact(int code, Parcel data, Parcel reply, int flags);// 真正的事务执行函数, 希望子类重写</div><div class="line">public final boolean transact(int code, Parcel data, Parcel reply, int flags);// 事务执行函数, 里面回调onTransact</div><div class="line">private boolean execTransact(int code, int dataObj, int replyObj, int flags);// 回调onTrasact, 如果抛出异常则返回true</div><div class="line">public void linkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line">public boolean unlinkToDeath(DeathRecipient recipient, int flags);// 本地实现无内容</div><div class="line"></div><div class="line">private native final void init();</div><div class="line">private native final void destroy();</div><div class="line">&#125;// Binder类</div><div class="line"></div><div class="line">final class BinderProxy implements IBinder &#123;// BinderProxy类</div><div class="line">    BinderProxy() &#123;</div><div class="line">        mSelf = new WeakReference(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 以下六个方法都成了native方法</div><div class="line">    public native boolean pingBinder();</div><div class="line">    public native boolean isBinderAlive();</div><div class="line">    public native String getInterfaceDescriptor();</div><div class="line">    public native boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line">    public native void linkToDeath(DeathRecipient recipient, int flags);</div><div class="line">    public native boolean unlinkToDeath(DeathRecipient recipient, int flags);</div><div class="line"></div><div class="line">    final private WeakReference mSelf;// 指向自身的弱引用</div><div class="line">    private int mObject;</div><div class="line">    private int mOrgue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看完源码至少有三个疑问: 1. IInterface和IBinder定义了哪些接口? 2. BinderProxy是什么, 怎么用的? 3. <code>Binder.java</code>中涉及到的那些native方法, 是怎么实现的?<br>打开<code>frameworks/base/core/java/android/os/IBinder.java</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/** 注释中详细讲述了IBinder的设计思路. 核心API是transact(), 与Binder的onTransact成对. 作为本地对象的它发送一个调用到远程IBinder对象, 同时作为远程对象的它可以接受一个调用并放到一个Binder对象中. 这个API是同步的, 以保证仅在远程onTransact返回后, 本地transact才返回, 这是所期望的行为.  </div><div class="line">系统在每个进程中维护一个事务线程池, 用于分发所有从外部进程进来的IPC. Binder系统允许递归调用, 比如A调用B, B的onTransact中又调用了A. */</div><div class="line">    // 定义了用户可以使用的事务代码</div><div class="line">    int FIRST_CALL_TRANSACTION  = 0x00000001;</div><div class="line">    int LAST_CALL_TRANSACTION   = 0x00ffffff;</div><div class="line"></div><div class="line">    // IBinder协议的事务代码</div><div class="line">    int PING_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;P&apos;&lt;&lt;16)|(&apos;N&apos;&lt;&lt;8)|&apos;G&apos;;</div><div class="line">    int DUMP_TRANSACTION        = (&apos;_&apos;&lt;&lt;24)|(&apos;D&apos;&lt;&lt;16)|(&apos;M&apos;&lt;&lt;8)|&apos;P&apos;;</div><div class="line">    int INTERFACE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;N&apos;&lt;&lt;16)|(&apos;T&apos;&lt;&lt;8)|&apos;F&apos;;</div><div class="line">    int TWEET_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;T&apos;&lt;&lt;16)|(&apos;W&apos;&lt;&lt;8)|&apos;T&apos;;</div><div class="line">    int LIKE_TRANSACTION   = (&apos;_&apos;&lt;&lt;24)|(&apos;L&apos;&lt;&lt;16)|(&apos;I&apos;&lt;&lt;8)|&apos;K&apos;;// 告诉app调用者喜欢它. 可选命令, 应用不必处理, 没啥卵用. 默认实现啥也不做.  </div><div class="line">    int SYSPROPS_TRANSACTION = (&apos;_&apos;&lt;&lt;24)|(&apos;S&apos;&lt;&lt;16)|(&apos;P&apos;&lt;&lt;8)|&apos;R&apos;;// hide</div><div class="line"></div><div class="line">    // transact的标记, 表示这是一个单向调用, 调用者不等待被调用者的结果, 而是立即返回</div><div class="line">    int FLAG_ONEWAY             = 0x00000001;</div><div class="line">    public static final int MAX_IPC_SIZE = 64 * 1024;// hide</div><div class="line"></div><div class="line">    public String getInterfaceDescriptor();</div><div class="line">    // 查询Binder是否可用有三种方式, 当Binder不可用时, transact()会抛出RemoteException, pingBinder()会返回false, linkToDeath()预先连接一个DeathRecipient, 不可用时会回调这个DeathRecipient的binderDied()</div><div class="line">    public boolean pingBinder();</div><div class="line">    public boolean isBinderAlive();</div><div class="line"></div><div class="line">    public IInterface queryLocalInterface(String descriptor);</div><div class="line"></div><div class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags);</div><div class="line"></div><div class="line">    public interface DeathRecipient &#123;</div><div class="line">        public void binderDied();</div><div class="line">    &#125;</div><div class="line">    public void linkToDeath(DeathRecipient recipient, int flags);// 连接一个DeathRecipient接收器, 当Binder不可用时回调</div><div class="line">    public boolean unlinkToDeath(DeathRecipient recipient, int flags);</div></pre></td></tr></table></figure></p>
<p>可见, IBinder定义了一套Transaction协议用于指明发起的Transaction类型, 定义了<code>transact()</code>核心接口, 该接口与Binder中的<code>onTransact</code>配合使用才能完成远程调用的功能. 定义了查询接口, 返回一个<code>IInterface</code>实例. 下面看看这个接口定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface IInterface</div><div class="line">&#123;</div><div class="line">    public IBinder asBinder();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就这一个接口方法, 返回<code>IBinder</code>实例. 注释中说该方法返回与该Interface绑定的Binder实例.<br>以上这些内容, 定义了一个基本的Binder系统框架, 即通过同一套<code>Binder &amp; IBinder &amp; IInterface</code>接口, 本地以<code>transact()</code>发起远程调用, 远程在<code>onTransact()</code>中处理相应调用. 本地以<code>asInterface()</code>获取远程服务的实例(实际获得的是服务的代理, 代理内对每个服务接口中的方法, 调用远程服务的transact方法, 传递一个约定好的事务代码和方法参数, 远程服务的onTransact会对每个约定好的事务代码, 生成相应的switch case, 调用真正的服务接口实现. 由于客户端和服务端对服务接口的定义是相同的, 故生成的服务接口也相同, 可以在本地aidl生成的java文件中查看onTransact的实现), 远程以<code>asBinder()</code>返回远程服务的实例, 本地通过asInterface返回的代理来调用远程服务的方法, 跟调用本地服务方法表面上看起来没有差别.  </p>
<h3 id="Service的启动过程"><a href="#Service的启动过程" class="headerlink" title="Service的启动过程"></a>Service的启动过程</h3><p>离开具体实现的Binder是无法工作的, 我们自己当然可以自行继承Binder来写自己的远程服务. AIDL是Android为我们提供的一种方便快捷生成Binder实现的方式和工具, 而Service是由系统实现了服务端的Binder. 我们以它为例, 说明如何启动服务, 以及其中哪里用到了Binder.<br>我们知道, 要获取服务(系统服务除外, 其实系统服务就是提供了一个通过descriptor获取服务的接口), 首先我们要知道服务的全名, 在Intent中设定服务全名, 并指定一个ServiceConnection回调, 调用<code>bindService(Intent, ServiceConnection, CONTEXT_OPTION)</code>绑定服务(其中第三个参数的含义稍后解释), 在<code>ServiceConnection</code>中获取到服务实例. 我们已经知道<code>ServiceConnection</code>的回调方法被调用时已经得到了服务实例, 下面我们看看<code>bindService</code>如何绑定服务获取服务实例.  </p>
<p><code>bindService</code>方法的定义来自于<code>Context</code>, <code>Activity</code>的<code>bindService</code>调用的是<code>ContextWrapper.bindService</code>, 其默认实现是调用<code>mBase.bindService</code>, <code>mBase</code>是一个<code>Context</code>类型的成员变量, 这里的<code>mBase</code>是一个<code>ContextImpl</code>实例变量. 在<code>ContextImpl.java</code>中, <code>bindService</code>是这么定义的:  </p>
<pre><code>class ContextImpl extends Context {
    ......

    @Override
    public boolean bindService(Intent service, ServiceConnection conn,
            int flags) {  
        IServiceConnection sd;  
        if (mPackageInfo != null) {  
            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),  
                mMainThread.getHandler(), flags);  
        } else {  
            ......  
        }  
        try {  
            int res = ActivityManagerNative.getDefault().bindService(  
                mMainThread.getApplicationThread(), getActivityToken(),  
                service, service.resolveTypeIfNeeded(getContentResolver()),  
                sd, flags);  
            ......  
            return res != 0;  
        } catch (RemoteException e) {  
            return false;  
        }
    }
    ......
}
</code></pre><p>这里的mMainThread是一个<code>ActivityThread</code>实例, 通过它的<code>getHandler</code>函数可以获得一个Handler对象(这里返回的Handler是在<code>ActivityThread</code>类内部从Handler类继承下来的一个H类实例变量), 有了这个Handler对象后, 就可以把消息分发到<code>ActivityThread</code>所在的线程消息队列中去了.<br>获得了这个Handler对象后, 就调用<code>mPackageInfo.getServiceDispatcher</code>函数来获得一个<code>IServiceConnection</code>接口, 这里的<code>mPackageInfo</code>的类型是<code>LoadedApk</code>, 它的<code>getServiceDispatcher</code>函数比较长我就不贴了, 大致上它先以传进来的context为key查找<code>mServices</code>成员中是否已经有对应的<code>ServiceDispatcher</code>, 没有则新建一个, 将传进来的<code>ServiceConnection</code>和Handler都保存在<code>ServiceDispatcher</code>内部, 并创建一个<code>InnerConnection</code>, <font color="red">这是一个Binder对象!</font> 最后返回给sd的就是这个<code>InnerConnection</code>对象.  </p>
<div id="LoadedApk.ServiceDispatcher.InnerConnection"></div><br>接着调用<code>ActivityManagerNative.getDefault().bindService()</code>, 在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>文件中, 函数定义如下:<br><br><div id="ActivityManagerService-bindService"></div>  

<pre><code>class ActivityManagerProxy implements IActivityManager  
{  
    ......  

    public int bindService(IApplicationThread caller, IBinder token,  
            Intent service, String resolvedType, IServiceConnection connection,  
            int flags) throws RemoteException {  
        Parcel data = Parcel.obtain();  
        Parcel reply = Parcel.obtain();  
        data.writeInterfaceToken(IActivityManager.descriptor);  
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeStrongBinder(token);  
        service.writeToParcel(data, 0);  
        data.writeString(resolvedType);  
        data.writeStrongBinder(connection.asBinder());// 被调用的服务的Binder作为数据传输给服务端
        data.writeInt(flags);  
        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);// 调用了transact, 进Binder驱动
        reply.readException();  
        int res = reply.readInt();  
        data.recycle();  
        reply.recycle();  
        return res;  
    }  

    ......  
}  
</code></pre><p>这个函数通过Binder驱动程序就进入到<code>ActivityManagerService</code>的<code>bindService</code>函数去了(到此为止, 代码执行就从Binder客户端进入到了Binder服务端), 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>文件中, 代码比较长就不贴了. 主要做了以下这些事:<br>函数首先根据传进来的参数token(是调用者Activity在<code>ActivityManagerService</code>里面的令牌), 将这个代表调用者Activity的<code>ActivityRecord</code>取回来.<br>接着通过<code>retrieveServiceLocked</code>函数, 得到一个<code>ServiceRecord</code>, 这个<code>ServiceReocrd</code>描述的是一个Service对象,这是根据传进来的参数service的内容获得的(service是个Intent, 带有我们要用的具体Service的信息).<br>接着把传进来的connection参数封装成一个<code>ConnectionRecord</code>对象, 并保存了它的一个引用到<code>activity.connections</code>中以方便后续取用.<br>最后, 传进来的第四个参数flags是有限的几种<code>BindServiceFlags</code>中的一种, 它决定了具体行为. 以<code>BIND_AUTO_CREATE</code>为例, 它会走到<code>private final boolean bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean whileRestarting)</code>, 第一个参数就是前面的Intent service, 第二个参数通过<code>service.getFlags()</code>得到, 第三个参数传的false. 该函数中, 首先判断应用进程是否存在, 如果存在则调用<code>realStartServiceLocked(r, app)</code>, app是通过进程名和uid获取到的<code>ProcessRecord</code>(如果不存在则启动新进程, 并将服务压栈等待进程启动完成, 在这个新进程上执行serivce). 来看这个函数实现:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......
    private final void realStartServiceLocked(ServiceRecord r,
            ProcessRecord app) throws RemoteException {  
        ......  
        r.app = app;  
        ......  

        app.services.add(r);
        ......  

        try {  
            ......  
            app.thread.scheduleCreateService(r, r.serviceInfo);  
            ......  
        } finally {  
            ......  
        }  

        requestServiceBindingsLocked(r);  

        ......  
    }
    ......
}
</code></pre><p>这个函数执行了两个操作, 一个是<code>app.thread.scheduleCreateService(r, r.serviceInfo)</code>在应用程序进程内部创建Service, 这个操作会导致Service的<code>onCreate</code>被调用; 另一个操作是调用<code>requestServiceBindingsLocked</code>函数向服务获取一个Binder对象, 这个操作会导致Service的<code>onBind</code>函数被调用. 可能有读者觉得有点偏题了, 实际不然, 这两个操作都依赖Binder机制. 先来看前者:  </p>
<pre><code>class ApplicationThreadProxy implements IApplicationThread {  
    ......  

    public final void scheduleCreateService(IBinder token, ServiceInfo info)  
            throws RemoteException {  
        Parcel data = Parcel.obtain();  
        data.writeInterfaceToken(IApplicationThread.descriptor);  
        data.writeStrongBinder(token);  
        info.writeToParcel(data, 0);  
        mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, null,  
            IBinder.FLAG_ONEWAY);// 又一次Binder调用, 进入到的是ApplicationThread.scheduleCreateService, flag引人注目
        data.recycle();  
    }  

    ......  
}  
</code></pre><p>这里通过Binder驱动程序就进入到<code>ApplicationThread</code>的<code>scheduleCreateService</code>函数去了. 它的定义在<code>frameworks/base/core/java/android/app/ActivityThread.java</code>文件中:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    private final class ApplicationThread extends ApplicationThreadNative {  
        ......  

        public final void scheduleCreateService(IBinder token,  
            ServiceInfo info) {  
            CreateServiceData s = new CreateServiceData();  
            s.token = token;  
            s.info = info;  

            queueOrSendMessage(H.CREATE_SERVICE, s);  
        }  

        ......  
    }  
    ......  
}  
</code></pre><p>其中<code>queueOrSendMessage</code>是<code>ActivityThread</code>的方法, 它用Handler把创建服务的操作放到了Activity线程的消息队列中, 在<code>handleMessage</code>时调用<code>handleCreateService</code>处理该消息, 代码如下:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    private final void handleCreateService(CreateServiceData data) {  
        ......  

        LoadedApk packageInfo = getPackageInfoNoCheck(  
        data.info.applicationInfo);  
        Service service = null;  
        try {  
            java.lang.ClassLoader cl = packageInfo.getClassLoader();  
            service = (Service) cl.loadClass(data.info.name).newInstance();  // 加载类, 获得实例
        } catch (Exception e) {  
            ......  
        }  

        try {  
            ......  

            ContextImpl context = new ContextImpl();  
            context.init(packageInfo, null, this);  

            Application app = packageInfo.makeApplication(false, mInstrumentation);  
            context.setOuterContext(service);  
            service.attach(context, this, data.info.name, data.token, app,  
                ActivityManagerNative.getDefault());  // 绑定服务

            service.onCreate();  // 进入onCreate生命周期
            mServices.put(data.token, service); // 保存服务映射
            ......  
        } catch (Exception e) {  
            ......  
        }  
    }  
    ......  
}  
</code></pre><p>至此, 服务实例就创建出来了. 下面回到<code>realStartServiceLocked</code>看<code>requestServiceBindingsLocked</code>, 它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>中:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative  
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......  

    private final void requestServiceBindingsLocked(ServiceRecord r) {  
        Iterator&lt;IntentBindRecord&gt; bindings = r.bindings.values().iterator();  
        while (bindings.hasNext()) {  
            IntentBindRecord i = bindings.next();  
            if (!requestServiceBindingLocked(r, i, false)) {  
                break;  
            }  
        }  
    }  

    private final boolean requestServiceBindingLocked(ServiceRecord r,  
            IntentBindRecord i, boolean rebind) {  
        ......  
        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) {  
          try {  
              ......  
              r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);  
              ......  
          } catch (RemoteException e) {  
              ......  
          }  
        }  
        return true;  
    }  

    ......  
}  
</code></pre><p>(下回分解)<br>1月9日, 继续分解Service启动过程.<br>前面说到经过<code>handleCreateService</code>之后, <code>Service</code>实例就通过ClassLoader载入到内存, 并通过newInstance创建了实例, 且进入到<code>onCreate</code>周期. 创建完毕后, 接着调用<code>requestServiceBindingsLocked</code>, 这个方法从名字看应该是要绑定服务了, 打开源码发现它实际调用了<code>app.thread.scheduleBindService</code>, 传的参数<code>ServiceRecord r</code>代表我们启动的自定义服务. <code>app.thread</code>是一个Binder对象的远程接口, 它的类型是<code>ApplicationThreadProxy</code>, 这一点从前面也看得出来. 通过代理和Binder驱动, 我们就进入到<code>ApplicationThread</code>的<code>scheduleBindService</code>中了:  </p>
<pre><code>class ApplicationThreadProxy implements IApplicationThread {  
    ......  

    public final void scheduleBindService(IBinder token, Intent intent, boolean rebind)  throws RemoteException {  
        Parcel data = Parcel.obtain();  
        data.writeInterfaceToken(IApplicationThread.descriptor);  
        data.writeStrongBinder(token);  
        intent.writeToParcel(data, 0);  
        data.writeInt(rebind ? 1 : 0);  
        mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, null,  
            IBinder.FLAG_ONEWAY);  
        data.recycle();  
    }  

    ......  
}  
</code></pre><p>那么, 我们来看看<code>ApplicationThread</code>中<code>scheduleBindService</code>是怎么实现的:  </p>
<pre><code>public final class ActivityThread {  
    ......  

    public final void scheduleBindService(IBinder token, Intent intent,  
            boolean rebind) {  
        BindServiceData s = new BindServiceData();  
        s.token = token;  
        s.intent = intent;  
        s.rebind = rebind;  

        queueOrSendMessage(H.BIND_SERVICE, s);  
    }  

    ......  
}  
</code></pre><p>很眼熟对不对? 相信不用我说你也知道之后是什么了:  </p>
<div id="Service.onBind"></div>  

<pre><code>switch (msg.what) {  
......  
case BIND_SERVICE:  
    handleBindService((BindServiceData)msg.obj);  
    break;  
......  
}  

...
private final void handleBindService(BindServiceData data) {  
    Service s = mServices.get(data.token);  
    if (s != null) {  
        try {  
            data.intent.setExtrasClassLoader(s.getClassLoader());  
            try {  
                if (!data.rebind) {  
                    IBinder binder = s.onBind(data.intent);  
                    ActivityManagerNative.getDefault().publishService(  
                        data.token, data.intent, binder);  
                } else {  
                    ......  
                }  
                ......  
            } catch (RemoteException ex) {  
            }  
        } catch (Exception e) {  
            ......  
        }  
    }  
}
</code></pre><p>首先将前面保存在<code>mServices</code>中的服务通过<code>data.token</code>取出来放到本地变量, 然后让它执行<code>onBind</code>获得一个Binder对象, 接着将这个对象传递给<code>ActivityManagerService.getDefa().publishService()</code>. <code>onBind</code>是自定义服务自己重写的, 就是返回一个实现了IBinder接口的Binder对象. <code>publishSerivce</code> 定义在<code>frameworks/base/core/java/android/app/ActivityManagerNative.java</code>中, 如下:  </p>
<pre><code>class ActivityManagerProxy implements IActivityManager  
{  
    ......  
    public void publishService(IBinder token,  
    Intent intent, IBinder service) throws RemoteException {  
        Parcel data = Parcel.obtain();  
        Parcel reply = Parcel.obtain();  
        data.writeInterfaceToken(IActivityManager.descriptor);  
        data.writeStrongBinder(token);  
        intent.writeToParcel(data, 0);  
        data.writeStrongBinder(service);  
        mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, 0);// 眼熟不?  
        reply.readException();  
        data.recycle();  
        reply.recycle();  
    }  
    ......  
}
</code></pre><p>再来看<code>publishService</code>的实现, 理所当然它的定义在<code>frameworks/base/services/java/com/android/server/am/ActivityManagerService.java</code>中:  </p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative  
        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {  
    ......  

    public void publishService(IBinder token, Intent intent, IBinder service) {  
        ......  
        synchronized(this) {  
            ......  
            ServiceRecord r = (ServiceRecord)token;  
            ......  

            ......  
            if (r != null) {  
                Intent.FilterComparison filter  
                    = new Intent.FilterComparison(intent);  
                IntentBindRecord b = r.bindings.get(filter);  
                if (b != null &amp;&amp; !b.received) {  
                    b.binder = service;  
                    b.requested = true;  
                    b.received = true;  
                    if (r.connections.size() &gt; 0) {  
                        Iterator&lt;ArrayList&lt;ConnectionRecord&gt;&gt; it  
                            = r.connections.values().iterator();  
                        while (it.hasNext()) {  
                            ArrayList&lt;ConnectionRecord&gt; clist = it.next();  
                            for (int i=0; i&lt;clist.size(); i++) {  
                                ConnectionRecord c = clist.get(i);  
                                ......  
                                try {  
                                    c.conn.connected(r.name, service);  
                                } catch (Exception e) {  
                                    ......  
                                }  
                            }  
                        }  
                    }  
                }  

                ......  
            }  
        }  
    }  

    ......  
}
</code></pre><p>这里传进来的service不出意外的话就是我们自定义<code>onBinder</code>返回的那个东西了, 也就是我们自定义服务的实例. 这里的<code>token</code>是一个<code>ServiceRecord</code>对象, 是在前面<a href="#ActivityManagerService-bindService">bindService</a>中中创建的. 在那里, 我们保存了自定义服务的一个<code>ConnectionRecord</code>在这个<code>ServiceRecord.connections</code>列表中, 因此这里可以通过<code>r.connections</code>取出那个<code>ConnectionRecord</code>.<br>取出<code>ConnectionRecord</code>之后, 调用成员变量的函数<code>conn.connected()</code>. 这个conn是一个<code>IServiceConnection</code>类型, 它是一个Binder对象的远程接口, 这个Binder对象, 就是我们在<a href="#LoadedApk.ServiceDispatcher.InnerConnection">前面</a>创建的<code>LoadedApk.ServiceDispatcher.InnerConnection</code>对象. 因此, 这里的<code>connected</code>就到了<code>InnerConnection.connected</code>:  </p>
<pre><code>// in file frameworks/base/core/java/android/app/LoadedApk.java
final class LoadedApk {  
    ......  

    static final class ServiceDispatcher {  
        ......  

        private static class InnerConnection extends IServiceConnection.Stub {  
            ......  

            public void connected(ComponentName name, IBinder service) throws RemoteException {  
                LoadedApk.ServiceDispatcher sd = mDispatcher.get();  
                if (sd != null) {  
                    sd.connected(name, service);  // 转到了外层ServiceDispatcher类中的connected
                }  
            }  
            ......  
        }  
        ......  

        public void connected(ComponentName name, IBinder service) {  
            if (mActivityThread != null) {  
                mActivityThread.post(new RunConnection(name, service, 0)); // 放到ActivityThread的消息队列中. mActivityThread是一个Handler实例  
            } else {  
                ......  
            }  
        }  
        ......  

        private final class RunConnection implements Runnable {  
            ......  

            public void run() {  
                if (mCommand == 0) {  
                    doConnected(mName, mService);  
                } else if (mCommand == 1) {  
                    ......  
                }  
            }  
            ......  
        }  
        ......  

        public void doConnected(ComponentName name, IBinder service) {  
            ......  

            // If there is a new service, it is now connected.  
            if (service != null) {  
                mConnection.onServiceConnected(name, service);  
            }  
        }  
    }  
    ......  
}
</code></pre><p>新建了一个<code>RunConnection</code>并调用<code>H.post</code>放到了<code>ActivityThread</code>的消息队列中. 当处理该消息时, 会运行的<code>RunConnection</code>的<code>run()</code>来处理, 原因见我另一篇文章<a href="./handler.md">Handler原理</a>. 此时<code>mCommand==0</code>, 最后就会执行到<code>mConnection.onServiceConnected</code>函数. 这里的<code>mConnection</code>的类型是<code>ServiceConnection</code>, 它是在<a href="#ActivityManagerService-bindService">前面</a>设置好的, 它是我们调用<code>bindService</code>时传入的<code>ServiceConnection</code>实例, 在前面我们用它通过<code>ServiceDispatcher</code>换得了一个<code>IServiceConnection</code>对象.<br>传入的第二个参数<code>service</code>是一个IBinder对象, 它其实就是我们<a href="#Service.onBind">前面</a>从自定义Service中得到的自定义Binder对象, 因此这里我们可以直接强转成那个自定义Binder类型, 并通过它的<code>getService</code>接口获取到自定义服务的接口. 至此, 我们经过<code>onServiceConnection</code>, 调用<code>getService</code>, 绑定并获取了自定义服务.  </p>
<h3 id="Binder驱动的实现"><a href="#Binder驱动的实现" class="headerlink" title="Binder驱动的实现"></a>Binder驱动的实现</h3><p>上面多次提到”进入了Binder驱动”, 可见Binder驱动在这个设计中具有重要的桥梁作用. 那么除了上面看到的那些, Binder驱动到底是什么样子呢? 接下来让我们深入Binder驱动源码.<br>首先我们要知道是哪里进入到Native Binder驱动的:<br><code>IYourService.Stub.Proxy.YOUR_API()</code>中, 调用<code>android.os.IBinder(实现在 android.os.Binder.BinderProxy).transact()</code>发送<code>Stub.TRANSACTION_YOUR_API</code> ==&gt; <strong><code>BinderProxy.transact()</code>进入Native层</strong> ==&gt; 由jni转到<code>android_os_BinderProxy_transact()</code>函数 ==&gt; 调用<code>IBinder-&gt;transact</code>函数.  </p>
<h4 id="调用mRemote-transact时进到了BinderProxy并在其中调用native方法android-os-BinderProxy-transact"><a href="#调用mRemote-transact时进到了BinderProxy并在其中调用native方法android-os-BinderProxy-transact" class="headerlink" title="调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()"></a>调用mRemote.transact时进到了BinderProxy并在其中调用native方法android_os_BinderProxy_transact()</h4><p>直到jni为止的内容我们前面已经了解过了, 下面来看<code>android_os_BinderProxy_transact()</code>函数:  </p>
<pre><code>// in file frameworks/base/core/jni/android_util_Binder.cpp

......

static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,
        jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException
{
    // check and parse data
    ......

    IBinder* target = (IBinder*)
        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);// 获取mObject指向的本地对象

    status_t err = target-&gt;transact(code, *data, reply, flags);// 调用本地代码的transact

    if (err == NO_ERROR) {
        return JNI_TRUE;
    } else if (err == UNKNOWN_TRANSACTION) {
        return JNI_FALSE;
    }

    signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize());
    return JNI_FALSE;
}
......

static const JNINativeMethod gBinderProxyMethods[] = {
     /* name, signature, funcPtr */
    {&quot;pingBinder&quot;,          &quot;()Z&quot;, (void*)android_os_BinderProxy_pingBinder},
    {&quot;isBinderAlive&quot;,       &quot;()Z&quot;, (void*)android_os_BinderProxy_isBinderAlive},
    {&quot;getInterfaceDescriptor&quot;, &quot;()Ljava/lang/String;&quot;, (void*)android_os_BinderProxy_getInterfaceDescriptor},
    {&quot;transactNative&quot;,      &quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;, (void*)android_os_BinderProxy_transact},
    {&quot;linkToDeath&quot;,         &quot;(Landroid/os/IBinder$DeathRecipient;I)V&quot;, (void*)android_os_BinderProxy_linkToDeath},
    {&quot;unlinkToDeath&quot;,       &quot;(Landroid/os/IBinder$DeathRecipient;I)Z&quot;, (void*)android_os_BinderProxy_unlinkToDeath},
    {&quot;destroy&quot;,             &quot;()V&quot;, (void*)android_os_BinderProxy_destroy},
};
......
</code></pre><p>其中, <code>gBinderProxyOffsets.mObject</code>是在Java层调用<code>IBinder.getContextObject()</code>时, 在<code>javaObjectForIBinder</code>函数中设置的:  </p>
<pre><code>// in file frameworks/base/core/jni/android_util_Binder.cpp
......

static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)
{
    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);
    return javaObjectForIBinder(env, b);
}

jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)
{
    ...
    LOGDEATH(&quot;objectForBinder %p: created new proxy %p !\n&quot;, val.get(), object);
    // The proxy holds a reference to the native object.
    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());// 设置本地IBinder对象, 令mObject指向它
    val-&gt;incStrong((void*)javaObjectForIBinder);
    ...
}

.....
########################################################################

// in file frameworks/native/libs/binder/ProcessState.cpp
......

sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)
{
    return getStrongProxyForHandle(0);
}

sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)
{
    sp&lt;IBinder&gt; result;
    ...
    b = new BpBinder(handle);
    result = b;
    ...
    return result;
}
</code></pre><p>可见, <code>android_os_BinderProxy_transact()</code>函数实际上调用的是 <code>BpBinder::transact()</code> 函数.  </p>
<h4 id="jni中的target-gt-transact调用进到BpBinder-再进到IPCThreadState"><a href="#jni中的target-gt-transact调用进到BpBinder-再进到IPCThreadState" class="headerlink" title="jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState"></a>jni中的target-&gt;transact调用进到BpBinder, 再进到IPCThreadState</h4><p>来看看<code>BpBinder::transact()</code>, 它位于<code>frameworks/native/libs/binder/BpBinder.cpp</code>:  </p>
<pre><code>status_t BpBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    // Once a binder has died, it will never come back to life.
    if (mAlive) {
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);// 调用IPCThreadState::self()-&gt;transact
        if (status == DEAD_OBJECT) mAlive = 0;
        return status;
    }

    return DEAD_OBJECT;
}
</code></pre><p><code>IPCThreadState</code>中是这么写的:  </p>
<pre><code>status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, const Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck();

    flags |= TF_ACCEPT_FDS;

    if (err == NO_ERROR) {
        LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),
            (flags &amp; TF_ONE_WAY) == 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

    if ((flags &amp; TF_ONE_WAY) == 0) {
        if (reply) {
            err = waitForResponse(reply);
        } else {
            Parcel fakeReply;
            err = waitForResponse(&amp;fakeReply);
        }
    } else {
        err = waitForResponse(NULL, NULL);
    }

    return err;
}

status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.ptr = 0; /* Don&apos;t pass uninitialized stack data to a remote process */
    tr.target.handle = handle;
    tr.code = code;
    ...

    mOut.writeInt32(cmd);
    mOut.write(&amp;tr, sizeof(tr));

    return NO_ERROR;
}
</code></pre><p>由函数内容可以看出, 数据再一次通过 <code>writeTransactionData()</code> 传递给 <code>mOut</code> 进行写入操作. <code>mOut</code> 是一个 <code>Parcel</code> 对象, 声明在 <code>IPCThreadState.h</code> 文件中. 之后则调用 <code>waitForResponse()</code> 函数.</p>
<h4 id="IPCThreadState-waitForResponse-在一个-while-循环里不断的调用-talkWithDriver-并检查是否有数据返回"><a href="#IPCThreadState-waitForResponse-在一个-while-循环里不断的调用-talkWithDriver-并检查是否有数据返回" class="headerlink" title="IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回"></a>IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回</h4><!-- 此处插代码 -->  
<pre><code>// in file frameworks/base/libs/binder/IPCThreadState.cpp
......

status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)
{
    int32_t cmd;
    int32_t err;

    while (1) { // 永真循环
        if ((err=talkWithDriver()) &lt; NO_ERROR) break; // 调用talkWithDriver, 当返回负时退出循环
        err = mIn.errorCheck();
        if (err &lt; NO_ERROR) break;
        if (mIn.dataAvail() == 0) continue;

        cmd = mIn.readInt32(); // 读取命令

        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;
                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;
        }

        switch (cmd) {
        case BR_TRANSACTION_COMPLETE:
            if (!reply &amp;&amp; !acquireResult) goto finish;
            break;

        case BR_DEAD_REPLY:
            err = DEAD_OBJECT;
            goto finish;

        case BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;
            goto finish;

        case BR_ACQUIRE_RESULT:
            {
                LOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);
                const int32_t result = mIn.readInt32();
                if (!acquireResult) continue;
                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;
            }
            goto finish;

        case BR_REPLY:
            {
                binder_transaction_data tr;
                err = mIn.read(&amp;tr, sizeof(tr));// 读取远端返回的数据
                LOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;);
                if (err != NO_ERROR) goto finish;

                if (reply) {
                    if ((tr.flags &amp; TF_STATUS_CODE) == 0) {
                        reply-&gt;ipcSetDataReference(
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t),
                            freeBuffer, this);
                    } else {
                        err = *static_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);
                        freeBuffer(NULL,
                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                            tr.data_size,
                            reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                            tr.offsets_size/sizeof(size_t), this);
                    }
                } else {
                    freeBuffer(NULL,
                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                        tr.data_size,
                        reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                        tr.offsets_size/sizeof(size_t), this);
                    continue;
                }
            }
            goto finish;

        default:
            err = executeCommand(cmd); // 处理其他命令, 例如NO_ERROR
            if (err != NO_ERROR) goto finish;
            break;
        }
    }

finish:
    if (err != NO_ERROR) {
        if (acquireResult) *acquireResult = err;
        if (reply) reply-&gt;setError(err);
        mLastError = err;
    }

    return err;
}
......
</code></pre><p><div id="talkWithDriver"></div></p>
<h4 id="IPCThreadState-talkWithDriver-函数是真正与-binder-驱动交互的实现"><a href="#IPCThreadState-talkWithDriver-函数是真正与-binder-驱动交互的实现" class="headerlink" title="IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现"></a>IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现</h4><!-- 此处插代码 -->  
<pre><code>......

status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= 0, &quot;Binder driver is not opened&quot;);

    binder_write_read bwr;

    // Is the read buffer empty?
    const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize();

    // We don&apos;t want to write anything if we are still reading
    // from data left in the input buffer and the caller
    // has requested to read the next data.
    const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0;

    // 写入数据
    bwr.write_size = outAvail;
    bwr.write_buffer = (long unsigned int)mOut.data();

    // This is what we&apos;ll read.
    // 读取数据
    if (doReceive &amp;&amp; needRead) {
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (long unsigned int)mIn.data();
    } else {
        bwr.read_size = 0;
    }

    IF_LOG_COMMANDS() {
        TextOutput::Bundle _b(alog);
        if (outAvail != 0) {
            alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;
            const void* cmds = (const void*)bwr.write_buffer;
            const void* end = ((const uint8_t*)cmds)+bwr.write_size;
            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;
            while (cmds &lt; end) cmds = printCommand(alog, cmds);
            alog &lt;&lt; dedent;
        }
        alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size
            &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;
    }

    // Return immediately if there is nothing to do.
    if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR;

    bwr.write_consumed = 0;
    bwr.read_consumed = 0;
    status_t err;
    do {
        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        }
#if defined(HAVE_ANDROID_OS)
        // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令
        // 该过程在下一节详述
        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)
            err = NO_ERROR;
        else
            err = -errno;
#else
        err = INVALID_OPERATION;
#endif
        IF_LOG_COMMANDS() {
            alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
        }
    } while (err == -EINTR);

    IF_LOG_COMMANDS() {
        alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)err &lt;&lt; &quot;, write consumed: &quot;
            &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()
            &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;
    }

    if (err &gt;= NO_ERROR) {
        if (bwr.write_consumed &gt; 0) {
            if (bwr.write_consumed &lt; (ssize_t)mOut.dataSize())
                mOut.remove(0, bwr.write_consumed);
            else
                mOut.setDataSize(0);
        }
        if (bwr.read_consumed &gt; 0) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(0);
        }
        IF_LOG_COMMANDS() {
            TextOutput::Bundle _b(alog);
            alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;
            alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;
            const void* cmds = mIn.data();
            const void* end = mIn.data() + mIn.dataSize();
            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;
            while (cmds &lt; end) cmds = printReturnCommand(alog, cmds);
            alog &lt;&lt; dedent;
        }
        return NO_ERROR;
    }

    return err;
}
......
</code></pre><p><code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code> 就是使用系统调用函数 <code>ioctl</code> 向 <code>binder</code> 设备文件 <code>/dev/binder</code> 发送 <code>BINDER_WRITE_READ</code> 命令.<br>回到上一步<code>waitForResponse</code>, 获取到<code>talkWithDriver</code>返回的命令<code>cmd</code>后默认执行<code>executeCommand(cmd)</code>, 来处理返回命令  </p>
<h4 id="IPCThreadState-executeCommand-int32-t-cmd-处理返回命令"><a href="#IPCThreadState-executeCommand-int32-t-cmd-处理返回命令" class="headerlink" title="IPCThreadState::executeCommand(int32_t cmd) 处理返回命令"></a>IPCThreadState::executeCommand(int32_t cmd) 处理返回命令</h4><p>除了在switch case中处理的命令以外, 其他的命令都通过调用<code>executeCommand</code>来处理, 它的实现如下:<br><!-- 此处插代码 -->  </p>
<pre><code>......

status_t IPCThreadState::executeCommand(int32_t cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    status_t result = NO_ERROR;

    switch (cmd) {
    // switch能处理的命令很多, 我们省略掉其他命令, 重点看正常数据处理
    ...
    case BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr));
            LOG_ASSERT(result == NO_ERROR,
                &quot;Not enough command data for brTRANSACTION&quot;);
            if (result != NO_ERROR) break;

            Parcel buffer;
            buffer.ipcSetDataReference(
                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t), freeBuffer, this);

            // 判断和设置优先级
            ...

            Parcel reply;
            if (tr.target.ptr) {
                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);
                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);// 实际执行的是 BBinder.transact() !
                if (error &lt; NO_ERROR) reply.setError(error);

            } else {
                const status_t error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
                if (error &lt; NO_ERROR) reply.setError(error);
            }

            if ((tr.flags &amp; TF_ONE_WAY) == 0) {
                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);
                sendReply(reply, 0);
            } else {
                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);
            }
            ...
        }
        break;
    ...
    return result;
}
......
</code></pre><p>可见它调用了<code>BBinder::transact()</code>来处理数据, 该函数定义如下:  </p>
<pre><code>// in file frameworks/base/libs/binder/Binder.cpp
status_t BBinder::transact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    data.setDataPosition(0);

    status_t err = NO_ERROR;
    switch (code) {
        case PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            break;
        default:
            err = onTransact(code, data, reply, flags);// 调用onTransact
            break;
    }

    if (reply != NULL) {
        reply-&gt;setDataPosition(0);
    }

    return err;
}
</code></pre><p>在此处<code>b-&gt;transact</code>调用时, <code>b</code>是一个<code>JavaBBinder</code>实例, <code>JavaBBinder</code>继承了<code>BBinder</code>类, 重写了<code>onTransact</code>, 所以这里实际调用的是<code>JavaBBinder.onTransact</code>, 定义见<code>frameworks/base/core/jni/android_util_Binder.cpp</code>:  </p>
<pre><code>virtual status_t onTransact(
    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)
{
    JNIEnv* env = javavm_to_jnienv(mVM);
    ...
    jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,
        code, (int32_t)&amp;data, (int32_t)reply, flags);// 调用gBinderOffsets.mExecTransact
    ...
    return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;
}


static int int_register_android_os_Binder(JNIEnv* env)
{
    jclass clazz;

    clazz = env-&gt;FindClass(kBinderPathName);
    LOG_FATAL_IF(clazz == NULL, &quot;Unable to find class android.os.Binder&quot;);
    ...
    gBinderOffsets.mExecTransact
        = env-&gt;GetMethodID(clazz, &quot;execTransact&quot;, &quot;(IIII)Z&quot;);
    ...
    return AndroidRuntime::registerNativeMethods(
        env, kBinderPathName,
        gBinderMethods, NELEM(gBinderMethods));
}
</code></pre><p>由上可见, <code>JavaBBinder</code>通过JNI的<code>gBinderOffsets.mExecTransact</code>调用java方法<code>android.os.Binder.execTransact</code>. 执行的实际上是<code>android.os.Binder.onTransact</code>. 它的实现如下:  </p>
<pre><code>// in file frameworks/base/core/java/android/os/Binder.java

// Entry point from android_util_Binder.cpp&apos;s onTransact
private boolean execTransact(int code, int dataObj, int replyObj,
        int flags) {
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we&apos;ll just call it directly.
    boolean res;
    try {
        res = onTransact(code, data, reply, flags);
    }
    // catch clauses
    ...
    reply.recycle();
    data.recycle();
    return res;
}

protected boolean onTransact(int code, Parcel data, Parcel reply,
       int flags) throws RemoteException {
   if (code == INTERFACE_TRANSACTION) {
       reply.writeString(getInterfaceDescriptor());
       return true;
   } else if (code == DUMP_TRANSACTION) {
       ParcelFileDescriptor fd = data.readFileDescriptor();
       String[] args = data.readStringArray();
       if (fd != null) {
           try {
               dump(fd.getFileDescriptor(), args);
           } finally {
               try {
                   fd.close();
               } catch (IOException e) {
                   // swallowed, not propagated back to the caller
               }
           }
       }
       // Write the StrictMode header.
       if (reply != null) {
           reply.writeNoException();
       } else {
           StrictMode.clearGatheredViolations();
       }
       return true;
   }
   return false;
}
</code></pre><p>由此可见, 经过Binder驱动之后, 最终会在服务端进程的<code>android.os.Binder.onTransact</code>处理命令和数据. 而我们在服务端的<code>IYourService.Stub</code>中, 重写了<code>onTransact</code>来调用服务接口的服务端实现(大多数情况下, 这个重写是aidl工具帮你完成的). 至此, Binder驱动下的IPC通讯过程已全部明了(除了中间处理进程状态的过程以及打开Binder设备文件进行数据读写的过程以外).  </p>
<p>一句话总结就是: 客户端发送<code>BC_TRANSACTION</code>命令到Binder驱动-&gt;服务端进程监听<code>BR_TRANSACTION</code>命令并处理;如果是服务端返回数据, 过程类似, 但发送的命令是<code>BC_REPLY</code>命令-&gt;客户端监听<code>BR_REPLY</code>命令  </p>
<h4 id="Binder设备驱动实现"><a href="#Binder设备驱动实现" class="headerlink" title="Binder设备驱动实现"></a>Binder设备驱动实现</h4><p>在<a href="#talkWithDriver">上一节中</a>, 我们只简单提了一下<code>ioctl</code>系统调用是对<code>/dev/binder</code>设备文件进行读写操作, 这一节详述该过程.  </p>
<p>首先, <code>ioctl</code>第一个参数<code>mProcess-&gt;mDriverFD</code>是Binder驱动的文件描述符(File Descriptor), 它是在<code>ProcessState</code>初始化时由函数<code>open_driver()</code>初始化的, <code>open_driver</code>代码如下:  </p>
<pre><code>// in file frameworks/base/libs/binder/ProcessState.cpp
static int open_driver()
{
    int fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (fd &gt;= 0) {
        fcntl(fd, F_SETFD, FD_CLOEXEC);
        int vers;
        // 获取驱动版本
        status_t result = ioctl(fd, BINDER_VERSION, &amp;vers);
        if (result == -1) {
            LOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno));
            close(fd);
            fd = -1;
        }
        // 检查驱动版本是否一致
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            LOGE(&quot;Binder driver protocol does not match user space protocol!&quot;);
            close(fd);
            fd = -1;
        }
        // 设置最多15个线程
        size_t maxThreads = 15;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);
        if (result == -1) {
            LOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno));
        }
    } else {
        LOGW(&quot;Opening &apos;/dev/binder&apos; failed: %s\n&quot;, strerror(errno));
    }
    return fd;
}
</code></pre><p>初始化后文件描述符保存在<code>mDriverFD</code>中, 以后通过它就可以和设备文件交互.  </p>
<p>其次, 在经过<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>调用后, 对设备驱动文件的读写操作就被完全封装在了结构体<code>binder_write_read</code>中. 具体的读写过程见<a href="#talkWithDriver">talkWithDriver的实现代码</a>及我的注释.<br>可见, 真正的数据读写都是通过<code>/dev/binder</code>来执行的, 其上封了命令<code>BINDER_WRITE_READ</code>用一个数据结构<code>binder_write_read</code>来存储读取和写入的数据, 再上封了<code>transact</code>处理不同逻辑概念下的事务. 再上通过<code>BBinder</code>接口联系到JNI代码和Java代码.  </p>
<p>最后, 让我们看看<code>/dev/binder</code>这个驱动程序的实现. 它是Binder的最终实现.<br>在看驱动代码前, 我们需要了解一些背景知识. 作为一个特殊的字符型设备, Binder的挂载节点是<code>/dev/binder</code>, 遵循Linux设备驱动模型, 在驱动实现过程中主要通过<code>binder_ioctl</code>函数与用户空间的进程交换数据. Android中的Service都是通过它来完成IPC的, 具体来说, 在Android虚拟机启动前, 系统会先启动<code>ServiceManager</code>进程, 它负责打开Binder驱动程序, 并告诉驱动程序自己将作为系统服务的管理者(通过特殊命令<code>BINDER_SET_CONTEXT_MGR</code>, 此后<code>ServiceManager</code>也通过Binder驱动与其他进程进行通讯), 然后<code>ServiceManager</code>进入循环, 等待处理来自其他进程的数据.<br>在Android系统中共有三种IPC机制:  </p>
<ul>
<li>标准Linux Kernel IPC 接口  </li>
<li>标准D-BUS 接口  </li>
<li>Binder接口  </li>
</ul>
<p>由于我没有了解过其他两种方式, 所以这里我就不评价孰优孰劣了, 在Android系统中大部分程序都使用了Binder接口. Binder是OpenBinder的精简实现, 包含一个Binder驱动程序, 一个Binder服务器, 一个Binder客户端.  </p>
<p>清楚了以上背景之后, 让我们看一下Binder驱动程序的实现. Android中Binder协议的定义在头文件<code>binder.h</code>中, 不同版本源码的路径不太一样, 4.0的路径在<code>external/kernel-headers/original/linux/binder.h</code>, 定义了五种Binder类型(<code>bhd</code>分别表示<code>binder</code> <code>handle</code> <code>FD</code>三个大类):  </p>
<pre><code>enum {
    BINDER_TYPE_BINDER    = B_PACK_CHARS(&apos;s&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(&apos;w&apos;, &apos;b&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_HANDLE    = B_PACK_CHARS(&apos;s&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(&apos;w&apos;, &apos;h&apos;, &apos;*&apos;, B_TYPE_LARGE),
    BINDER_TYPE_FD        = B_PACK_CHARS(&apos;f&apos;, &apos;d&apos;, &apos;*&apos;, B_TYPE_LARGE),
};
</code></pre><p>同样是在这个头文件中, 定义了用于进程间传输的数据结构, 称作Binder Object, 它是一个<code>flat_binder_object</code>结构体, 定义如下(为方便理解我把注释也放上来了):  </p>
<pre><code>/*
 * This is the flattened representation of a Binder object for transfer
 * between processes.  The &apos;offsets&apos; supplied as part of a binder transaction
 * contains offsets into the data where these structures occur.  The Binder
 * driver takes care of re-writing the structure type and data as it moves
 * between processes.
 */
struct flat_binder_object {
    /* 8 bytes for large_flat_header. */
    unsigned long        type;// Binder对象类型, 即前面Binder协议中五种类型的一种
    unsigned long        flags;// 传输方式, 见下面transaction_flags

    /* 8 bytes of data. */
    union {
        void        *binder;    /* local object */
        signed long    handle;        /* remote object */
    };

    /* extra data associated with local object */
    void            *cookie;
};

...
enum transaction_flags {
    TF_ONE_WAY    = 0x01,    /* this is a one-way call: async, no return */
    TF_ROOT_OBJECT    = 0x04,    /* contents are the component&apos;s root object */
    TF_STATUS_CODE    = 0x08,    /* contents are a 32-bit status code */
    TF_ACCEPT_FDS    = 0x10,    /* allow replies with file descriptors */
};
</code></pre><p>从注释可以知道, <code>flat_binder_object</code>中的union结构存的就是要传输的数据, 当类型为<code>Binder</code>时, 数据是一个本地对象<code>*binder</code>, 当类型为<code>Handle</code>时, 数据是一个远程对象<code>handle</code>. Binder对象在进程间传递时, Binder驱动会修改它的类型和数据.<br>正如Binder的客户端和服务端是相对而言的一样, 这里的本地Binder和远程Handle对象也是相对而言的, 其实他们都指向同一个对象, 所以他们共用一个union空间, 只不过A的本地对象binder对于另一进程B来说就是远程对象handle.  </p>
<p>虽然<code>flat_binder_object</code>是要传输的Binder对象, 但实际上Binder驱动并不直接操作它, 而是将它封装成了一个<code>binder_transaction_data</code>, 操作的直接对象是这个封装的数据. 该封装的定义如下:  </p>
<pre><code>struct binder_transaction_data {
    /* The first two are only used for bcTRANSACTION and brTRANSACTION,
     * identifying the target and contents of the transaction.
     */
    union {
        size_t    handle;    /* target descriptor of command transaction */
        void    *ptr;    /* target descriptor of return transaction */
    } target;
    void        *cookie;    /* target object cookie */
    unsigned int    code;        /* transaction command */

    /* General information about the transaction. */
    unsigned int    flags;
    pid_t        sender_pid;
    uid_t        sender_euid;
    size_t        data_size;    /* number of bytes of data */
    size_t        offsets_size;    /* number of bytes of offsets */

    /* If this transaction is inline, the data immediately
     * follows here; otherwise, it ends with a pointer to
     * the data buffer.
     */
    union {
        struct {
            /* transaction data */
            const void    *buffer;// flat_binder_object被封装在*buffer中
            /* offsets from buffer to flat_binder_object structs */
            const void    *offsets;
        } ptr;
        uint8_t    buf[8];
    } data;
};
</code></pre><p><hr><br>了解了真正传输的数据结构之后, 让我们来深入Binder生命周期. 以下内容涉及到: Binder设备创建, Binder启动, Binder释放,  Binder数据关联, Binder接口及命令含义. 我尽量从我自己追踪代码的习惯来讲解, 这样虽然效率比较低但是好处是更容易理解和回忆. 以下内容与源码实现紧密关联, 再次声明, 本文基于<code>Android4.0</code>源码写就, 不适用于其他版本.  </p>
<ol>
<li><p>Binder设备创建<br> 作为一个特殊的符号设备, Binder设备也是需要进行创建的. 可以合理猜测系统有一个统一的创建驱动设备的过程, Binder作为其中一个设备一起被创建(如果不对, 就追踪调用栈, 看哪里引用了<code>frameworks/base/cmds/servicemanager/binder.c</code>, 特别是调用了里面的<code>binder_open</code>). 在这种猜测下, 我们来找一下符号设备的创建(我假设你跟我一样不知道Android下启动过程是否跟Linux一样). 到源码目录搜索<code>/dev/binder</code>, 除了前面提到的<code>ProcessState.open_driver</code>以外, 在以下三个文件中还出现了<code>/dev/binder</code>: <code>frameworks/base/cmds/servicemanager/binder.c</code>, <code>system/core/rootdir/ueventd.rc</code>, <code>system/extras/tests/fstest/perm_checker.conf</code>. 好像没有看出哪个是创建binder设备? 别急, 如果你看过老罗的&lt;<a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>&gt;一文, 就可能猜测, 在文件<code>frameworks/base/cmds/servicemanager/binder.c</code>中, 有完整的<code>binder_open</code> <code>binder_release</code> <code>binder_write</code>实现, 正好这三个操作是实现Linux设备驱动时需要定义的基本操作的一部分, 这意味着该文件很可能就是Binder设备驱动文件. 我们假设它的确是, 那么应该有设备注册和初始化操作(模块加载, 卸载方法), 但很遗憾搜索之后发现没有. 难道Binder设备不用注册吗? 不是的, 进一步在整个源码范围搜索binder注册函数<code>binder_init</code>, 发现它匹配到了<code>prebuilt/android-arm/kernel/vmlinux-qemu</code>, 而这个我们知道是预编译好的Linux内核, 看来应该是在Linux内核源码里实现的设备注册, 遗憾的是直接下载Android源码的话是不带内核源码的, 我只好去下载了对应的内核源码(4.0系统对应3.0内核, 2.2系统对应2.6内核, 4.2~4.3系统对应3.4内核). 本文不讲怎么下载Android内核代码, 直接给出相关代码片段:  </p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

// 定义文件操作函数
static const struct file_operations binder_fops = {
    .owner = THIS_MODULE,
    .poll = binder_poll,
    .unlocked_ioctl = binder_ioctl,
    .mmap = binder_mmap,
    .open = binder_open,
    .flush = binder_flush,
    .release = binder_release,
};

static struct workqueue_struct *binder_deferred_workqueue;

// 初始化函数
static int __init binder_init(void)
{
    int ret;

    // 创建了一个内核工作队列对象workqueue, 用于执行可以延期执行的工作任务
    binder_deferred_workqueue = create_singlethread_workqueue(&quot;binder&quot;);
    if (!binder_deferred_workqueue)
        return -ENOMEM;

    // 创建调试目录 /sys/kernel/debug/binder
    binder_debugfs_dir_entry_root = debugfs_create_dir(&quot;binder&quot;, NULL);
    if (binder_debugfs_dir_entry_root)
        binder_debugfs_dir_entry_proc = debugfs_create_dir(&quot;proc&quot;,
                         binder_debugfs_dir_entry_root);
    // 注册字符设备
    ret = misc_register(&amp;binder_miscdev);
    // 创建调试文件
    if (binder_debugfs_dir_entry_root) {
        debugfs_create_file(&quot;state&quot;,
                    S_IRUGO,
                    binder_debugfs_dir_entry_root,
                    NULL,
                    &amp;binder_state_fops);
                    ...
    }
    return ret;
}

// 调用初始化函数加载内核, 基本等价于不支持动态编译驱动模块的module_init, 如果需要把Binder改成动态的内核模块, 直接把这个device_initcall改成module_init, 同时添加驱动卸载接口函数 module_exit即可
device_initcall(binder_init);
</code></pre><p>可见在系统装载设备的时候, 就加载了Binder设备模块, 并绑定了设备操作对应的函数.  </p>
<p>好奇心重一点的读者可能会去自行发掘Linux设备模块怎么编写. Linux驱动程序的一个主要功能就是向用户空间的程序提供操作接口, 这个接口是标准的, Binder包含的接口有:  </p>
<pre><code>-Proc接口（/proc/binder）
    . /proc/binder/state
    . /proc/binder/stats
    . /proc/binder/transactions
    . /proc/binder/transaction_log
    . /proc/binder/failed_transaction_log
    . /proc/binder/proc/

-设备接口（/dev/binder）
    . binder_open
    . binder_release
    . binder_flush
    . binder_mmap
    . binder_poll
    . binder_ioctl
</code></pre></li>
<li><p>Binder启动<br> 在<code>frameworks/base/cmds/servicemanager/binder.c</code>中定义了binder设备打开的函数<code>binder_open</code>:  </p>
<pre><code>struct binder_state *binder_open(unsigned mapsize)
{
    struct binder_state *bs;

    bs = malloc(sizeof(*bs));
    if (!bs) {
        errno = ENOMEM;
        return 0;
    }

    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);
    if (bs-&gt;fd &lt; 0) {
        fprintf(stderr,&quot;binder: cannot open device (%s)\n&quot;,
                strerror(errno));
        goto fail_open;
    }

    bs-&gt;mapsize = mapsize;
    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);
    if (bs-&gt;mapped == MAP_FAILED) {
        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,
                strerror(errno));
        goto fail_map;
    }

        /* TODO: check version */

    return bs;

fail_map:
    close(bs-&gt;fd);
fail_open:
    free(bs);
    return 0;
}
</code></pre><p> 这个函数作用是把设备映射到内存, 在Binder设备驱动中还有一个同名函数负责打开Binder设备和设置引用计数, 如下:  </p>
<pre><code>// in file kernel/goldfish/drivers/staging/android/binder.c

static int binder_open(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc;

    // 初始化, 分配 binder_proc 数据结构内存
    proc = kzalloc(sizeof(*proc), GFP_KERNEL);
    if (proc == NULL)
        return -ENOMEM;

    // 增加当前线程/进程的引用计数并赋值给proc-&gt;tsk
    get_task_struct(current);
    proc-&gt;tsk = current;
    // 初始化binder_proc队列和默认优先级
    INIT_LIST_HEAD(&amp;proc-&gt;todo);
    init_waitqueue_head(&amp;proc-&gt;wait);
    proc-&gt;default_priority = task_nice(current);

    binder_lock(__func__);

    // 增加 BINDER_STAT_PROC对象计数
    binder_stats_created(BINDER_STAT_PROC);
    // 添加进程节点proc_node到binder_procs的全局列表中, 任何进程都可以访问其他进程的binder_proc对象
    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);
    // 保存进程id
    proc-&gt;pid = current-&gt;group_leader-&gt;pid;
    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);
    // 驱动文件的private_data指向proc
    filp-&gt;private_data = proc;

    binder_unlock(__func__);
    ...

    return 0;
}
</code></pre></li>
<li><p>Binder释放<br> 同样是在<code>frameworks/base/cmds/servicemanager/binder.c</code>文件中定义了设备释放函数<code>binder_release</code>:  </p>
<pre><code>void binder_release(struct binder_state *bs, void *ptr)
{
    uint32_t cmd[2];
    cmd[0] = BC_RELEASE;
    cmd[1] = (uint32_t) ptr;
    binder_write(bs, cmd, sizeof(cmd));
}
</code></pre><p> 可见只是发送了一个释放命令给Binder驱动, 那么可以肯定驱动中也有一个释放函数, 正好前面看到过设备操作的接口中有一个就是<code>binder_release</code>与这里的函数同名, 不会是巧合. <code>kernel/goldfish/drivers/staging/android/binder.c</code>中相关代码片段如下:  </p>
<pre><code>static int binder_release(struct inode *nodp, struct file *filp)
{
    struct binder_proc *proc = filp-&gt;private_data;
    debugfs_remove(proc-&gt;debugfs_entry);
    binder_defer_work(proc, BINDER_DEFERRED_RELEASE);

    return 0;
}
</code></pre><p> 好嘛, 释放操作给了<code>binder_defer_work</code>, 这又是嘛? 其实前面我们在初始化的时候就有内容涉及到它: 在<code>create_singlethread_workqueue</code>的时候创建了一个叫做<code>binder_deferred_workqueue</code>的队列, 该队列用来调度执行<code>binder_deferred_work</code>, 而两者发生联系就是在函数<code>binder_defer_work</code>中, <code>queue_work</code>使用了他们作为函数参数. 前面说过这个队列里都是可以延期执行的任务, 而<code>binder_deferred_work</code>有三种类型, 即枚举变量<code>binder_deferred_state</code>中定义的<code>PUT_FILES</code> <code>FLUSH</code> <code>RELEASE</code>.<br> 显然, 释放的具体操作就要看<code>queue_work</code>函数了, 很可惜我查的资料里没有详述这个函数做了啥. 它的定义在<code>kernel/goldfish/kernel/workqueue.c</code>中, 粗略看了下, 理解不一定对, 感觉它跟Handler类似, 在入队work的时候获取执行work的worker, 而由别的过程控制出队和实际执行, 只不过它所处的层次更靠近硬件.  </p>
</li>
<li>Binder数据关联<br> 前面说过, 传输对象中<code>binder</code>和<code>handle</code>其实指向的是同一个对象, 现在来解释一下为什么. 在一次调用中, 对于客户端进程来说, handle存储的索引是一个远端对象的句柄, 当数据经由Binder驱动传达到服务端的时候, 服务端就会把这个索引解释为本地对象的地址, 对于第三方来说, 客户端的handle和服务端的binder都是指向了服务端的那个Binder对象. 对于Binder来说, 对象的索引和映射是通过<code>binder_node</code>和<code>binder_ref</code>两个核心数据结构来完成的, 两个定义都可以在文件<code>kernel/goldfish/drivers/staging/android/binder.c</code>中看到. 对于Binder本地对象, 对象的Binder地址保存在<code>binder_node-&gt;ptr</code>里, 对于远程对象, 索引保存在<code>binder_ref-&gt;desc</code>里, 每一个<code>binder_node</code>都有一个<code>binder_ref</code>与之对应, 他们通过<code>ptr</code>和<code>desc</code>来做映射. 前面说过进程间传递的Binder对象实际上是<code>flat_binder_object</code>这个数据结构, 每个<code>flat_binder_object</code>在内核都有一个唯一的<code>binder_node</code>对象与之对应, 这个对象挂载在<code>binder_proc</code>的一棵二叉树上, 而每一个<code>binder_node</code>又有唯一一个<code>binder_ref</code>对象与之对应. 可以这么理解, <code>binder_ref-&gt;desc</code> <code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code> <code>flat_binder_object-&gt;handle</code>四者都指向同一个对象, 其中<code>binder_node-&gt;ptr</code> <code>binder_node-&gt;cookie</code>的<code>binder_node</code>位于服务端. <code>binder_ref</code>按照node和desc两种方式映射到<code>binder_proc</code>对象上, 因此可以通过<code>binder_node</code>或者<code>desc</code>查找到<code>binder_ref</code>或<code>binder_node</code>. 对于一个<code>flat_binder_object</code>对象来说, 它的<code>binder, cookie, handle</code>都指向的同一个<code>binder_node</code>对象.<br> Binder驱动中, flush操作在关闭一个设备文件描述符拷贝时被调用, 这里不做探究. 另一个操作mmap(memory map)负责把设备内存映射到用户进程地址空间中, 用户进程可以像操作内存一样操作设备. 一般的设备驱动, 设备内存是设备本身具有的, 或者在驱动初始化时由<code>vmalloc</code>或<code>kmalloc</code>等内核函数分配好, Binder不同于此, 它的设备内存是由mmap操作来分配的, 分配方法是现在内核虚拟映射表上获取一段可用区域, 再分配物理页, 并把物理页映射到获取的虚拟地址区域. 每个进程/线程只能做一次mmap操作, 其后重复操作都会返回错误. mmap分配内存的代码见文件<code>kernel/goldfish/drivers/staging/android/binder.c#binder_mmap</code>片段, 过程大致是先做检查调用合法性等准备工作, 然后申请虚拟内存空间, 再使用<code>binder_update_page_range</code>分配物理空间(实际是分配了1个页的物理内存用来存储指针buffer, 1个物理页是4K, 1个指针是4字节, 所以1页最多可存1K个指针, 每个指针对应一个物理页, 所以对应最多4M物理空间, 这是一次mmap最多可以分配的物理内存量, 这里不管实际申请了多大的物理内存, 内核总是提供1页物理内存用来放buffer指针, 即每次都允许申请最多的物理页), 在该函数中利用Linux系统中内存相关函数完成具体分配任务, 完成后由<code>binder_buffer</code>负责管理该内存区域, <code>binder_buffer</code>放到了<code>proc-&gt;buffers</code>链表中, 今后就可以通过这段内存区域完成设备数据读写了. 更形象的插图见<a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a>相关章节, 本段主要参考该文和内核代码完成.  </li>
<li>Binder接口及命令<br> Binder能得以正确工作, 首先要依赖于一致的Binder协议. 其中Binder类型在前文<code>external/kernel-headers/original/linux/binder.h</code>中提到过, 一共3大类5小类. 其实该文件中还定义了Binder驱动支持的命令格式和数据定义, 分为客户端的<code>BinderDriverCommandProtocol</code>和服务端的<code>BinderDriverReturnProtocol</code>, 两个都是枚举类型, 很可惜以我现在的C水平, 看不懂枚举成员<code>BC_TRANSACTION = _IOW_BAD(&#39;c&#39;, 0, struct binder_transaction_data)</code>的写法是什么意思, 大概猜测是第一个参数是访问模式, 第二个参数是指令, 第三个参数是数据指针. 客户端命令(BC)中第一个参数都是’c’, 宏<code>_IOR_BAD</code>根据资料应该是指向的<code>ioctl</code>的, 也就是说这里的参数传给了<code>ioctl</code>. 服务端返回(BR)的第一个参数都是’r’, 表示read. 两个数据结构定义了Binder客户端和服务端可以执行的全部命令. 既然有协议, 自然就有版本, 细心的读者可能发现, 前文<code>binder_open</code>函数里面就隐藏了一段注释, 说明以后会有<code>check version</code>的步骤.  </li>
</ol>
<p>本节主要参考:  </p>
<ul>
<li><a href="http://blog.csdn.net/yangwen123/article/details/9316987" target="_blank" rel="external">深入分析Android Binder 驱动</a>  </li>
<li><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="external">Binder 源码分析</a>  </li>
<li><a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html" target="_blank" rel="external">BinderIPC原理</a>  </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6568411" target="_blank" rel="external">在Ubuntu上为Android系统编写Linux内核驱动程序</a>  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>给两个主要结论和一个图(图不是我画的, 但来源记不得了), 方便大家按图索骥.  </p>
<p><img src="/images/blogs/binder_native_stack.png" alt="binder native stack">  </p>
<ol>
<li><p>Binder的实现从上到下涉及到Java层(Application层)/JNI层/Native层(Runtime层)/Linux kernel层, 可以说涉及到了Android的整个架构, 说是它的核心之一一点不过分. 系统服务的注册/获取/使用/Intent传递都通过Binder驱动, 对它的深入理解将会起到提纲挈领的效果.  </p>
</li>
<li><p>上层的<code>android.os.Binder</code>是对Binder的一层封装, 一般不直接使用. 如果定义服务, 使用系统提供的<code>Service</code>接口即可(它完成了一个默认的<code>android.os.Binder</code>实现), 如果是自定义跨进程服务, 使用<code>AIDL</code>将是更快的方式, 它本质是一个对Binder操作进行封装的工具. 如果不嫌麻烦, 直接使用<code>android.os.Binder</code>来定义客户端和服务端也是完全可行的.  </p>
</li>
</ol>
<p>说实话这篇文章写得有点吃力, 一个是时间拉太长, 记忆跟不上, 另一个是这个内容本身比较难用平白的语言讲清楚. 感谢大家阅读, 难免理解有误或以讹传讹, 欢迎大家指正.  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Binder机制
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】Handler全解</title>
    <link href="https://hjhjw1991.github.io/android/2017/01/06/%5BAndroid%E6%95%99%E7%A8%8B%5DHandler%E5%85%A8%E8%A7%A3/"/>
    <id>https://hjhjw1991.github.io/android/2017/01/06/[Android教程]Handler全解/</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-05-04T10:32:16.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某渣的凭印象回顾"><a href="#某渣的凭印象回顾" class="headerlink" title="某渣的凭印象回顾"></a>某渣的凭印象回顾</h2><p>Handler是线程间消息通讯的一种方式. 使用它需要Message, MessageQueue, Looper几个东西的配合. 每个线程都有一个Looper对象, 它里面有个方法loop()会去轮询消息队列MessageQueue中的Message, 对每个Message去调用它目标线程的Handler来处理这个消息. 轮询的操作会调用native方法使用epoll机制来获得Message. 最常见的使用场景就是子线程中做计算, 将结果返回给主线程, 此时子线程就需要使用主线程的Handler来发送消息到主线程的消息队列, 再由主线程的Handler来处理消息.  </p>
<h2 id="为什么需要Handler"><a href="#为什么需要Handler" class="headerlink" title="为什么需要Handler"></a>为什么需要Handler</h2><p>参考: <a href="http://blog.csdn.net/innost/article/details/47317823" target="_blank" rel="external">&lt;&lt;深入理解Android 卷III&gt;&gt;第二章 深入理解Java Binder和MessageQueue</a>  </p>
<ol>
<li>线程之间通信的需要. 在Android中, 系统做了一个隐含假设, 即用来显示UI的线程应该只用来显示UI包括更新UI, 不应该做过多的事情, 而同时, 其他线程应该做他们该做的事情, 而不应该更新UI. 因此, 如果试图在一个非UI线程中更新UI组件, 会抛出异常(如果你知道某个叫<code>runOnMainThread</code>的黑科技你当然可以用), 而如果在UI线程中做了过多的事情, 会导致UI线程阻塞(ANR). 这就造成一个问题, 我们经常需要根据业务逻辑或计算结果去更新UI, 这怎么办呢? 就需要其他线程和UI线程之间进行通信, 传递需要的信息.  </li>
<li>事件异步处理的需要. 有时候我们会遇到这样一种情况: 我们希望过一段时间去做某件事, 但又不希望线程阻塞去等待这个时间, 这时候我们当然可以通过新建一个线程在一段时间后与主线程通信的方式来实现这个目的, 但这样显然有点小题大做了, 有没有更好的机制能够异步处理消息而不需要额外创建子线程呢? 答案就是Handler.  </li>
</ol>
<h2 id="Handler的设计思想-工作原理"><a href="#Handler的设计思想-工作原理" class="headerlink" title="Handler的设计思想/工作原理"></a>Handler的设计思想/工作原理</h2><p>Handler不是一个孤立的类, 它与MessageQueue, Message, Looper几个类共同构成了线程间消息传递的系统.<br>其中, Message是具体消息的载体, Handler负责生产和消耗Message, MessageQueue负责把Message构成一个有序的队列, Looper负责从MessageQueue中取出Message对象. Handler, MessageQueue, Looper三个类构成了一个Message流动的循环.  </p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>对于一般的线程, 我们只需要定义一个MyHandler类, 让它继承Handler类, 实现我们自己的<code>handleMessage</code>方法, 处理对应类型的Message就可以了, 大多数情况下甚至我们只需要在UI线程代码中定义一个继承Handler的匿名内部类并实现其<code>handleMessage</code>方法足矣. <code>Handler</code>中的<code>sendMessage</code>系列方法可以完成将Message入队的操作. <code>obtainMessage</code>可以获取一个空闲的Message对象. 如果你只满足于<code>Handler</code>的基本使用方法, 那知道这些就足够用了.(完)  </p>
<p><div name="empty"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><br>很好, 看来你跟我一样不只想要知道怎么用, 还想知道为什么这样用. Android那帮大牛将Handler设计得很巧妙, 机制简单易懂, 封装得非常好, 以至于我们一般情况下只需要知道上面那段话就行了. 不一般的情况呢, 我们从问题入手, 随便抛出几个问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?  </li>
</ol>
<p>以上都是很容易想到的问题, 而要彻底搞懂它们, 免不了要打开Android源码.<br>我说的”实践”, 就是看Android源码对Handler的实现.<br>现在, 先让我们抛开那些问题, 从Handler开始, 一步一步看清这背后的真相. 打开Handler源码查看它的定义, 发现它有以下几个成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final MessageQueue mQueue;</div><div class="line">final Looper mLooper;</div><div class="line">final Callback mCallback;</div><div class="line">final boolean mAsynchronous;</div></pre></td></tr></table></figure></p>
<p>一看到这几个我们心里就有点猜测了, 前两个不就是前面提到的消息队列和消息循环器吗! 不过后两个是什么鬼? 别急, 先看Handler构造方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来上面几个成员变量都在构造函数中初始化了. 其中<code>mLooper</code>使用的是<code>Looper.myLooper()</code>的返回结果, 而<code>mQueue</code>直接使用了<code>mLooper.mQueue</code>. 可以猜测MessageQueue实例是由Looper来创建的, Handler持有这个Looper实例的引用, Handler和mLooper共同持有MessageQueue实例的引用. 构造方法传进来的两个参数用来初始化其余两个成员变量.<br>来看<code>Looper.myLooper()</code>, 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</div><div class="line"></div><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从Looper的静态成员变量<code>sThreadLocal</code>中获取的Looper实例. 那么有<code>get()</code>应该也有<code>set()</code>, 可我们好像没有看到哪里有调用<code>set()</code>? 以及<code>ThreadLocal</code>这个类是个什么东西?<br>关于ThreadLocal可以看<a href="http://blog.csdn.net/singwhatiwanna/article/details/48350919" target="_blank" rel="external">任玉刚的这篇博客</a>了解, 简单来说就是一个可以存储和访问仅对当前线程可见的数据的类.<br>我们直奔<code>set()</code>方法去看看, 发现了下面这段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来是<code>prepare()</code>这个方法直接新建了一个<code>Looper</code>对象放在里面, 这样在之后取的话就能取到这个Looper了. 可是我们好像也没有调用<code>prepare()</code>? 事实上, 如果我们没有调用<code>prepare()</code>的话, 就会抛出上面Handler构造方法里面mLooper为空时的那个异常啦! 所以<code>prepare()</code>这个方法是必调的, 而且一定是在Handler所在线程中先于Handler实例创建.<br>再来看Looper的构造函数, 如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">       mQueue = new MessageQueue(quitAllowed);</div><div class="line">       mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>明白了, 在Looper构造函数中, 新建了MessageQueue, 并且持有了当前线程的引用.<br>细心的同学可能会问了: “我在Activity里面没有调用prepare方法, 可我用Handler也用得很6啊!”. 这位同学, 我很欣赏你的细心. <code>Activity</code>就是我们的UI线程了, 为什么我们在UI线程里面可以不调用<code>prepare</code>呢? 答案是, 系统已经帮我们调用过了. 有看过Activity启动源码的同学可能会知道, 在Android中Activity的启动是通过<code>ActivityManagerService</code>做到的, 其中在<code>ActivityThread</code>里面, 会调用<code>Looper.prepareMainLooper()</code>为主线程准备一个Looper, 并且调用<code>Looper.loop()</code>开始轮询. 其中<code>prepareMainLooper()</code>大体上就是调用了<code>prepare</code>方法, 只不过加了个锁来保证主线程Looper对象的唯一性.  </p>
<p>到此, 我们已经知道了Looper对象从哪里来, 到哪里去, 我们也知道调用<code>loop()</code>方法之后Looper就开始轮询MessageQueue了, 但我们还不知道Looper对象的<code>loop()</code>方法在干嘛. 看看源码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line"></div><div class="line">    //获得一个 Looper 对象</div><div class="line">    final Looper me = myLooper();</div><div class="line"></div><div class="line">    // 拿到 looper 对应的 mQueue 对象</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    //死循环监听(如果没有消息变化，他不会工作的) 不断轮询 queue 中的 Message</div><div class="line">    for (;;) &#123;</div><div class="line">        // 通过 queue 的 next 方法拿到一个 Message</div><div class="line">        Message msg = queue.next(); // 可能会阻塞, 具体是调用native方法时可能阻塞</div><div class="line">        //空判断</div><div class="line">        if (msg == null)return;</div><div class="line">        //消息分发   </div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        //回收操作  </div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取到MessageQueue实例, 死循环读取下一个消息, 再调用<code>Message.target.dispatchMessage(msg)</code>将消息分发到<code>target</code>中去处理.<br>诶? 这个target是啥? 显然, 它是在Message中设置好的东西, 让我们看看Handler的<code>sendMessage</code>源码. Handler中有许多发送消息的方法, 但追本溯源会到达下面这个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Handler target;</div><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    // 使用默认的 handler 构造方法时，mAsynchronous 为 false。</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">       msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有意思, 发送消息时首先检验MessageQueue是不是为空, 不空的话就执行入队操作, 在入队的方法中让Message对象持有当前Handler的引用, 然后调用MessageQueue的入队方法. 有兴趣的同学可以再深入看一下MessageQueue的入队方法是怎么实现的, 里面会涉及到更加具体的所使用的数据结构, 由于它不影响咱们理解Handler机制, 这里就暂不展开了.<br>再看<code>dispatchMessage</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一切都连起来了. 在这里, 如果你的Message对象中, callback为空, 那么就会执行到Handler成员<code>mCallback</code>的<code>handleMessage</code>方法或Handler的<code>handleMessage</code>方法, 否则会直接执行<code>handleCallback</code>. 我们去看一下<code>handleCallback</code>和<code>Message</code>的源码, 就会发现<code>callback</code>是一个<code>Runnable</code>对象, 而<code>handleCallback</code>中直接调用了这个对象的<code>run()</code>方法. 所以我们可以得出结论, 如果设置了Message的callback, 那handleMessage就不起作用了, 转而用callback来处理这个消息. 按Android那帮天才的习惯, Handler里应该有对应的API来供开发者调用. 果不其然, 可以找到<code>post</code>等相关方法.  </p>
<p>至此, Message是怎么进入和退出MessageQueue, 又是怎么被Handler处理的, 这个过程我们都已经清楚了. 尝试回答一下本节开头时提出的问题:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: 看源码.  </li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: 看源码.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 看源码, 看我上面的分析.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 看我上面的分析.  </li>
</ol>
<p>如果你有种上当的感觉的话, 你的感觉是对的, 我上面这一段分析基本上没有回答这几个问题. 其实看到这里你应该也有所感觉, 重要的是这种设计的思路, 厘清了思路之后, 具体能做什么/怎么做, 就是可以自己把控的了.  </p>
<p>然鹅, 这里我正正经经回答一下上面那些问题, 免得搜索那些问题进来的同学们失望:  </p>
<ol>
<li>Message具体怎么实现的?它可以承载哪些信息?<br>A: <code>android.os.Message</code>是一个<code>final</code>类, 它实现了<code>Parcelable</code>接口, 通过一个<code>int</code>型的<code>flags</code>来标记状态, 状态包括<code>FLAG_IN_USE</code>, <code>FLAG_ASYNCHRONOUS</code>, <code>FLAGS_TO_CLEAR_ON_COPY_FROM</code>三种. <code>Message</code>内主要的成员变量有:  <ul>
<li>公共成员变量what/arg1/arg2/obj/replyTo/sendingUid, 前三个是整型, 后三个分别是<code>Object</code>, <code>Message</code>, <code>int</code>型. 我们可以通过<code>obtain</code>方法的重载来设置前四个变量.  </li>
<li>包可见成员变量flags(及其三个标志状态)/when/data/target/callback/next, 类型分别是<code>int</code>, <code>long</code>, <code>Bundle</code>, <code>Handler</code>, <code>Runnable</code>, <code>Message</code>. 其中除了next以外都有对应的设置方法.  </li>
<li>私有变量sPoolSync/sPool/sPoolSize/MAX_POOL_SIZE/gCheckRecycle, 类型分别是<code>Object</code>, <code>Message</code>, <code>int</code>, <code>final int</code>, <code>boolean</code>. 前四个的作用是在消息池非空时同步地从消息池(单链表, sPool指向表头)中摘出表头节点作为<code>obtain()</code>的返回值(所有重载的<code>obtain</code>方法都通过该无参方法获得Message实例), 或者在<code>recycleUnchecked()</code>时将当前消息插入到表头. 表的最大容量是50. 最后一个是在API 21加入的标记, 标志是否要检查回收状态. 使用中的<code>Message</code>被回收时如果该标志为<code>true</code>则抛出<code>IllegalStateException</code>异常.<br>总结来说, Message实现了一个最大容量为50的单链表结构, 其类静态变量<code>sPool</code>指向表头, 其实现了<code>Parcelable</code>接口, 可以承载包括<code>Bundle</code>在内的复杂数据.  </li>
</ul>
</li>
<li>Handler默认实现是怎样的?它的<code>obtainMessage</code>做了啥?为什么要用<code>obtainMessage</code>, 直接<code>new Message</code>可以吗?<code>sendMessage</code>又做了啥?这两个方法还可以更高效吗?除了<code>handleMessage</code>和<code>sendMessage</code>, Hanlder还可以做什么?<br>A: <code>android.os.Handler</code>是一个专用于继承实现的类, 它的<code>handleMessage</code>是一个空方法. 它内部定义了一个<code>Callback</code>接口, 含有<code>boolean handleMessage(Message msg)</code>方法, 成员变量<code>mCallback</code>就是这个接口类型, 在Handler的<code>dispatchMessage</code>中拥有第二优先权, 仅次于Message本身的Callback. 继承Handler类容易造成内存泄漏, 这一点需要格外注意. <code>obtainMessage</code>代理了<code>Message</code>类的静态多态方法<code>obtain</code>. 由于<code>Message</code>没有显式定义构造函数, 直接<code>new Message</code>显然是可以的, <code>obtain()</code>就是通过这个构造函数初始化消息池. 但这样做无法循环利用消息池, 造成内存浪费, 因此<code>obtainMessage</code>是更好地获取Message实例的方法. <code>sendMessage</code>做了什么见上文的相关段落,  由于这个是系统调用机制, 效率上我没有想到更好的实现方式. <code>sendMessageAtTime</code>等方法允许子类重写. 除了<code>handleMessage</code>和<code>sendMessage</code>, Handler中还定义了一些实用的方法和类, 例如可以获取到Looper, 可以传入Runnable获取Message实例, 可以dump信息, 实现了一个阻塞的<code>final class BlockingRunnable</code>用于内部的<code>runWithScissors</code>. 实现了一个<code>final class MessengerImpl</code>用于在发送Message之前设置Message的Uid为Binder的Uid, 并让包可见成员变量mMessenger持有该类的实例, 但实际上这个成员变量未在别处引用.  </li>
<li>MessageQueue是什么时候创建的?它怎么处理具有延迟时间的Message?MessageQueue有容量限制吗?<br>A: 上文已经分析了<code>MessageQueue</code>是什么时候创建的(创建Looper时). 在每个消息进入队列(<code>enqueueMessage</code>)的时候, 会根据该消息的时间when将它插入到消息队列链表(这个链表不同于消息池的链表)中, 因此消息队列中的消息都是按照消息时间排序好的, 在取出Message时, 如果没有到该消息的执行时间, 会<code>nativePollOnce</code>等待到执行时间. <code>MessageQueue</code>从代码看没有容量限制.  </li>
<li>Looper是什么时候创建的?它怎么处理Message为空的情况?它怎么把消息分发到正确的Handler对象?<br>A: 上文已经分析了Looper是什么时候创建的(<code>Looper.prepare()</code>调用时). 它怎么处理Message为空的情况? 答案是退出循环, 因为Message为空只可能出现在MessageQueue已经没有内容时. 它怎么分发到正确的Handler对象, 这可以看前文分析, 答案是在<code>sendMessage</code>调用<code>enqueueMessage</code>时, Handler默认会把每个<code>Message</code>的<code>target</code>都设置为它自己, 循环处理时直接调用<code>msg.target.dispatchMessage(msg)</code>来分发. 循环时Looper会保证始终在同一线程上处理消息队列, 如果线程发生变化, Looper会记录一个<code>Log.wtf()</code>日志(注释说是<code>What a Terrible Failure</code>, 但我怎么看都觉得是<code>What The Fxxk</code>). Looper每处理完一个Message都会调用它的<code>recycleUnchecked()</code>让它进入消息池.  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲Handler异步消息机制
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>【Android教程】NDK&amp;JNI入门</title>
    <link href="https://hjhjw1991.github.io/android/2016/12/21/%5BAndroid%E6%95%99%E7%A8%8B%5Dndk&amp;jni/"/>
    <id>https://hjhjw1991.github.io/android/2016/12/21/[Android教程]ndk&amp;jni/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2017-08-16T04:44:47.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NDK-amp-JNI"><a href="#NDK-amp-JNI" class="headerlink" title="NDK &amp; JNI"></a>NDK &amp; JNI</h2><p>NDK和JNI的关系是: Java通过JNI的方式调用由NDK编译生成的本地库.<br>JNI是独立于NDK的一个技术, NDK是帮助编译c/cpp文件的一个工具.  </p>
<p>在JNI的c文件中如果用到了<code>#include &lt;utils/Log.h&gt;</code>  </p>
<p>然后用NDK 编译的时候会提示<code>error: utils/Log.h: No such file or directory</code><br>这个是因为这个头文件在Android源码的<code>frameworks/base/include</code>中，不在SDK或NDK中  </p>
<p>如果想要使用NDK的LOG功能的话  </p>
<p>1—–修改Android.mk文件配置,添加如下语句，这是载入liblog库，其中$(SYSROOT)是NDK中platform的路径  </p>
<p><code>LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog</code>  </p>
<p>2—–在.c文件中修改为如下语句。这是引入NDK中的日志头文件，位置在<code>$(SYSROOT)/usr/include</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include&lt;android/log.h&gt;</div></pre></td></tr></table></figure></p>
<p>3—–使用方法。其中这后面的方法在头文件中可以找到定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define LOG_TAG &quot;debug&quot;</div><div class="line">#define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, fmt, ##args)</div><div class="line">#define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, fmt, ##args)</div></pre></td></tr></table></figure>
<p>4—-打印语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOGI(&quot;test log!!!!&quot;);</div><div class="line"></div><div class="line">LOGI(&quot;the string is: %s \n&quot;,buff);</div></pre></td></tr></table></figure></p>
<p>5—-错误输出到日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOGI(strerror(errno))</div></pre></td></tr></table></figure></p>
<p>如果想要开启NDK的Debug功能，需要按照下列步骤操作。  </p>
<h2 id="JNI中的映射关系"><a href="#JNI中的映射关系" class="headerlink" title="JNI中的映射关系"></a>JNI中的映射关系</h2><p>基本类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">Java 类型</th>
<th>jni本地类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean</td>
<td>jboolean</td>
<td style="text-align:left">C/C++ unsigned 8 bits</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td>jbyte</td>
<td style="text-align:left">C/C++ signed 8 bits</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td>jchar</td>
<td style="text-align:left">C/C++ unsigned 16 bits</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>jshort</td>
<td style="text-align:left">C/C++ signed 16 bits</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td>jint</td>
<td style="text-align:left">C/C++ signed 32 bits</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td>jlong</td>
<td style="text-align:left">C/C++ signed 64 bits</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>jfloat</td>
<td style="text-align:left">C/C++  32位浮点型</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>jdouble</td>
<td style="text-align:left">C/C++  64位浮点型</td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td>void</td>
<td style="text-align:left">N/A</td>
</tr>
</tbody>
</table>
<p>命名规则就是java基本类型加j前缀.  </p>
<p>引用类型和数组类型也差不多:<br>引用类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>jobject</td>
<td>任何Java对象，或者没有对应java类型的对象</td>
</tr>
<tr>
<td>Class</td>
<td>jclass</td>
<td>class对象</td>
</tr>
<tr>
<td>String</td>
<td>jstring</td>
<td>字符串对象</td>
</tr>
</tbody>
</table>
<p>数组类型  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean[]</td>
<td>jbooleanArray</td>
<td>布尔型数组 unsigned</td>
</tr>
<tr>
<td>byte[]</td>
<td>jbyteArray</td>
<td>比特型数组 signed</td>
</tr>
<tr>
<td>char[]</td>
<td>jcharArray</td>
<td>字符型数组 unsigned</td>
</tr>
<tr>
<td>short[]</td>
<td>jshortArray</td>
<td>短整型数组 signed</td>
</tr>
<tr>
<td>int[]</td>
<td>jintArray</td>
<td>整型数组 signed</td>
</tr>
<tr>
<td>long[]</td>
<td>jlongArray</td>
<td>长整型数组 signed</td>
</tr>
<tr>
<td>float[]</td>
<td>jfloatArray</td>
<td>浮点型数组</td>
</tr>
<tr>
<td>double[]</td>
<td>jdoubleArray</td>
<td>双浮点型数组</td>
</tr>
<tr>
<td>Object[]</td>
<td>jobjectArray</td>
<td>任何对象的数组</td>
</tr>
</tbody>
</table>
<p>数组类型多个Array后缀.  </p>
<p>JNI函数签名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello(JNIEnv *, jclass, jstring);</div></pre></td></tr></table></figure></p>
<p>第一个参数: <code>JNIEnv*</code> 是定义任意 <code>native</code> 函数的第一个参数(包括调用 JNI 的 <code>RegisterNatives</code> 函数注册的函数), 指向 JVM 函数表的指针, 函数表中的每一个入口指向一个 JNI 函数, 每个函数用于访问 JVM 中特定的数据结构.<br>第二个参数: 调用 Java 中 native 方法的实例或 Class 对象, 如果这个 <code>native</code> 方法是实例方法, 则该参数是 <code>jobject</code>,如果是静态方法，则是 <code>jclass</code>.<br>第三个参数: Java 对应 JNI 中的数据类型, Java 中 String 类型对应 JNI 的 jstring 类型. (前面已介绍 JAVA 与 JNI 数据类型的映射关系)  </p>
<p>函数签名也可以手动动态映射, 通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static JNINativeMethod gMethods[] = &#123;</div><div class="line">// 这里写映射关系数组</div><div class="line">// &#123;&quot;native函数名&quot;, &quot;参数列表&quot;, 对应的JNI方法&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中参数列表有个缩写映射规则,要用缩写表示Java类型.<br>当参数为引用类型的时候，参数类型的标示的格式为”L完整路径名;”,前面L后面分号.如果是数组就是在成员类型前面加[,有多少层加多少个[.例如String对应的就是<code>(Ljava/lang/String;)</code>  </p>
<table>
<thead>
<tr>
<th>类型标志</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>Ljava/lang/String</td>
<td>String</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>[I</td>
<td>Int[]</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>[Ljava/lang/object</td>
<td>Object[]</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
</tbody>
</table>
<p><code>javap</code>可以生成函数签名. <code>javap -s -p xxx</code>. 参数含义参见help.  </p>
<p>JNI层就相当于是在用C写东西了, 所以语法也是C的语法.<br>对于基本类型, 可以直接强制类型转换成对应长度的C/C++类型(事实上, 查看jni基本类型的定义可以发现, 它们都是c基本类型的<code>typedef</code>).<br>对于数组类型, 需要使用JNIEnv提供的方法, 简单类型的数组会把其指针直接暴露给本地代码. 一系列GetXXXArrayElements函数可以把Java数组作为参数, 返回一个指向对应的本地类型的数组指针.  </p>
<table>
<thead>
<tr>
<th>函数</th>
<th>Java 数组类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetBooleanArrayElements</td>
<td>jbooleanArray</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteArrayElements</td>
<td>jbyteArray</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharArrayElements</td>
<td>jcharArray</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortArrayElements</td>
<td>jshortArray</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntArrayElements</td>
<td>jintArray</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongArrayElements</td>
<td>jlongArray</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatArrayElements</td>
<td>jfloatArray</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleArrayElements</td>
<td>jdoubleArray</td>
<td>jdouble</td>
</tr>
</tbody>
</table>
<p>使用完之后要调用对应的ReleaseXXXArrayElements, 参数是对应的数组和前面GetXXXArrayElements返回的指针. 这个函数会把你对本地数组做的变化复制到Java数组中, 然后释放相关资源.<br>JNIEnv还有一些别的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GetArrayLength</div><div class="line"></div><div class="line">NewXXXArray</div><div class="line"></div><div class="line">GetXXXArrayElements</div><div class="line"></div><div class="line">ReleaseXXXArrayElements</div><div class="line"></div><div class="line">GetXXXArrayRegion</div><div class="line"></div><div class="line">SetXXXArrayRegion</div></pre></td></tr></table></figure></p>
<p>这些方法都是Env预定义的方法, 帮助你在C/C++的Array和Java的Array之间转换.  </p>
<h2 id="NDK用到的C-C-运行库"><a href="#NDK用到的C-C-运行库" class="headerlink" title="NDK用到的C/C++运行库"></a>NDK用到的C/C++运行库</h2><p>你在Android.mk文件中可以指定LOCAL_CPP_EXTENSION来告诉编译器, 把什么后缀的文件当做C++源文件来编译. 对于C和C++会采用不同的编译器. 不过，编译过后的C++程序想要执行，还必须要有C++运行环境（C++ Runtime）的支持。默认情况下，Android NDK会使用一个非常迷你的C++运行环境，称做“libstdc++”。这个运行环境几乎什么都没有，不支持异常和RTTI（RunTime Type Information，即运行时类型识别），甚至连C++标准库也没有。  </p>
<p><style><br>img {<br>  width: 600px;<br>  height: 400px;<br>  margin: auto;<br>}<br></style><br><img src="/images/blogs/c++runtimelibrary.jpg" alt="c++ runtime library">  </p>
<p><code>.a</code>是静态库, <code>.so</code>是动态库, 也叫共享库. 通过<code>Application.mk</code>的<code>APP_STL</code>可以配置想要用什么运行库, 需要注意的是Android源码目录的ndk子目录下面, 就有各个目标平台和架构的运行库, Android 8(Android 2.2)之前, 是只有默认的那个库.  </p>
<p>最后，还有一点需要注意，如果你的JNI功能都是包含在一个模块（也就是程序中只有一个.so文件）中的话，可以考虑用静态库C++运行时库的形式。而如果你的程序中包含了多个模块，请尽量使用动态C++运行时库。  </p>
<p>在用动态C++运行时库的时候，相应的动态库.so文件（默认的C++运行时库除外）会随你的程序一起发布出去，位于apk文件中的lib目录下。  </p>
<p>如果你的目标Android系统是4.3之前，那么你必须要在加载所有你自己的模块之前，显式的加载C++动态运行时库。  </p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html" target="_blank" rel="external">JNI版本加入的时间和版本间差异</a>  </p>
]]></content>
    
    <summary type="html">
    
      又叫【花样劝退教程】。本文讲NDK &amp; JNI基础
    
    </summary>
    
      <category term="android" scheme="https://hjhjw1991.github.io/categories/android/"/>
    
    
      <category term="guide" scheme="https://hjhjw1991.github.io/tags/guide/"/>
    
      <category term="android" scheme="https://hjhjw1991.github.io/tags/android/"/>
    
      <category term="interview" scheme="https://hjhjw1991.github.io/tags/interview/"/>
    
  </entry>
  
</feed>
